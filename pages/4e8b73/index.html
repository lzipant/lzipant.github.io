<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>CPU缓存的基础架构 | harrison&#39;s blog</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="后端技术博客,简洁至上,专注Java学习与总结。Java, Spring, SpringBoot, SpringCloud, MyBatis, Netty, RabbitMQ, Kafka, Dubbo, Linux, Linux Kernel等技术文章。">
    <meta name="keywords" content="后端技术博客">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="preload" href="/assets/css/0.styles.db69af13.css" as="style"><link rel="preload" href="/assets/js/app.36e91a11.js" as="script"><link rel="preload" href="/assets/js/2.409e0185.js" as="script"><link rel="preload" href="/assets/js/36.305c9ab9.js" as="script"><link rel="prefetch" href="/assets/js/10.1206fbe6.js"><link rel="prefetch" href="/assets/js/11.811b7408.js"><link rel="prefetch" href="/assets/js/12.83e62cf0.js"><link rel="prefetch" href="/assets/js/13.3da6fa14.js"><link rel="prefetch" href="/assets/js/14.be23cced.js"><link rel="prefetch" href="/assets/js/15.5b1701fd.js"><link rel="prefetch" href="/assets/js/16.3d55b70f.js"><link rel="prefetch" href="/assets/js/17.7429b142.js"><link rel="prefetch" href="/assets/js/18.796642e8.js"><link rel="prefetch" href="/assets/js/19.ffb2f3b3.js"><link rel="prefetch" href="/assets/js/20.9b77edb3.js"><link rel="prefetch" href="/assets/js/21.45f0bd1c.js"><link rel="prefetch" href="/assets/js/22.05843092.js"><link rel="prefetch" href="/assets/js/23.99984d12.js"><link rel="prefetch" href="/assets/js/24.6a89fd33.js"><link rel="prefetch" href="/assets/js/25.16160e78.js"><link rel="prefetch" href="/assets/js/26.471a561c.js"><link rel="prefetch" href="/assets/js/27.ff9b36a8.js"><link rel="prefetch" href="/assets/js/28.d235529f.js"><link rel="prefetch" href="/assets/js/29.ac8ca018.js"><link rel="prefetch" href="/assets/js/3.1c6d2763.js"><link rel="prefetch" href="/assets/js/30.96538408.js"><link rel="prefetch" href="/assets/js/31.47118b60.js"><link rel="prefetch" href="/assets/js/32.fb74aca4.js"><link rel="prefetch" href="/assets/js/33.d059016b.js"><link rel="prefetch" href="/assets/js/34.c1f0aff0.js"><link rel="prefetch" href="/assets/js/35.1b63946e.js"><link rel="prefetch" href="/assets/js/37.1f8690b8.js"><link rel="prefetch" href="/assets/js/38.6a0faec0.js"><link rel="prefetch" href="/assets/js/39.6a4f34cc.js"><link rel="prefetch" href="/assets/js/4.f0a8c30f.js"><link rel="prefetch" href="/assets/js/40.2d767369.js"><link rel="prefetch" href="/assets/js/41.f6602ec0.js"><link rel="prefetch" href="/assets/js/42.d86dc81f.js"><link rel="prefetch" href="/assets/js/43.3193e48c.js"><link rel="prefetch" href="/assets/js/44.ba2bfbed.js"><link rel="prefetch" href="/assets/js/45.c855ea02.js"><link rel="prefetch" href="/assets/js/46.cc0695f3.js"><link rel="prefetch" href="/assets/js/47.9356ab33.js"><link rel="prefetch" href="/assets/js/48.04ed80cc.js"><link rel="prefetch" href="/assets/js/49.3b625cf2.js"><link rel="prefetch" href="/assets/js/5.e688792f.js"><link rel="prefetch" href="/assets/js/50.45f22e5f.js"><link rel="prefetch" href="/assets/js/51.e28308a2.js"><link rel="prefetch" href="/assets/js/52.2d74a9f7.js"><link rel="prefetch" href="/assets/js/53.9ea65ca6.js"><link rel="prefetch" href="/assets/js/54.b92ef08c.js"><link rel="prefetch" href="/assets/js/55.c96f6cd9.js"><link rel="prefetch" href="/assets/js/56.66e76778.js"><link rel="prefetch" href="/assets/js/57.290715f8.js"><link rel="prefetch" href="/assets/js/58.68f33ada.js"><link rel="prefetch" href="/assets/js/59.a0c46087.js"><link rel="prefetch" href="/assets/js/6.feb75664.js"><link rel="prefetch" href="/assets/js/60.942b9285.js"><link rel="prefetch" href="/assets/js/7.3e34b1bc.js"><link rel="prefetch" href="/assets/js/8.e4dd00a2.js"><link rel="prefetch" href="/assets/js/9.74704eea.js">
    <link rel="stylesheet" href="/assets/css/0.styles.db69af13.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/HL-logo.png" alt="harrison's blog" class="logo"> <span class="site-name can-hide">harrison's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/categories/" class="nav-link">分类</a></div><div class="nav-item"><a href="/tags/" class="nav-link">标签</a></div><div class="nav-item"><a href="/archives/" class="nav-link">归档</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="收藏" class="dropdown-title"><!----> <span class="title" style="display:;">收藏</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/collections/websites/" class="nav-link">网站</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://cdn.jsdelivr.net/gh/HarrisonLee1998/image/avatar.jpg"> <div class="blogger-info"><h3>Harrison Lee</h3> <span>玻璃晴朗，橘子辉煌</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/categories/" class="nav-link">分类</a></div><div class="nav-item"><a href="/tags/" class="nav-link">标签</a></div><div class="nav-item"><a href="/archives/" class="nav-link">归档</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="收藏" class="dropdown-title"><!----> <span class="title" style="display:;">收藏</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/collections/websites/" class="nav-link">网站</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>缓存</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/4e8b73/" aria-current="page" class="active sidebar-link">CPU缓存的基础架构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/4e8b73/#缓存结构" class="sidebar-link">缓存结构</a></li><li class="sidebar-sub-header"><a href="/pages/4e8b73/#缓存读取" class="sidebar-link">缓存读取</a></li><li class="sidebar-sub-header"><a href="/pages/4e8b73/#缓存替换" class="sidebar-link">缓存替换</a></li><li class="sidebar-sub-header"><a href="/pages/4e8b73/#缓存写出" class="sidebar-link">缓存写出</a></li><li class="sidebar-sub-header"><a href="/pages/4e8b73/#多级缓存的包含策略" class="sidebar-link">多级缓存的包含策略</a></li><li class="sidebar-sub-header"><a href="/pages/4e8b73/#缓存寻址和地址转换后备缓冲区" class="sidebar-link">缓存寻址和地址转换后备缓冲区</a></li><li class="sidebar-sub-header"><a href="/pages/4e8b73/#非阻塞缓存" class="sidebar-link">非阻塞缓存</a></li><li class="sidebar-sub-header"><a href="/pages/4e8b73/#参考" class="sidebar-link">参考</a></li></ul></li><li><a href="/pages/856225/" class="sidebar-link">CPU缓存一致性协议概述</a></li><li><a href="/pages/35e881/" class="sidebar-link">CPU缓存一致性协议之MSI</a></li><li><a href="/pages/5709ee/" class="sidebar-link">CPU缓存一致性协议之MESI</a></li><li><a href="/pages/b770ae/" class="sidebar-link">CPU中的Store Buffers</a></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper bg-style-1"><div class="articleInfo-wrap" data-v-33863c7e><div class="articleInfo" data-v-33863c7e><ul class="breadcrumbs" data-v-33863c7e><li data-v-33863c7e><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-33863c7e></a></li> <li data-v-33863c7e><a href="/categories/?category=%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84" title="分类" data-v-33863c7e>计算机体系结构</a></li> <li data-v-33863c7e><a href="/categories/?category=%E7%BC%93%E5%AD%98" title="分类" data-v-33863c7e>缓存</a></li> <!----></ul> <div class="info" data-v-33863c7e><div title="作者" class="author iconfont icon-touxiang" data-v-33863c7e><a href="https://github.com/HarrisonLee1998" target="_blank" title="作者" class="beLink" data-v-33863c7e>Harrison Lee</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-33863c7e><a href="javascript:;" data-v-33863c7e>2020-12-13</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">
          CPU缓存的基础架构
        </h1> <!----> <div class="theme-vdoing-content content__default"><h2 id="缓存结构"><a href="#缓存结构" class="header-anchor">#</a> 缓存结构</h2> <p>一般情况下，缓存空间分为<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span></span>个组，每个组又分为<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span></span>行，在每一行中，存储了<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></span>字节（经过工业界的实践，目前缓存块一般为<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn><mi>B</mi></mrow><annotation encoding="application/x-tex">64B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></span>）的块（有效数据）以及有效位和标记位（元数据），所有缓存块的总大小为<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mi>S</mi><mo>×</mo><mi>E</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">C=S \times E \times B</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></span>个字节，元数据不包括在缓存空间大小内。
</p> <img src="https://cdn.harrisonlee.net/image-20201213153320307.png" width="60%" alt="缓存结构示意图(来自CSAPP)"> <p>内存地址被划分为三个部分，标记，组索引和块偏移：</p> <ul><li>标记：在每个组内唯一地标识缓存块，注意，在所有缓存块中该标识不唯一。</li> <li>组索引：确定该缓存块存放于哪个组中。</li> <li>块偏移：表示该地址在缓存块中的偏移地址。</li></ul> <p>根据组中所包含的行的数量，大体可以把映射关系分为三类：</p> <ul><li>直接映射（direct-mapped）：每个组只有一行。</li> <li>全相联（fully-associative）：整个缓存中只有一个组，组中包含所有的行。</li> <li>组相联（set-associative）：即上图中所示的情况，分为<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span></span>个组，每个组有<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span></span>行。</li></ul> <p>因为平衡直接映射和全相联的极端，组相联被广泛使用。</p> <h2 id="缓存读取"><a href="#缓存读取" class="header-anchor">#</a> 缓存读取</h2> <p>下图是CPU读取二路组相联缓存的过程示意图：</p> <img src="https://cdn.harrisonlee.net/image-20201213191928073.png" width="60%" alt="CPU读取缓存过程示意图"> <p>上图中一共列举了7个步骤。</p> <ol><li><p>根据目标地址求得缓存块应在的组索引。</p></li> <li><p>根据组索引在tag数组中获取相应组的标记。</p></li> <li><p>从目标地址中求得标识，然后在SA（sensor amplifier，读出放大器）中与第2步中取得的标记进行比较，目的是确认目标地址是否在缓存中。如果存在匹配，那么缓存命中（cache hit），否则，缓存未命中（cache miss）。</p></li> <li><p>在执行第2步和第3步的同时，从data数组中读取相应的缓存块。</p></li> <li><p>如果在第3步中存在匹配，那么取出对应的缓存块。</p></li> <li><p>根据地址中的缓存偏移（block offset）从第5步中取出的缓存块中读取数据。</p></li> <li><p>将第6步中读取的数据递交给CPU。</p></li></ol> <p>以上7个步骤只是一般过程，在一些高性能的缓存中，上述步骤可能采用流水线来提高缓存读取吞吐量，从而可以处理多个缓存读取请求。而且在现实中为了满足各种需求，整个过程会十分复杂。比如步骤1，步骤2和步骤4可能被线性或并行执行。</p> <ul><li><p>线性执行的优势是在确定缓存命中后，只需要读取data数组中同一组中对应的缓存块即可，如果缓存未命中，则不需要从data数组中读取数据。</p></li> <li><p>并行执行的优势是在确定缓存命中或未命中时，相应的数据块已经被读取到了，接下来仅需要做的是找到对应的数据块以及块中对应的数据，该方法在缓存命中时会更快，但是效率却不高（在缓存未命中时尤为明显），因为同一组中的数据块都被读取了。</p></li></ul> <p>在某些设计中，<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">L1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">1</span></span></span></span></span>缓存采用并行执行，而<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">L2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">2</span></span></span></span></span>和<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">L3</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">3</span></span></span></span></span>缓存采用线性执行，因为<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">L1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">1</span></span></span></span></span>缓存所要求达到的缓存命中率要更高，大部分情况下，步骤四不是徒劳的。</p> <h2 id="缓存替换"><a href="#缓存替换" class="header-anchor">#</a> 缓存替换</h2> <p>由于缓存空间远远小于主存空间，那么某些情况可能导致缓存满了，则需要进行缓存淘汰。具体的算法有下面几种：</p> <ul><li>最佳淘汰算法（OPT）： 该算法是理想化的，实际不能被实现。其指淘汰未来最久之后才使用的缓存块，由于不能确定未来的情况，所以该算法不能被实现，但是能够为其他算法的优劣提供评判依据。</li> <li>最近最少使用（LRU）： 该算法被广为使用，其指淘汰过去一段时间内最少使用的缓存块。但是该算法在循坏访问同一组中的缓存块时（其单次循环读取的缓存块数量大于每组容纳的数量），会导致性能下降（因为会不断地进行替换）。</li></ul> <h2 id="缓存写出"><a href="#缓存写出" class="header-anchor">#</a> 缓存写出</h2> <p>当CPU修改了缓存的值，何时写出到外围存储器（可能是次级缓存也可能是主存）中是个重要的问题。主要有两种实现：</p> <ul><li>写通（write through）：指缓存中的任何修改都会被立即写出到主存中。</li> <li>写回（write back）：指只有在缓存在被替换时，被修改过的缓存块才会被写出到外层存储器中，所以CPU的缓存行中需要一个比特位来标记该缓存行是否被更改过。</li></ul> <p>芯片最外层缓存通常会采用写回策略，因为写通会占用更多的总线带宽。</p> <p>另外，两者在容错性方面存在差异，由于某些软故障，可能会导致某些比特的值更改，从而使缓存块的值无效。写通策略的容错性更高一些，因为其有效数据已经被写到外围存储中了。采用写回策略的画，不仅需要错误探测，还需要错误纠正，通常采用纠错码（error correcting code [ECC]），但是ECC具有计算开销。因此，在很多实现中，<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">L1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">1</span></span></span></span></span>缓存采用写通策略，<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">L2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">2</span></span></span></span></span>缓存采用写回策略并用ECC加以保护数据。</p> <p>如果CPU所写的数据不在缓存中，那么也有两种实现：</p> <ul><li>写分配：在写之前，先从外层存储器中读取对应的缓存块，然后再修改。</li> <li>写不分配：直接写出到对外层存储器中。</li></ul> <p>如果所写内容所在的缓存块在将来不需要被读或写，那么采用写不分配会更佳，尤其是在内层缓存空间较小的情况下。反之，写分配更佳。写通策略既可以使用写分配也可以使用写不分配，而写回策略只有使用写分配策略。</p> <h2 id="多级缓存的包含策略"><a href="#多级缓存的包含策略" class="header-anchor">#</a> 多级缓存的包含策略</h2> <p>在多级缓存中，内层缓存的内容是否同时需要在外层缓存中存在，这就引入了一个缓存包含问题。</p> <ul><li>如果外围缓存包含内层缓存的数据，那么则称为包含（inclusive）。</li> <li>如果外围缓存不包含内层缓存的数据，那么则称为排斥（exclusive）。</li> <li>inclusive和exclusive都需要某些协议来实现，如果没有协议支持，则可以实现既不包含也不排斥策略（non-inclusive non-exclusive [NINE]）。</li></ul> <p>这里使用<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">L1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">1</span></span></span></span></span>（内层）和<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">L2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">2</span></span></span></span></span>（外层）缓存来举例，假设最开始，<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">L2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">2</span></span></span></span></span>缓存具有Z，<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">L1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">1</span></span></span></span></span>缓存为空。</p> <p>首先<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">L1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">1</span></span></span></span></span>缓存未命中X和Y，L2中也没有，那么则需要从主存中获取，这一步的状态如下图所示：</p> <p><img src="https://cdn.harrisonlee.net/image-20201213212558276.png" alt="image-20201213212558276"></p> <p>可见，在inclusive和NINE策略下，外层缓存保存了内层缓存的内容，则exclusive策略下，外层缓存则没有保存。</p> <p>接下来在<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">L1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">1</span></span></span></span></span>缓存淘汰X，这一步的状态如下图所示：</p> <p><img src="https://cdn.harrisonlee.net/image-20201213212838039.png" alt="image-20201213212838039"></p> <p>可见，在exclusive策略下，外层缓存“收留”了被淘汰的数据。对于另外两种策略，其外层缓存中肯定存在副本，所以内层缓存直接淘汰即可。</p> <p>接下来在<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">L2</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">2</span></span></span></span></span>缓存中淘汰Y，这一步的状态如下图所示：</p> <p><img src="https://cdn.harrisonlee.net/image-20201213213227938.png" alt="image-20201213213227938"></p> <p>在inclusive模式下，外层缓存中数据淘汰导致内层缓存也跟着淘汰（向上失效）。在NINE策略下，则仅仅淘汰外层缓存的数据。这也是NINE和inclusive策略的区别。</p> <p>最后，在<span class="vuepress-eq"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">L1</annotation></semantics></math></span><span aria-hidden="true" class="katex-html"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">1</span></span></span></span></span>未命中Z时，这一步的状态如下图所示：</p> <p><img src="https://cdn.harrisonlee.net/image-20201213214508636.png" alt="image-20201213214508636"></p> <p>在inclusive和NINE模式下，外层缓存都将数据拷贝到内层缓存中。而exclusive模式下，外层缓存在拷贝后将其淘汰掉。</p> <p>除了上面对三种策略的基本定义之外，还有更多特性：</p> <ul><li><p>inclusive策略：内层缓存所包含的数据一定在外层缓存中，外层缓存中没有的数据在内层缓存中一定没有。在某些核芯独享的缓存中遇到未命中的情况时，需要在其他核芯的缓存中去找，如果核芯数量多了，查找成本会很高，如果使用inclusive策略则不必去其他核芯中找，直接到外层缓存中找即可。</p></li> <li><p>NINE策略：内层缓存所包含的数据，外层缓存一定有；外层缓存没有的数据，内层缓存仍然可能有。</p></li> <li><p>exclusive策略：内存缓存所包含的数据，外层缓存一定没有，外层缓存包含的数据，内层缓存一定没有。</p></li> <li><p>inclusive策略下，缓存未命中延迟更短，而另外两种则更长些。就算所有的缓存中都没有数据，那么inclusive策略下，也会更快地向主存中获取数据。</p></li> <li><p>inclusive策略下，对外层缓存的利用率不高，尤其是在外层缓存的容量不大的情况下。</p></li> <li><p>exclusive策略下，整体上缓存能够存放更多不同的缓存块，同时也会导致频繁地填充新的缓存块（内层缓存每次淘汰的外层缓存都会进行“收留”）。</p></li> <li><p>NINE策略下，不保证缓存块的不存在。</p></li></ul> <p><font color="deeppink">综上所述，设计者应该根据具体的缓存空间大小计算整体的缓存利用率来决定使用哪一种策略。</font></p> <h2 id="缓存寻址和地址转换后备缓冲区"><a href="#缓存寻址和地址转换后备缓冲区" class="header-anchor">#</a> 缓存寻址和地址转换后备缓冲区</h2> <p>CPU根据指令进行寻址，然而寻址操作的操作数是进程的虚拟地址空间地址，而不是真实物理内存的地址。而缓存中是根据物理内存地址来存储缓存块的，所以在寻址之前，CPU需要先将虚拟地址空间转换为物理内存的地址。进程的页表是存放在主存中的，而CPU在访问缓存之前就要译址，所以CPU也考虑将页表缓存到缓冲区中，这就是TLB（translation lookaside buffer）的由来。</p> <h2 id="非阻塞缓存"><a href="#非阻塞缓存" class="header-anchor">#</a> 非阻塞缓存</h2> <p>在早期处理器中，当缓存未命中时，CPU一直等到缓存块被读取到缓存中为止，这严重降低了性能。所以现代处理器引入了未命中状态处理寄存器（miss status handling registers [MSHRs]）。当缓存未命中时，为该次未命中分配一个该寄存器来跟踪获取情况，当读取到缓存时，在回收掉该寄存器。当寄存器分配后，即可处理下一个缓存查找的任务，从而大大提升了效率。</p> <h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <ul><li><a href="https://book.douban.com/subject/26912767/" target="_blank" rel="noopener noreferrer">《深入理解计算机系统（第三版）》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://www.amazon.com/Fundamentals-Parallel-Multicore-Architecture-Solihin/dp/0367575280/ref=sr_1_1?crid=FJCGUSB0DB5A&amp;dchild=1&amp;keywords=fundamentals+of+parallel+multicore+architecture&amp;qid=1607872319&amp;sprefix=fundamental+of+para%2Caps%2C415&amp;sr=8-1" target="_blank" rel="noopener noreferrer">Fundamentals of Parallel Multicore Architecture <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div> <!----> <div class="page-edit"><!----> <div class="tags"><a href="/tags/?tag=Cache" title="标签">#Cache</a></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2021-01-19</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><!----> <a href="/pages/856225/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">CPU缓存一致性协议概述</div></a></div> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/pages/856225/">CPU缓存一致性协议概述</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/0c4c2e/"><div>Spring AOP基础</div></a> <span>02-08</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/e0358f/"><div>SpringBoot中Filter的注册</div></a> <span>02-07</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/226a87/"><div>Java中的Lambda表达式及原理</div></a> <span>01-29</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:lzipant@gmail.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/HarrisonLee1998" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2020-2021
    <span>Harrison Lee | <a href="https://github.com/xugaoyi/vuepress-theme-vdoing/blob/master/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">跟随系统</li><li class="iconfont icon-rijianmoshi">浅色模式</li><li class="iconfont icon-yejianmoshi">深色模式</li><li class="iconfont icon-yuedu">阅读模式</li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.36e91a11.js" defer></script><script src="/assets/js/2.409e0185.js" defer></script><script src="/assets/js/36.305c9ab9.js" defer></script>
  </body>
</html>