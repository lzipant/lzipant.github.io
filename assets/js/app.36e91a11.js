(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var r,i,s=e[0],l=e[1],c=e[2],p=0,u=[];p<s.length;p++)i=s[p],Object.prototype.hasOwnProperty.call(a,i)&&a[i]&&u.push(a[i][0]),a[i]=0;for(r in l)Object.prototype.hasOwnProperty.call(l,r)&&(n[r]=l[r]);for(d&&d(e);u.length;)u.shift()();return o.push.apply(o,c||[]),t()}function t(){for(var n,e=0;e<o.length;e++){for(var t=o[e],r=!0,s=1;s<t.length;s++){var l=t[s];0!==a[l]&&(r=!1)}r&&(o.splice(e--,1),n=i(i.s=t[0]))}return n}var r={},a={1:0},o=[];function i(e){if(r[e])return r[e].exports;var t=r[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,i),t.l=!0,t.exports}i.e=function(n){var e=[],t=a[n];if(0!==t)if(t)e.push(t[2]);else{var r=new Promise((function(e,r){t=a[n]=[e,r]}));e.push(t[2]=r);var o,s=document.createElement("script");s.charset="utf-8",s.timeout=120,i.nc&&s.setAttribute("nonce",i.nc),s.src=function(n){return i.p+"assets/js/"+({}[n]||n)+"."+{2:"409e0185",3:"1c6d2763",4:"f0a8c30f",5:"e688792f",6:"feb75664",7:"3e34b1bc",8:"e4dd00a2",9:"74704eea",10:"1206fbe6",11:"811b7408",12:"83e62cf0",13:"3da6fa14",14:"be23cced",15:"5b1701fd",16:"3d55b70f",17:"7429b142",18:"796642e8",19:"ffb2f3b3",20:"9b77edb3",21:"45f0bd1c",22:"05843092",23:"99984d12",24:"6a89fd33",25:"16160e78",26:"471a561c",27:"ff9b36a8",28:"d235529f",29:"ac8ca018",30:"96538408",31:"47118b60",32:"fb74aca4",33:"d059016b",34:"c1f0aff0",35:"1b63946e",36:"305c9ab9",37:"1f8690b8",38:"6a0faec0",39:"6a4f34cc",40:"2d767369",41:"f6602ec0",42:"d86dc81f",43:"3193e48c",44:"ba2bfbed",45:"c855ea02",46:"cc0695f3",47:"9356ab33",48:"04ed80cc",49:"3b625cf2",50:"45f22e5f",51:"e28308a2",52:"2d74a9f7",53:"9ea65ca6",54:"b92ef08c",55:"c96f6cd9",56:"66e76778",57:"290715f8",58:"68f33ada",59:"a0c46087",60:"942b9285"}[n]+".js"}(n);var l=new Error;o=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=a[n];if(0!==t){if(t){var r=e&&("load"===e.type?"missing":e.type),o=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+r+": "+o+")",l.name="ChunkLoadError",l.type=r,l.request=o,t[1](l)}a[n]=void 0}};var c=setTimeout((function(){o({type:"timeout",target:s})}),12e4);s.onerror=s.onload=o,document.head.appendChild(s)}return Promise.all(e)},i.m=n,i.c=r,i.d=function(n,e,t){i.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},i.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},i.t=function(n,e){if(1&e&&(n=i(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(i.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)i.d(t,r,function(e){return n[e]}.bind(null,r));return t},i.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return i.d(e,"a",e),e},i.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},i.p="/",i.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var d=l;o.push([246,0]),t()}([function(n,e,t){var r=t(2),a=t(38).f,o=t(26),i=t(21),s=t(121),l=t(176),c=t(72);n.exports=function(n,e){var t,d,p,u,h,m=n.target,f=n.global,g=n.stat;if(t=f?r:g?r[m]||s(m,{}):(r[m]||{}).prototype)for(d in e){if(u=e[d],p=n.noTargetGet?(h=a(t,d))&&h.value:t[d],!c(f?d:m+(g?".":"#")+d,n.forced)&&void 0!==p){if(typeof u==typeof p)continue;l(u,p)}(n.sham||p&&p.sham)&&o(u,"sham",!0),i(t,d,u,n)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){"use strict";t.d(e,"a",(function(){return r}));t(27),t(33),t(4),t(50),t(18),t(13);function r(n){return(r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}},function(n,e,t){var r=t(131),a=t(21),o=t(256);r||a(Object.prototype,"toString",o,{unsafe:!0})},function(n,e,t){var r=t(2),a=t(119),o=t(17),i=t(84),s=t(123),l=t(173),c=a("wks"),d=r.Symbol,p=l?d:d&&d.withoutSetter||i;n.exports=function(n){return o(c,n)&&(s||"string"==typeof c[n])||(s&&o(d,n)?c[n]=d[n]:c[n]=p("Symbol."+n)),c[n]}},function(n,e){n.exports=function(n){return"object"==typeof n?null!==n:"function"==typeof n}},function(n,e,t){var r=t(1);n.exports=!r((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var r=t(6);n.exports=function(n){if(!r(n))throw TypeError(String(n)+" is not an object");return n}},function(n,e,t){var r=t(32),a=Math.min;n.exports=function(n){return n>0?a(r(n),9007199254740991):0}},function(n,e,t){var r=t(7),a=t(171),o=t(8),i=t(62),s=Object.defineProperty;e.f=r?s:function(n,e,t){if(o(n),e=i(e,!0),o(t),a)try{return s(n,e,t)}catch(n){}if("get"in t||"set"in t)throw TypeError("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){function r(e){return"function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?(n.exports=r=function(n){return typeof n},n.exports.default=n.exports,n.exports.__esModule=!0):(n.exports=r=function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},n.exports.default=n.exports,n.exports.__esModule=!0),r(e)}t(27),t(33),t(4),t(50),t(18),t(13),n.exports=r,n.exports.default=n.exports,n.exports.__esModule=!0},function(n,e,t){"use strict";var r=t(0),a=t(94);r({target:"RegExp",proto:!0,forced:/./.exec!==a},{exec:a})},function(n,e,t){var r=t(2),a=t(186),o=t(156),i=t(26),s=t(5),l=s("iterator"),c=s("toStringTag"),d=o.values;for(var p in a){var u=r[p],h=u&&u.prototype;if(h){if(h[l]!==d)try{i(h,l,d)}catch(n){h[l]=d}if(h[c]||i(h,c,p),a[p])for(var m in o)if(h[m]!==o[m])try{i(h,m,o[m])}catch(n){h[m]=o[m]}}}},function(n,e,t){"use strict";var r=t(0),a=t(187);r({target:"Array",proto:!0,forced:[].forEach!=a},{forEach:a})},function(n,e,t){var r=t(2),a=t(186),o=t(187),i=t(26);for(var s in a){var l=r[s],c=l&&l.prototype;if(c&&c.forEach!==o)try{i(c,"forEach",o)}catch(n){c.forEach=o}}},function(n,e,t){"use strict";function r(n,e,t,r,a,o,i,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),r&&(c.functional=!0),o&&(c._scopeId="data-v-"+o),i?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),a&&a.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(i)},c._ssrRegister=l):a&&(l=s?function(){a.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:a),l)if(c.functional){c._injectStyles=l;var d=c.render;c.render=function(n,e){return l.call(e),d(n,e)}}else{var p=c.beforeCreate;c.beforeCreate=p?[].concat(p,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return r}))},function(n,e){var t={}.hasOwnProperty;n.exports=function(n,e){return t.call(n,e)}},function(n,e,t){"use strict";var r=t(165).charAt,a=t(37),o=t(126),i=a.set,s=a.getterFor("String Iterator");o(String,"String",(function(n){i(this,{type:"String Iterator",string:String(n),index:0})}),(function(){var n,e=s(this),t=e.string,a=e.index;return a>=t.length?{value:void 0,done:!0}:(n=r(t,a),e.index+=n.length,{value:n,done:!1})}))},function(n,e,t){var r=t(24);n.exports=function(n){return Object(r(n))}},function(n,e,t){var r=t(21),a=Date.prototype,o=a.toString,i=a.getTime;new Date(NaN)+""!="Invalid Date"&&r(a,"toString",(function(){var n=i.call(this);return n==n?o.call(this):"Invalid Date"}))},function(n,e,t){var r=t(2),a=t(26),o=t(17),i=t(121),s=t(125),l=t(37),c=l.get,d=l.enforce,p=String(String).split("String");(n.exports=function(n,e,t,s){var l,c=!!s&&!!s.unsafe,u=!!s&&!!s.enumerable,h=!!s&&!!s.noTargetGet;"function"==typeof t&&("string"!=typeof e||o(t,"name")||a(t,"name",e),(l=d(t)).source||(l.source=p.join("string"==typeof e?e:""))),n!==r?(c?!h&&n[e]&&(u=!0):delete n[e],u?n[e]=t:a(n,e,t)):u?n[e]=t:i(e,t)})(Function.prototype,"toString",(function(){return"function"==typeof this&&c(this).source||s(this)}))},function(n,e,t){"use strict";var r=t(0),a=t(52).filter;r({target:"Array",proto:!0,forced:!t(74)("filter")},{filter:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(93),a=t(8),o=t(9),i=t(32),s=t(24),l=t(136),c=t(259),d=t(95),p=Math.max,u=Math.min;r("replace",2,(function(n,e,t,r){var h=r.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE,m=r.REPLACE_KEEPS_$0,f=h?"$":"$0";return[function(t,r){var a=s(this),o=null==t?void 0:t[n];return void 0!==o?o.call(t,a,r):e.call(String(a),t,r)},function(n,r){if(!h&&m||"string"==typeof r&&-1===r.indexOf(f)){var s=t(e,n,this,r);if(s.done)return s.value}var g=a(n),v=String(this),b="function"==typeof r;b||(r=String(r));var y=g.global;if(y){var x=g.unicode;g.lastIndex=0}for(var w=[];;){var E=d(g,v);if(null===E)break;if(w.push(E),!y)break;""===String(E[0])&&(g.lastIndex=l(v,o(g.lastIndex),x))}for(var A,S="",M=0,C=0;C<w.length;C++){E=w[C];for(var k=String(E[0]),T=p(u(i(E.index),v.length),0),j=[],I=1;I<E.length;I++)j.push(void 0===(A=E[I])?A:String(A));var B=E.groups;if(b){var _=[k].concat(j,T,v);void 0!==B&&_.push(B);var L=String(r.apply(void 0,_))}else L=c(k,v,T,j,B,r);T>=M&&(S+=v.slice(M,T)+L,M=T+k.length)}return S+v.slice(M)}]}))},function(n,e){n.exports=function(n){if(null==n)throw TypeError("Can't call method on "+n);return n}},function(n,e,t){"use strict";var r=t(21),a=t(8),o=t(1),i=t(133),s=RegExp.prototype,l=s.toString,c=o((function(){return"/a/b"!=l.call({source:"a",flags:"b"})})),d="toString"!=l.name;(c||d)&&r(RegExp.prototype,"toString",(function(){var n=a(this),e=String(n.source),t=n.flags;return"/"+e+"/"+String(void 0===t&&n instanceof RegExp&&!("flags"in s)?i.call(n):t)}),{unsafe:!0})},function(n,e,t){var r=t(7),a=t(10),o=t(63);n.exports=r?function(n,e,t){return a.f(n,e,o(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){"use strict";var r=t(0),a=t(2),o=t(40),i=t(46),s=t(7),l=t(123),c=t(173),d=t(1),p=t(17),u=t(56),h=t(6),m=t(8),f=t(19),g=t(29),v=t(62),b=t(63),y=t(48),x=t(88),w=t(57),E=t(184),A=t(129),S=t(38),M=t(10),C=t(127),k=t(26),T=t(21),j=t(119),I=t(89),B=t(70),_=t(84),L=t(5),P=t(185),O=t(91),D=t(39),R=t(37),z=t(52).forEach,q=I("hidden"),H=L("toPrimitive"),F=R.set,N=R.getterFor("Symbol"),U=Object.prototype,J=a.Symbol,$=o("JSON","stringify"),V=S.f,W=M.f,G=E.f,X=C.f,K=j("symbols"),Y=j("op-symbols"),Z=j("string-to-symbol-registry"),Q=j("symbol-to-string-registry"),nn=j("wks"),en=a.QObject,tn=!en||!en.prototype||!en.prototype.findChild,rn=s&&d((function(){return 7!=y(W({},"a",{get:function(){return W(this,"a",{value:7}).a}})).a}))?function(n,e,t){var r=V(U,e);r&&delete U[e],W(n,e,t),r&&n!==U&&W(U,e,r)}:W,an=function(n,e){var t=K[n]=y(J.prototype);return F(t,{type:"Symbol",tag:n,description:e}),s||(t.description=e),t},on=c?function(n){return"symbol"==typeof n}:function(n){return Object(n)instanceof J},sn=function(n,e,t){n===U&&sn(Y,e,t),m(n);var r=v(e,!0);return m(t),p(K,r)?(t.enumerable?(p(n,q)&&n[q][r]&&(n[q][r]=!1),t=y(t,{enumerable:b(0,!1)})):(p(n,q)||W(n,q,b(1,{})),n[q][r]=!0),rn(n,r,t)):W(n,r,t)},ln=function(n,e){m(n);var t=g(e),r=x(t).concat(un(t));return z(r,(function(e){s&&!cn.call(t,e)||sn(n,e,t[e])})),n},cn=function(n){var e=v(n,!0),t=X.call(this,e);return!(this===U&&p(K,e)&&!p(Y,e))&&(!(t||!p(this,e)||!p(K,e)||p(this,q)&&this[q][e])||t)},dn=function(n,e){var t=g(n),r=v(e,!0);if(t!==U||!p(K,r)||p(Y,r)){var a=V(t,r);return!a||!p(K,r)||p(t,q)&&t[q][r]||(a.enumerable=!0),a}},pn=function(n){var e=G(g(n)),t=[];return z(e,(function(n){p(K,n)||p(B,n)||t.push(n)})),t},un=function(n){var e=n===U,t=G(e?Y:g(n)),r=[];return z(t,(function(n){!p(K,n)||e&&!p(U,n)||r.push(K[n])})),r};(l||(T((J=function(){if(this instanceof J)throw TypeError("Symbol is not a constructor");var n=arguments.length&&void 0!==arguments[0]?String(arguments[0]):void 0,e=_(n),t=function(n){this===U&&t.call(Y,n),p(this,q)&&p(this[q],e)&&(this[q][e]=!1),rn(this,e,b(1,n))};return s&&tn&&rn(U,e,{configurable:!0,set:t}),an(e,n)}).prototype,"toString",(function(){return N(this).tag})),T(J,"withoutSetter",(function(n){return an(_(n),n)})),C.f=cn,M.f=sn,S.f=dn,w.f=E.f=pn,A.f=un,P.f=function(n){return an(L(n),n)},s&&(W(J.prototype,"description",{configurable:!0,get:function(){return N(this).description}}),i||T(U,"propertyIsEnumerable",cn,{unsafe:!0}))),r({global:!0,wrap:!0,forced:!l,sham:!l},{Symbol:J}),z(x(nn),(function(n){O(n)})),r({target:"Symbol",stat:!0,forced:!l},{for:function(n){var e=String(n);if(p(Z,e))return Z[e];var t=J(e);return Z[e]=t,Q[t]=e,t},keyFor:function(n){if(!on(n))throw TypeError(n+" is not a symbol");if(p(Q,n))return Q[n]},useSetter:function(){tn=!0},useSimple:function(){tn=!1}}),r({target:"Object",stat:!0,forced:!l,sham:!s},{create:function(n,e){return void 0===e?y(n):ln(y(n),e)},defineProperty:sn,defineProperties:ln,getOwnPropertyDescriptor:dn}),r({target:"Object",stat:!0,forced:!l},{getOwnPropertyNames:pn,getOwnPropertySymbols:un}),r({target:"Object",stat:!0,forced:d((function(){A.f(1)}))},{getOwnPropertySymbols:function(n){return A.f(f(n))}}),$)&&r({target:"JSON",stat:!0,forced:!l||d((function(){var n=J();return"[null]"!=$([n])||"{}"!=$({a:n})||"{}"!=$(Object(n))}))},{stringify:function(n,e,t){for(var r,a=[n],o=1;arguments.length>o;)a.push(arguments[o++]);if(r=e,(h(e)||void 0!==n)&&!on(n))return u(e)||(e=function(n,e){if("function"==typeof r&&(e=r.call(this,n,e)),!on(e))return e}),a[1]=e,$.apply(null,a)}});J.prototype[H]||k(J.prototype,H,J.prototype.valueOf),D(J,"Symbol"),B[q]=!0},function(n,e,t){"use strict";var r=t(0),a=t(6),o=t(56),i=t(64),s=t(9),l=t(29),c=t(73),d=t(5),p=t(74)("slice"),u=d("species"),h=[].slice,m=Math.max;r({target:"Array",proto:!0,forced:!p},{slice:function(n,e){var t,r,d,p=l(this),f=s(p.length),g=i(n,f),v=i(void 0===e?f:e,f);if(o(p)&&("function"!=typeof(t=p.constructor)||t!==Array&&!o(t.prototype)?a(t)&&null===(t=t[u])&&(t=void 0):t=void 0,t===Array||void 0===t))return h.call(p,g,v);for(r=new(void 0===t?Array:t)(m(v-g,0)),d=0;g<v;g++,d++)g in p&&c(r,d,p[g]);return r.length=d,r}})},function(n,e,t){var r=t(68),a=t(24);n.exports=function(n){return r(a(n))}},function(n,e,t){var r=t(0),a=t(2),o=t(69),i=[].slice,s=function(n){return function(e,t){var r=arguments.length>2,a=r?i.call(arguments,2):void 0;return n(r?function(){("function"==typeof e?e:Function(e)).apply(this,a)}:e,t)}};r({global:!0,bind:!0,forced:/MSIE .\./.test(o)},{setTimeout:s(a.setTimeout),setInterval:s(a.setInterval)})},function(n,e,t){"use strict";var r=t(0),a=t(52).map;r({target:"Array",proto:!0,forced:!t(74)("map")},{map:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e){var t=Math.ceil,r=Math.floor;n.exports=function(n){return isNaN(n=+n)?0:(n>0?r:t)(n)}},function(n,e,t){"use strict";var r=t(0),a=t(7),o=t(2),i=t(17),s=t(6),l=t(10).f,c=t(176),d=o.Symbol;if(a&&"function"==typeof d&&(!("description"in d.prototype)||void 0!==d().description)){var p={},u=function(){var n=arguments.length<1||void 0===arguments[0]?void 0:String(arguments[0]),e=this instanceof u?new d(n):void 0===n?d():d(n);return""===n&&(p[e]=!0),e};c(u,d);var h=u.prototype=d.prototype;h.constructor=u;var m=h.toString,f="Symbol(test)"==String(d("test")),g=/^Symbol\((.*)\)[^)]+$/;l(h,"description",{configurable:!0,get:function(){var n=s(this)?this.valueOf():this,e=m.call(n);if(i(p,n))return"";var t=f?e.slice(7,-1):e.replace(g,"$1");return""===t?void 0:t}}),r({global:!0,forced:!0},{Symbol:u})}},function(n,e,t){t(49);var r=Array.isArray;n.exports=r},function(n,e,t){var r=t(11).default,a=t(194),o="object"==("undefined"==typeof self?"undefined":r(self))&&self&&self.Object===Object&&self,i=a||o||Function("return this")();n.exports=i},function(n,e,t){var r=t(0),a=t(7);r({target:"Object",stat:!0,forced:!a,sham:!a},{defineProperty:t(10).f})},function(n,e,t){var r,a,o,i=t(247),s=t(2),l=t(6),c=t(26),d=t(17),p=t(120),u=t(89),h=t(70),m=s.WeakMap;if(i){var f=p.state||(p.state=new m),g=f.get,v=f.has,b=f.set;r=function(n,e){return e.facade=n,b.call(f,n,e),e},a=function(n){return g.call(f,n)||{}},o=function(n){return v.call(f,n)}}else{var y=u("state");h[y]=!0,r=function(n,e){return e.facade=n,c(n,y,e),e},a=function(n){return d(n,y)?n[y]:{}},o=function(n){return d(n,y)}}n.exports={set:r,get:a,has:o,enforce:function(n){return o(n)?a(n):r(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=a(e)).type!==n)throw TypeError("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var r=t(7),a=t(127),o=t(63),i=t(29),s=t(62),l=t(17),c=t(171),d=Object.getOwnPropertyDescriptor;e.f=r?d:function(n,e){if(n=i(n),e=s(e,!0),c)try{return d(n,e)}catch(n){}if(l(n,e))return o(!a.f.call(n,e),n[e])}},function(n,e,t){var r=t(10).f,a=t(17),o=t(5)("toStringTag");n.exports=function(n,e,t){n&&!a(n=t?n:n.prototype,o)&&r(n,o,{configurable:!0,value:e})}},function(n,e,t){var r=t(172),a=t(2),o=function(n){return"function"==typeof n?n:void 0};n.exports=function(n,e){return arguments.length<2?o(r[n])||o(a[n]):r[n]&&r[n][e]||a[n]&&a[n][e]}},function(n,e){n.exports=function(n){if("function"!=typeof n)throw TypeError(String(n)+" is not a function");return n}},function(n,e){var t={}.toString;n.exports=function(n){return t.call(n).slice(8,-1)}},function(n,e,t){"use strict";var r=t(0),a=t(109).indexOf,o=t(47),i=[].indexOf,s=!!i&&1/[1].indexOf(1,-0)<0,l=o("indexOf");r({target:"Array",proto:!0,forced:s||!l},{indexOf:function(n){return s?i.apply(this,arguments)||0:a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(7),a=t(10).f,o=Function.prototype,i=o.toString,s=/^\s*function ([^ (]*)/;r&&!("name"in o)&&a(o,"name",{configurable:!0,get:function(){try{return i.call(this).match(s)[1]}catch(n){return""}}})},function(n,e,t){var r=t(0),a=t(19),o=t(88);r({target:"Object",stat:!0,forced:t(1)((function(){o(1)}))},{keys:function(n){return o(a(n))}})},function(n,e){n.exports=!1},function(n,e,t){"use strict";var r=t(1);n.exports=function(n,e){var t=[][n];return!!t&&r((function(){t.call(null,e||function(){throw 1},1)}))}},function(n,e,t){var r,a=t(8),o=t(163),i=t(124),s=t(70),l=t(175),c=t(122),d=t(89),p=d("IE_PROTO"),u=function(){},h=function(n){return"<script>"+n+"<\/script>"},m=function(){try{r=document.domain&&new ActiveXObject("htmlfile")}catch(n){}var n,e;m=r?function(n){n.write(h("")),n.close();var e=n.parentWindow.Object;return n=null,e}(r):((e=c("iframe")).style.display="none",l.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(h("document.F=Object")),n.close(),n.F);for(var t=i.length;t--;)delete m.prototype[i[t]];return m()};s[p]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(u.prototype=a(n),t=new u,u.prototype=null,t[p]=n):t=m(),void 0===e?t:o(t,e)}},function(n,e,t){t(0)({target:"Array",stat:!0},{isArray:t(56)})},function(n,e,t){t(91)("iterator")},function(n,e,t){var r=t(283),a=t(286);n.exports=function(n,e){var t=a(n,e);return r(t)?t:void 0}},function(n,e,t){var r=t(61),a=t(68),o=t(19),i=t(9),s=t(107),l=[].push,c=function(n){var e=1==n,t=2==n,c=3==n,d=4==n,p=6==n,u=7==n,h=5==n||p;return function(m,f,g,v){for(var b,y,x=o(m),w=a(x),E=r(f,g,3),A=i(w.length),S=0,M=v||s,C=e?M(m,A):t||u?M(m,0):void 0;A>S;S++)if((h||S in w)&&(y=E(b=w[S],S,x),n))if(e)C[S]=y;else if(y)switch(n){case 3:return!0;case 5:return b;case 6:return S;case 2:l.call(C,b)}else switch(n){case 4:return!1;case 7:l.call(C,b)}return p?-1:c||d?d:C}};n.exports={forEach:c(0),map:c(1),filter:c(2),some:c(3),every:c(4),find:c(5),findIndex:c(6),filterOut:c(7)}},function(n,e,t){"use strict";var r=t(0),a=t(1),o=t(56),i=t(6),s=t(19),l=t(9),c=t(73),d=t(107),p=t(74),u=t(5),h=t(66),m=u("isConcatSpreadable"),f=h>=51||!a((function(){var n=[];return n[m]=!1,n.concat()[0]!==n})),g=p("concat"),v=function(n){if(!i(n))return!1;var e=n[m];return void 0!==e?!!e:o(n)};r({target:"Array",proto:!0,forced:!f||!g},{concat:function(n){var e,t,r,a,o,i=s(this),p=d(i,0),u=0;for(e=-1,r=arguments.length;e<r;e++)if(v(o=-1===e?i:arguments[e])){if(u+(a=l(o.length))>9007199254740991)throw TypeError("Maximum allowed index exceeded");for(t=0;t<a;t++,u++)t in o&&c(p,u,o[t])}else{if(u>=9007199254740991)throw TypeError("Maximum allowed index exceeded");c(p,u++,o)}return p.length=u,p}})},function(n,e,t){"use strict";t.d(e,"e",(function(){return r})),t.d(e,"b",(function(){return o})),t.d(e,"j",(function(){return i})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return d})),t.d(e,"c",(function(){return p})),t.d(e,"f",(function(){return u})),t.d(e,"l",(function(){return h})),t.d(e,"m",(function(){return m})),t.d(e,"d",(function(){return g})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return x}));t(23),t(12),t(78),t(59),t(60),t(31),t(14),t(15),t(22),t(49),t(43),t(4),t(20),t(53),t(170),t(25);var r=/#.*$/,a=/\.(md|html)$/,o=/\/$/,i=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(r,"").replace(a,"")}function l(n){return i.test(n)}function c(n){return/^mailto:/.test(n)}function d(n){return/^tel:/.test(n)}function p(n){if(l(n))return n;var e=n.match(r),t=e?e[0]:"",a=s(n);return o.test(a)?n:a+".html"+t}function u(n,e){var t=n.hash,a=function(n){var e=n.match(r);if(e)return e[0]}(e);return(!a||t===a)&&s(n.path)===s(e)}function h(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var o=n.replace(/^\//,"").split("/"),i=0;i<o.length;i++){var s=o[i];".."===s?a.pop():"."!==s&&a.push(s)}""!==a[0]&&a.unshift("");return a.join("/")}(e,t));for(var r=s(e),a=0;a<n.length;a++)if(s(n[a].regularPath)===r)return Object.assign({},n[a],{type:"page",path:p(n[a].path)});return console.error('[vuepress] No matching page found for sidebar item "'.concat(e,'"')),{}}function m(n,e,t,r){var a=t.pages,o=t.themeConfig,i=r&&o.locales&&o.locales[r]||o;if("auto"===(n.frontmatter.sidebar||i.sidebar||o.sidebar))return f(n);var s=i.sidebar||o.sidebar;if(s){var l=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(var t in e)if(0===(r=n,/(\.html|\/)$/.test(r)?r:r+"/").indexOf(encodeURI(t)))return{base:t,config:e[t]};var r;return{}}(e,s),c=l.base,d=l.config;return"auto"===d?f(n):d?d.map((function(n){return function n(e,t,r){var a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;if("string"==typeof e)return h(t,e,r);if(Array.isArray(e))return Object.assign(h(t,e[0],r),{title:e[1]});a>3&&console.error("[vuepress] detected a too deep nested sidebar group.");var o=e.children||[];return 0===o.length&&e.path?Object.assign(h(t,e.path,r),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:o.map((function(e){return n(e,t,r,a+1)})),collapsable:!1!==e.collapsable}}(n,a,c)})):[]}return[]}function f(n){var e=g(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map((function(e){return{type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}}))}]}function g(n){var e;return(n=n.map((function(n){return Object.assign({},n)}))).forEach((function(n){2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)})),n.filter((function(n){return 2===n.level}))}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){var e=n.frontmatter.date||n.lastUpdated,t=new Date(e);return"Invalid Date"==t&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return y(e)-y(n)}},function(n,e,t){t(0)({target:"Object",stat:!0,sham:!t(7)},{create:t(48)})},function(n,e,t){var r=t(42);n.exports=Array.isArray||function(n){return"Array"==r(n)}},function(n,e,t){var r=t(174),a=t(124).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return r(n,a)}},function(n,e,t){var r=t(11).default;n.exports=function(n){return null!=n&&"object"==r(n)}},function(n,e,t){"use strict";var r=t(93),a=t(134),o=t(8),i=t(24),s=t(79),l=t(136),c=t(9),d=t(95),p=t(94),u=t(1),h=[].push,m=Math.min,f=!u((function(){return!RegExp(4294967295,"y")}));r("split",2,(function(n,e,t){var r;return r="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(n,t){var r=String(i(this)),o=void 0===t?4294967295:t>>>0;if(0===o)return[];if(void 0===n)return[r];if(!a(n))return e.call(r,n,o);for(var s,l,c,d=[],u=(n.ignoreCase?"i":"")+(n.multiline?"m":"")+(n.unicode?"u":"")+(n.sticky?"y":""),m=0,f=new RegExp(n.source,u+"g");(s=p.call(f,r))&&!((l=f.lastIndex)>m&&(d.push(r.slice(m,s.index)),s.length>1&&s.index<r.length&&h.apply(d,s.slice(1)),c=s[0].length,m=l,d.length>=o));)f.lastIndex===s.index&&f.lastIndex++;return m===r.length?!c&&f.test("")||d.push(""):d.push(r.slice(m)),d.length>o?d.slice(0,o):d}:"0".split(void 0,0).length?function(n,t){return void 0===n&&0===t?[]:e.call(this,n,t)}:e,[function(e,t){var a=i(this),o=null==e?void 0:e[n];return void 0!==o?o.call(e,a,t):r.call(String(a),e,t)},function(n,a){var i=t(r,n,this,a,r!==e);if(i.done)return i.value;var p=o(n),u=String(this),h=s(p,RegExp),g=p.unicode,v=(p.ignoreCase?"i":"")+(p.multiline?"m":"")+(p.unicode?"u":"")+(f?"y":"g"),b=new h(f?p:"^(?:"+p.source+")",v),y=void 0===a?4294967295:a>>>0;if(0===y)return[];if(0===u.length)return null===d(b,u)?[u]:[];for(var x=0,w=0,E=[];w<u.length;){b.lastIndex=f?w:0;var A,S=d(b,f?u:u.slice(w));if(null===S||(A=m(c(b.lastIndex+(f?0:w)),u.length))===x)w=l(u,w,g);else{if(E.push(u.slice(x,w)),E.length===y)return E;for(var M=1;M<=S.length-1;M++)if(E.push(S[M]),E.length===y)return E;w=x=A}}return E.push(u.slice(x)),E}]}),!f)},function(n,e,t){"use strict";var r=t(0),a=t(68),o=t(29),i=t(47),s=[].join,l=a!=Object,c=i("join",",");r({target:"Array",proto:!0,forced:l||!c},{join:function(n){return s.call(o(this),void 0===n?",":n)}})},function(n,e,t){var r=t(41);n.exports=function(n,e,t){if(r(n),void 0===e)return n;switch(t){case 0:return function(){return n.call(e)};case 1:return function(t){return n.call(e,t)};case 2:return function(t,r){return n.call(e,t,r)};case 3:return function(t,r,a){return n.call(e,t,r,a)}}return function(){return n.apply(e,arguments)}}},function(n,e,t){var r=t(6);n.exports=function(n,e){if(!r(n))return n;var t,a;if(e&&"function"==typeof(t=n.toString)&&!r(a=t.call(n)))return a;if("function"==typeof(t=n.valueOf)&&!r(a=t.call(n)))return a;if(!e&&"function"==typeof(t=n.toString)&&!r(a=t.call(n)))return a;throw TypeError("Can't convert object to primitive value")}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var r=t(32),a=Math.max,o=Math.min;n.exports=function(n,e){var t=r(n);return t<0?a(t+e,0):o(t,e)}},function(n,e,t){var r=t(42),a=t(2);n.exports="process"==r(a.process)},function(n,e,t){var r,a,o=t(2),i=t(69),s=o.process,l=s&&s.versions,c=l&&l.v8;c?a=(r=c.split("."))[0]+r[1]:i&&(!(r=i.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=i.match(/Chrome\/(\d+)/))&&(a=r[1]),n.exports=a&&+a},function(n,e,t){var r=t(75),a=t(268),o=t(269),i=r?r.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":i&&i in Object(n)?a(n):o(n)}},function(n,e,t){var r=t(1),a=t(42),o="".split;n.exports=r((function(){return!Object("z").propertyIsEnumerable(0)}))?function(n){return"String"==a(n)?o.call(n,""):Object(n)}:Object},function(n,e,t){var r=t(40);n.exports=r("navigator","userAgent")||""},function(n,e){n.exports={}},function(n,e){n.exports={}},function(n,e,t){var r=t(1),a=/#|\.prototype\./,o=function(n,e){var t=s[i(n)];return t==c||t!=l&&("function"==typeof e?r(e):!!e)},i=o.normalize=function(n){return String(n).replace(a,".").toLowerCase()},s=o.data={},l=o.NATIVE="N",c=o.POLYFILL="P";n.exports=o},function(n,e,t){"use strict";var r=t(62),a=t(10),o=t(63);n.exports=function(n,e,t){var i=r(e);i in n?a.f(n,i,o(0,t)):n[i]=t}},function(n,e,t){var r=t(1),a=t(5),o=t(66),i=a("species");n.exports=function(n){return o>=51||!r((function(){var e=[];return(e.constructor={})[i]=function(){return{foo:1}},1!==e[n](Boolean).foo}))}},function(n,e,t){var r=t(35).Symbol;n.exports=r},function(n,e,t){"use strict";t.d(e,"a",(function(){return o}));t(49);var r=t(77);t(27),t(33),t(4),t(50),t(18),t(13),t(168);var a=t(101);function o(n){return function(n){if(Array.isArray(n))return Object(r.a)(n)}(n)||function(n){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(n))return Array.from(n)}(n)||Object(a.a)(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";function r(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,r=new Array(e);t<e;t++)r[t]=n[t];return r}t.d(e,"a",(function(){return r}))},function(n,e,t){"use strict";var r=t(93),a=t(8),o=t(9),i=t(24),s=t(136),l=t(95);r("match",1,(function(n,e,t){return[function(e){var t=i(this),r=null==e?void 0:e[n];return void 0!==r?r.call(e,t):new RegExp(e)[n](String(t))},function(n){var r=t(e,n,this);if(r.done)return r.value;var i=a(n),c=String(this);if(!i.global)return l(i,c);var d=i.unicode;i.lastIndex=0;for(var p,u=[],h=0;null!==(p=l(i,c));){var m=String(p[0]);u[h]=m,""===m&&(i.lastIndex=s(c,o(i.lastIndex),d)),h++}return 0===h?null:u}]}))},function(n,e,t){var r=t(8),a=t(41),o=t(5)("species");n.exports=function(n,e){var t,i=r(n).constructor;return void 0===i||null==(t=r(i)[o])?e:a(t)}},function(n,e,t){"use strict";var r=t(0),a=t(64),o=t(32),i=t(9),s=t(19),l=t(107),c=t(73),d=t(74)("splice"),p=Math.max,u=Math.min;r({target:"Array",proto:!0,forced:!d},{splice:function(n,e){var t,r,d,h,m,f,g=s(this),v=i(g.length),b=a(n,v),y=arguments.length;if(0===y?t=r=0:1===y?(t=0,r=v-b):(t=y-2,r=u(p(o(e),0),v-b)),v+t-r>9007199254740991)throw TypeError("Maximum allowed length exceeded");for(d=l(g,r),h=0;h<r;h++)(m=b+h)in g&&c(d,h,g[m]);if(d.length=r,t<r){for(h=b;h<v-r;h++)f=h+t,(m=h+r)in g?g[f]=g[m]:delete g[f];for(h=v;h>v-r+t;h--)delete g[h-1]}else if(t>r)for(h=v-r;h>b;h--)f=h+t-1,(m=h+r-1)in g?g[f]=g[m]:delete g[f];for(h=0;h<t;h++)g[h+b]=arguments[h+2];return g.length=v-r+t,d}})},function(n,e){n.exports=function(n,e,t){if(!(n instanceof e))throw TypeError("Incorrect "+(t?t+" ":"")+"invocation");return n}},function(n,e,t){var r=t(8),a=t(248);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set).call(t,[]),e=t instanceof Array}catch(n){}return function(t,o){return r(t),a(o),e?n.call(t,o):t.__proto__=o,t}}():void 0)},function(n,e,t){var r=t(24),a="["+t(92)+"]",o=RegExp("^"+a+a+"*"),i=RegExp(a+a+"*$"),s=function(n){return function(e){var t=String(r(e));return 1&n&&(t=t.replace(o,"")),2&n&&(t=t.replace(i,"")),t}};n.exports={start:s(1),end:s(2),trim:s(3)}},function(n,e){var t=0,r=Math.random();n.exports=function(n){return"Symbol("+String(void 0===n?"":n)+")_"+(++t+r).toString(36)}},function(n,e,t){var r=t(17),a=t(19),o=t(89),i=t(178),s=o("IE_PROTO"),l=Object.prototype;n.exports=i?Object.getPrototypeOf:function(n){return n=a(n),r(n,s)?n[s]:"function"==typeof n.constructor&&n instanceof n.constructor?n.constructor.prototype:n instanceof Object?l:null}},function(n,e,t){"use strict";var r=t(40),a=t(10),o=t(5),i=t(7),s=o("species");n.exports=function(n){var e=r(n),t=a.f;i&&e&&!e[s]&&t(e,s,{configurable:!0,get:function(){return this}})}},function(n,e,t){var r=t(0),a=t(1),o=t(19),i=t(85),s=t(178);r({target:"Object",stat:!0,forced:a((function(){i(1)})),sham:!s},{getPrototypeOf:function(n){return i(o(n))}})},function(n,e,t){var r=t(174),a=t(124);n.exports=Object.keys||function(n){return r(n,a)}},function(n,e,t){var r=t(119),a=t(84),o=r("keys");n.exports=function(n){return o[n]||(o[n]=a(n))}},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(4);function r(n,e,t,r,a,o,i){try{var s=n[o](i),l=s.value}catch(n){return void t(n)}s.done?e(l):Promise.resolve(l).then(r,a)}function a(n){return function(){var e=this,t=arguments;return new Promise((function(a,o){var i=n.apply(e,t);function s(n){r(i,a,o,s,l,"next",n)}function l(n){r(i,a,o,s,l,"throw",n)}s(void 0)}))}}},function(n,e,t){var r=t(172),a=t(17),o=t(185),i=t(10).f;n.exports=function(n){var e=r.Symbol||(r.Symbol={});a(e,n)||i(e,n,{value:o.f(n)})}},function(n,e){n.exports="\t\n\v\f\r                　\u2028\u2029\ufeff"},function(n,e,t){"use strict";t(12);var r=t(21),a=t(1),o=t(5),i=t(94),s=t(26),l=o("species"),c=!a((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")})),d="$0"==="a".replace(/./,"$0"),p=o("replace"),u=!!/./[p]&&""===/./[p]("a","$0"),h=!a((function(){var n=/(?:)/,e=n.exec;n.exec=function(){return e.apply(this,arguments)};var t="ab".split(n);return 2!==t.length||"a"!==t[0]||"b"!==t[1]}));n.exports=function(n,e,t,p){var m=o(n),f=!a((function(){var e={};return e[m]=function(){return 7},7!=""[n](e)})),g=f&&!a((function(){var e=!1,t=/a/;return"split"===n&&((t={}).constructor={},t.constructor[l]=function(){return t},t.flags="",t[m]=/./[m]),t.exec=function(){return e=!0,null},t[m](""),!e}));if(!f||!g||"replace"===n&&(!c||!d||u)||"split"===n&&!h){var v=/./[m],b=t(m,""[n],(function(n,e,t,r,a){return e.exec===i?f&&!a?{done:!0,value:v.call(e,t,r)}:{done:!0,value:n.call(t,e,r)}:{done:!1}}),{REPLACE_KEEPS_$0:d,REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE:u}),y=b[0],x=b[1];r(String.prototype,n,y),r(RegExp.prototype,m,2==e?function(n,e){return x.call(n,this,e)}:function(n){return x.call(n,this)})}p&&s(RegExp.prototype[m],"sham",!0)}},function(n,e,t){"use strict";var r,a,o=t(133),i=t(190),s=RegExp.prototype.exec,l=String.prototype.replace,c=s,d=(r=/a/,a=/b*/g,s.call(r,"a"),s.call(a,"a"),0!==r.lastIndex||0!==a.lastIndex),p=i.UNSUPPORTED_Y||i.BROKEN_CARET,u=void 0!==/()??/.exec("")[1];(d||u||p)&&(c=function(n){var e,t,r,a,i=this,c=p&&i.sticky,h=o.call(i),m=i.source,f=0,g=n;return c&&(-1===(h=h.replace("y","")).indexOf("g")&&(h+="g"),g=String(n).slice(i.lastIndex),i.lastIndex>0&&(!i.multiline||i.multiline&&"\n"!==n[i.lastIndex-1])&&(m="(?: "+m+")",g=" "+g,f++),t=new RegExp("^(?:"+m+")",h)),u&&(t=new RegExp("^"+m+"$(?!\\s)",h)),d&&(e=i.lastIndex),r=s.call(c?t:i,g),c?r?(r.input=r.input.slice(f),r[0]=r[0].slice(f),r.index=i.lastIndex,i.lastIndex+=r[0].length):i.lastIndex=0:d&&r&&(i.lastIndex=i.global?r.index+r[0].length:e),u&&r&&r.length>1&&l.call(r[0],t,(function(){for(a=1;a<arguments.length-2;a++)void 0===arguments[a]&&(r[a]=void 0)})),r}),n.exports=c},function(n,e,t){var r=t(42),a=t(94);n.exports=function(n,e){var t=n.exec;if("function"==typeof t){var o=t.call(n,e);if("object"!=typeof o)throw TypeError("RegExp exec method returned something other than an Object or null");return o}if("RegExp"!==r(n))throw TypeError("RegExp#exec called on incompatible receiver");return a.call(n,e)}},function(n,e,t){var r=t(273),a=t(274),o=t(275),i=t(276),s=t(277);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(196);n.exports=function(n,e){for(var t=n.length;t--;)if(r(n[t][0],e))return t;return-1}},function(n,e,t){var r=t(51)(Object,"create");n.exports=r},function(n,e,t){t(31);var r=t(295);n.exports=function(n,e){var t=n.__data__;return r(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var r=t(145);n.exports=function(n){if("string"==typeof n||r(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(28),t(4),t(44),t(168),t(18);var r=t(77);function a(n,e){if(n){if("string"==typeof n)return Object(r.a)(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Object(r.a)(n,e):void 0}}},function(n,e,t){var r,a;t(11).default;t(30),t(23),t(12),t(28),t(43),void 0===(a="function"==typeof(r=function(){var n,e,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function a(n,e,t){return n<e?e:n>t?t:n}function o(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(r[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=a(n,r.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(r.barSelector),d=r.speed,p=r.easing;return l.offsetWidth,i((function(e){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var a;return(a="translate3d"===r.positionUsing?{transform:"translate3d("+o(n)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+o(n)+"%,0)"}:{"margin-left":o(n)+"%"}).transition="all "+e+"ms "+t,a}(n,d,p)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){return t.status||t.set(0),r.trickle&&function n(){setTimeout((function(){t.status&&(t.trickle(),n())}),r.trickleSpeed)}(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*a(Math.random()*e,.1,.95)),e=a(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},n=0,e=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===e&&t.start(),n++,e++,r.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=r.template;var a,i=e.querySelector(r.barSelector),l=n?"-100":o(t.status||0),d=document.querySelector(r.parent);return s(i,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),r.showSpinner||(a=e.querySelector(r.spinnerSelector))&&u(a),d!=document.body&&c(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(r.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&u(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var i=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var r,a=n.length,o=e.charAt(0).toUpperCase()+e.slice(1);a--;)if((r=n[a]+o)in t)return r;return e}(t))}function r(n,e,r){e=t(e),n.style[e]=r}return function(n,e){var t,a,o=arguments;if(2==o.length)for(t in e)void 0!==(a=e[t])&&e.hasOwnProperty(t)&&r(n,t,a);else r(n,o[1],o[2])}}();function l(n,e){return("string"==typeof n?n:p(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=p(n),r=t+e;l(t,e)||(n.className=r.substring(1))}function d(n,e){var t,r=p(n);l(n,e)&&(t=r.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function p(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function u(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?r.call(e,t,e,n):r)||(n.exports=a)},function(n,e,t){"use strict";var r=t(0),a=t(52).some;r({target:"Array",proto:!0,forced:!t(47)("some")},{some:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){t(0)({target:"Function",proto:!0},{bind:t(191)})},function(n,e,t){var r=t(7),a=t(2),o=t(72),i=t(118),s=t(10).f,l=t(57).f,c=t(134),d=t(133),p=t(190),u=t(21),h=t(1),m=t(37).set,f=t(86),g=t(5)("match"),v=a.RegExp,b=v.prototype,y=/a/g,x=/a/g,w=new v(y)!==y,E=p.UNSUPPORTED_Y;if(r&&o("RegExp",!w||E||h((function(){return x[g]=!1,v(y)!=y||v(x)==x||"/a/i"!=v(y,"i")})))){for(var A=function(n,e){var t,r=this instanceof A,a=c(n),o=void 0===e;if(!r&&a&&n.constructor===A&&o)return n;w?a&&!o&&(n=n.source):n instanceof A&&(o&&(e=d.call(n)),n=n.source),E&&(t=!!e&&e.indexOf("y")>-1)&&(e=e.replace(/y/g,""));var s=i(w?new v(n,e):v(n,e),r?this:b,A);return E&&t&&m(s,{sticky:t}),s},S=function(n){n in A||s(A,n,{configurable:!0,get:function(){return v[n]},set:function(e){v[n]=e}})},M=l(v),C=0;M.length>C;)S(M[C++]);b.constructor=A,A.prototype=b,u(a,"RegExp",A)}f("RegExp")},function(n,e,t){"use strict";var r=t(0),a=t(41),o=t(19),i=t(1),s=t(47),l=[],c=l.sort,d=i((function(){l.sort(void 0)})),p=i((function(){l.sort(null)})),u=s("sort");r({target:"Array",proto:!0,forced:d||!p||!u},{sort:function(n){return void 0===n?c.call(o(this)):c.call(o(this),a(n))}})},function(n,e,t){var r=t(6),a=t(56),o=t(5)("species");n.exports=function(n,e){var t;return a(n)&&("function"!=typeof(t=n.constructor)||t!==Array&&!a(t.prototype)?r(t)&&null===(t=t[o])&&(t=void 0):t=void 0),new(void 0===t?Array:t)(0===e?0:e)}},function(n,e,t){"use strict";var r=t(0),a=t(83).trim;r({target:"String",proto:!0,forced:t(228)("trim")},{trim:function(){return a(this)}})},function(n,e,t){var r=t(29),a=t(9),o=t(64),i=function(n){return function(e,t,i){var s,l=r(e),c=a(l.length),d=o(i,c);if(n&&t!=t){for(;c>d;)if((s=l[d++])!=s)return!0}else for(;c>d;d++)if((n||d in l)&&l[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:i(!0),indexOf:i(!1)}},function(n,e,t){t(36),n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e,t){var r=t(21);n.exports=function(n,e,t){for(var a in e)r(n,a,e[a],t);return n}},function(n,e,t){var r=t(5)("iterator"),a=!1;try{var o=0,i={next:function(){return{done:!!o++}},return:function(){a=!0}};i[r]=function(){return this},Array.from(i,(function(){throw 2}))}catch(n){}n.exports=function(n,e){if(!e&&!a)return!1;var t=!1;try{var o={};o[r]=function(){return{next:function(){return{done:t=!0}}}},n(o)}catch(n){}return t}},function(n,e,t){t(91)("toStringTag")},function(n,e,t){t(39)(Math,"Math",!0)},function(n,e,t){var r=t(2);t(39)(r.JSON,"JSON",!0)},function(n,e,t){t(0)({target:"Object",stat:!0},{setPrototypeOf:t(82)})},function(n,e,t){var r=t(0),a=t(189),o=t(1),i=t(6),s=t(135).onFreeze,l=Object.freeze;r({target:"Object",stat:!0,forced:o((function(){l(1)})),sham:!a},{freeze:function(n){return l&&i(n)?l(s(n)):n}})},function(n,e,t){var r=t(6),a=t(82);n.exports=function(n,e,t){var o,i;return a&&"function"==typeof(o=e.constructor)&&o!==t&&r(i=o.prototype)&&i!==t.prototype&&a(n,i),n}},function(n,e,t){var r=t(46),a=t(120);(n.exports=function(n,e){return a[n]||(a[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.9.1",mode:r?"pure":"global",copyright:"© 2021 Denis Pushkarev (zloirock.ru)"})},function(n,e,t){var r=t(2),a=t(121),o=r["__core-js_shared__"]||a("__core-js_shared__",{});n.exports=o},function(n,e,t){var r=t(2),a=t(26);n.exports=function(n,e){try{a(r,n,e)}catch(t){r[n]=e}return e}},function(n,e,t){var r=t(2),a=t(6),o=r.document,i=a(o)&&a(o.createElement);n.exports=function(n){return i?o.createElement(n):{}}},function(n,e,t){var r=t(65),a=t(66),o=t(1);n.exports=!!Object.getOwnPropertySymbols&&!o((function(){return!Symbol.sham&&(r?38===a:a>37&&a<41)}))},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var r=t(120),a=Function.toString;"function"!=typeof r.inspectSource&&(r.inspectSource=function(n){return a.call(n)}),n.exports=r.inspectSource},function(n,e,t){"use strict";var r=t(0),a=t(233),o=t(85),i=t(82),s=t(39),l=t(26),c=t(21),d=t(5),p=t(46),u=t(71),h=t(177),m=h.IteratorPrototype,f=h.BUGGY_SAFARI_ITERATORS,g=d("iterator"),v=function(){return this};n.exports=function(n,e,t,d,h,b,y){a(t,e,d);var x,w,E,A=function(n){if(n===h&&T)return T;if(!f&&n in C)return C[n];switch(n){case"keys":case"values":case"entries":return function(){return new t(this,n)}}return function(){return new t(this)}},S=e+" Iterator",M=!1,C=n.prototype,k=C[g]||C["@@iterator"]||h&&C[h],T=!f&&k||A(h),j="Array"==e&&C.entries||k;if(j&&(x=o(j.call(new n)),m!==Object.prototype&&x.next&&(p||o(x)===m||(i?i(x,m):"function"!=typeof x[g]&&l(x,g,v)),s(x,S,!0,!0),p&&(u[S]=v))),"values"==h&&k&&"values"!==k.name&&(M=!0,T=function(){return k.call(this)}),p&&!y||C[g]===T||l(C,g,T),u[e]=T,h)if(w={values:A("values"),keys:b?T:A("keys"),entries:A("entries")},y)for(E in w)(f||M||!(E in C))&&c(C,E,w[E]);else r({target:e,proto:!0,forced:f||M},w);return w}},function(n,e,t){"use strict";var r={}.propertyIsEnumerable,a=Object.getOwnPropertyDescriptor,o=a&&!r.call({1:2},1);e.f=o?function(n){var e=a(this,n);return!!e&&e.enumerable}:r},function(n,e,t){var r=t(40),a=t(57),o=t(129),i=t(8);n.exports=r("Reflect","ownKeys")||function(n){var e=a.f(i(n)),t=o.f;return t?e.concat(t(n)):e}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var r=t(8),a=t(164),o=t(9),i=t(61),s=t(153),l=t(180),c=function(n,e){this.stopped=n,this.result=e};n.exports=function(n,e,t){var d,p,u,h,m,f,g,v=t&&t.that,b=!(!t||!t.AS_ENTRIES),y=!(!t||!t.IS_ITERATOR),x=!(!t||!t.INTERRUPTED),w=i(e,v,1+b+x),E=function(n){return d&&l(d),new c(!0,n)},A=function(n){return b?(r(n),x?w(n[0],n[1],E):w(n[0],n[1])):x?w(n,E):w(n)};if(y)d=n;else{if("function"!=typeof(p=s(n)))throw TypeError("Target is not iterable");if(a(p)){for(u=0,h=o(n.length);h>u;u++)if((m=A(n[u]))&&m instanceof c)return m;return new c(!1)}d=p.call(n)}for(f=d.next;!(g=f.call(d)).done;){try{m=A(g.value)}catch(n){throw l(d),n}if("object"==typeof m&&m&&m instanceof c)return m}return new c(!1)}},function(n,e,t){var r={};r[t(5)("toStringTag")]="z",n.exports="[object z]"===String(r)},function(n,e,t){var r,a,o,i=t(2),s=t(1),l=t(61),c=t(175),d=t(122),p=t(181),u=t(65),h=i.location,m=i.setImmediate,f=i.clearImmediate,g=i.process,v=i.MessageChannel,b=i.Dispatch,y=0,x={},w=function(n){if(x.hasOwnProperty(n)){var e=x[n];delete x[n],e()}},E=function(n){return function(){w(n)}},A=function(n){w(n.data)},S=function(n){i.postMessage(n+"",h.protocol+"//"+h.host)};m&&f||(m=function(n){for(var e=[],t=1;arguments.length>t;)e.push(arguments[t++]);return x[++y]=function(){("function"==typeof n?n:Function(n)).apply(void 0,e)},r(y),y},f=function(n){delete x[n]},u?r=function(n){g.nextTick(E(n))}:b&&b.now?r=function(n){b.now(E(n))}:v&&!p?(o=(a=new v).port2,a.port1.onmessage=A,r=l(o.postMessage,o,1)):i.addEventListener&&"function"==typeof postMessage&&!i.importScripts&&h&&"file:"!==h.protocol&&!s(S)?(r=S,i.addEventListener("message",A,!1)):r="onreadystatechange"in d("script")?function(n){c.appendChild(d("script")).onreadystatechange=function(){c.removeChild(this),w(n)}}:function(n){setTimeout(E(n),0)}),n.exports={set:m,clear:f}},function(n,e,t){"use strict";var r=t(8);n.exports=function(){var n=r(this),e="";return n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.dotAll&&(e+="s"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},function(n,e,t){var r=t(6),a=t(42),o=t(5)("match");n.exports=function(n){var e;return r(n)&&(void 0!==(e=n[o])?!!e:"RegExp"==a(n))}},function(n,e,t){var r=t(70),a=t(6),o=t(17),i=t(10).f,s=t(84),l=t(189),c=s("meta"),d=0,p=Object.isExtensible||function(){return!0},u=function(n){i(n,c,{value:{objectID:"O"+ ++d,weakData:{}}})},h=n.exports={REQUIRED:!1,fastKey:function(n,e){if(!a(n))return"symbol"==typeof n?n:("string"==typeof n?"S":"P")+n;if(!o(n,c)){if(!p(n))return"F";if(!e)return"E";u(n)}return n[c].objectID},getWeakData:function(n,e){if(!o(n,c)){if(!p(n))return!0;if(!e)return!1;u(n)}return n[c].weakData},onFreeze:function(n){return l&&h.REQUIRED&&p(n)&&!o(n,c)&&u(n),n}};r[c]=!0},function(n,e,t){"use strict";var r=t(165).charAt;n.exports=function(n,e,t){return e+(t?r(n,e).length:1)}},function(n,e,t){var r=t(0),a=t(7);r({target:"Object",stat:!0,forced:!a,sham:!a},{defineProperties:t(163)})},function(n,e,t){var r=t(267),a=t(58),o=Object.prototype,i=o.hasOwnProperty,s=o.propertyIsEnumerable,l=r(function(){return arguments}())?r:function(n){return a(n)&&i.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var r=t(51)(t(35),"Map");n.exports=r},function(n,e,t){var r=t(11).default;n.exports=function(n){var e=r(n);return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var r=t(287),a=t(294),o=t(296),i=t(297),s=t(298);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){t(14),t(15),n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var r=t(11).default,a=t(34),o=t(145),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,s=/^\w*$/;n.exports=function(n,e){if(a(n))return!1;var t=r(n);return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!o(n))||(s.test(n)||!i.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var r=t(11).default,a=t(67),o=t(58);n.exports=function(n){return"symbol"==r(n)||o(n)&&"[object Symbol]"==a(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){"use strict";var r=t(32),a=t(24);n.exports="".repeat||function(n){var e=String(a(this)),t="",o=r(n);if(o<0||o==1/0)throw RangeError("Wrong number of repetitions");for(;o>0;(o>>>=1)&&(e+=e))1&o&&(t+=e);return t}},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(49);t(27),t(33),t(4),t(50),t(18),t(13);var r=t(101);function a(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(n)){var t=[],r=!0,a=!1,o=void 0;try{for(var i,s=n[Symbol.iterator]();!(r=(i=s.next()).done)&&(t.push(i.value),!e||t.length!==e);r=!0);}catch(n){a=!0,o=n}finally{try{r||null==s.return||s.return()}finally{if(a)throw o}}return t}}(n,e)||Object(r.a)(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";var r=t(7),a=t(2),o=t(72),i=t(21),s=t(17),l=t(42),c=t(118),d=t(62),p=t(1),u=t(48),h=t(57).f,m=t(38).f,f=t(10).f,g=t(83).trim,v=a.Number,b=v.prototype,y="Number"==l(u(b)),x=function(n){var e,t,r,a,o,i,s,l,c=d(n,!1);if("string"==typeof c&&c.length>2)if(43===(e=(c=g(c)).charCodeAt(0))||45===e){if(88===(t=c.charCodeAt(2))||120===t)return NaN}else if(48===e){switch(c.charCodeAt(1)){case 66:case 98:r=2,a=49;break;case 79:case 111:r=8,a=55;break;default:return+c}for(i=(o=c.slice(2)).length,s=0;s<i;s++)if((l=o.charCodeAt(s))<48||l>a)return NaN;return parseInt(o,r)}return+c};if(o("Number",!v(" 0o1")||!v("0b1")||v("+0x1"))){for(var w,E=function(n){var e=arguments.length<1?0:n,t=this;return t instanceof E&&(y?p((function(){b.valueOf.call(t)})):"Number"!=l(t))?c(new v(x(e)),t,E):x(e)},A=r?h(v):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger,fromString,range".split(","),S=0;A.length>S;S++)s(v,w=A[S])&&!s(E,w)&&f(E,w,m(v,w));E.prototype=b,b.constructor=E,i(a,"Number",E)}},function(n,e,t){var r=t(5),a=t(48),o=t(10),i=r("unscopables"),s=Array.prototype;null==s[i]&&o.f(s,i,{configurable:!0,value:a(null)}),n.exports=function(n){s[i][n]=!0}},function(n,e,t){var r=t(0),a=t(263);r({global:!0,forced:parseInt!=a},{parseInt:a})},function(n,e,t){"use strict";t.d(e,"a",(function(){return o}));t(45),t(27),t(22),t(192),t(14),t(15),t(188),t(137),t(36);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function o(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}},function(n,e,t){var r=t(154),a=t(71),o=t(5)("iterator");n.exports=function(n){if(null!=n)return n[o]||n["@@iterator"]||a[r(n)]}},function(n,e,t){var r=t(131),a=t(42),o=t(5)("toStringTag"),i="Arguments"==a(function(){return arguments}());n.exports=r?a:function(n){var e,t,r;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=Object(n),o))?t:i?a(e):"Object"==(r=a(e))&&"function"==typeof e.callee?"Arguments":r}},function(n,e,t){"use strict";var r=t(0),a=t(52).every;r({target:"Array",proto:!0,forced:!t(47)("every")},{every:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(29),a=t(150),o=t(71),i=t(37),s=t(126),l=i.set,c=i.getterFor("Array Iterator");n.exports=s(Array,"Array",(function(n,e){l(this,{type:"Array Iterator",target:r(n),index:0,kind:e})}),(function(){var n=c(this),e=n.target,t=n.kind,r=n.index++;return!e||r>=e.length?(n.target=void 0,{value:void 0,done:!0}):"keys"==t?{value:r,done:!1}:"values"==t?{value:e[r],done:!1}:{value:[r,e[r]],done:!1}}),"values"),o.Arguments=o.Array,a("keys"),a("values"),a("entries")},function(n,e,t){(function(n){var e=t(11).default;t(27),t(33),t(4),t(50),t(18),t(13),t(257),t(113),t(114),t(115),t(36),t(55),t(87),t(14),t(44),t(116),t(25),t(20),t(15),t(158),t(28);var r=function(n){"use strict";var t=Object.prototype,r=t.hasOwnProperty,a="function"==typeof Symbol?Symbol:{},o=a.iterator||"@@iterator",i=a.asyncIterator||"@@asyncIterator",s=a.toStringTag||"@@toStringTag";function l(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{l({},"")}catch(n){l=function(n,e,t){return n[e]=t}}function c(n,e,t,r){var a=e&&e.prototype instanceof u?e:u,o=Object.create(a.prototype),i=new S(r||[]);return o._invoke=function(n,e,t){var r="suspendedStart";return function(a,o){if("executing"===r)throw new Error("Generator is already running");if("completed"===r){if("throw"===a)throw o;return C()}for(t.method=a,t.arg=o;;){var i=t.delegate;if(i){var s=w(i,t);if(s){if(s===p)continue;return s}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===r)throw r="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);r="executing";var l=d(n,e,t);if("normal"===l.type){if(r=t.done?"completed":"suspendedYield",l.arg===p)continue;return{value:l.arg,done:t.done}}"throw"===l.type&&(r="completed",t.method="throw",t.arg=l.arg)}}}(n,t,i),o}function d(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(n){return{type:"throw",arg:n}}}n.wrap=c;var p={};function u(){}function h(){}function m(){}var f={};f[o]=function(){return this};var g=Object.getPrototypeOf,v=g&&g(g(M([])));v&&v!==t&&r.call(v,o)&&(f=v);var b=m.prototype=u.prototype=Object.create(f);function y(n){["next","throw","return"].forEach((function(e){l(n,e,(function(n){return this._invoke(e,n)}))}))}function x(n,t){var a;this._invoke=function(o,i){function s(){return new t((function(a,s){!function a(o,i,s,l){var c=d(n[o],n,i);if("throw"!==c.type){var p=c.arg,u=p.value;return u&&"object"===e(u)&&r.call(u,"__await")?t.resolve(u.__await).then((function(n){a("next",n,s,l)}),(function(n){a("throw",n,s,l)})):t.resolve(u).then((function(n){p.value=n,s(p)}),(function(n){return a("throw",n,s,l)}))}l(c.arg)}(o,i,a,s)}))}return a=a?a.then(s,s):s()}}function w(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,w(n,e),"throw"===e.method))return p;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return p}var r=d(t,n.iterator,e.arg);if("throw"===r.type)return e.method="throw",e.arg=r.arg,e.delegate=null,p;var a=r.arg;return a?a.done?(e[n.resultName]=a.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,p):a:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,p)}function E(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function A(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function S(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(E,this),this.reset(!0)}function M(n){if(n){var e=n[o];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var t=-1,a=function e(){for(;++t<n.length;)if(r.call(n,t))return e.value=n[t],e.done=!1,e;return e.value=void 0,e.done=!0,e};return a.next=a}}return{next:C}}function C(){return{value:void 0,done:!0}}return h.prototype=b.constructor=m,m.constructor=h,h.displayName=l(m,s,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===h||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,m):(n.__proto__=m,l(n,s,"GeneratorFunction")),n.prototype=Object.create(b),n},n.awrap=function(n){return{__await:n}},y(x.prototype),x.prototype[i]=function(){return this},n.AsyncIterator=x,n.async=function(e,t,r,a,o){void 0===o&&(o=Promise);var i=new x(c(e,t,r,a),o);return n.isGeneratorFunction(t)?i:i.next().then((function(n){return n.done?n.value:i.next()}))},y(b),l(b,s,"Generator"),b[o]=function(){return this},b.toString=function(){return"[object Generator]"},n.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var r=e.pop();if(r in n)return t.value=r,t.done=!1,t}return t.done=!0,t}},n.values=M,S.prototype={constructor:S,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(A),!n)for(var e in this)"t"===e.charAt(0)&&r.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function t(t,r){return i.type="throw",i.arg=n,e.next=t,r&&(e.method="next",e.arg=void 0),!!r}for(var a=this.tryEntries.length-1;a>=0;--a){var o=this.tryEntries[a],i=o.completion;if("root"===o.tryLoc)return t("end");if(o.tryLoc<=this.prev){var s=r.call(o,"catchLoc"),l=r.call(o,"finallyLoc");if(s&&l){if(this.prev<o.catchLoc)return t(o.catchLoc,!0);if(this.prev<o.finallyLoc)return t(o.finallyLoc)}else if(s){if(this.prev<o.catchLoc)return t(o.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<o.finallyLoc)return t(o.finallyLoc)}}}},abrupt:function(n,e){for(var t=this.tryEntries.length-1;t>=0;--t){var a=this.tryEntries[t];if(a.tryLoc<=this.prev&&r.call(a,"finallyLoc")&&this.prev<a.finallyLoc){var o=a;break}}o&&("break"===n||"continue"===n)&&o.tryLoc<=e&&e<=o.finallyLoc&&(o=null);var i=o?o.completion:{};return i.type=n,i.arg=e,o?(this.method="next",this.next=o.finallyLoc,p):this.complete(i)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),p},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),A(t),p}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var r=t.completion;if("throw"===r.type){var a=r.arg;A(t)}return a}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:M(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),p}},n}("object"===e(n)?n.exports:{});try{regeneratorRuntime=r}catch(n){Function("r","regeneratorRuntime = r")(r)}}).call(this,t(110)(n))},function(n,e,t){"use strict";var r=t(0),a=t(56),o=[].reverse,i=[1,2];r({target:"Array",proto:!0,forced:String(i)===String(i.reverse())},{reverse:function(){return a(this)&&(this.length=this.length),o.call(this)}})},function(n,e,t){var r=t(134);n.exports=function(n){if(r(n))throw TypeError("The method doesn't accept regular expressions");return n}},function(n,e,t){var r=t(5)("match");n.exports=function(n){var e=/./;try{"/./"[n](e)}catch(t){try{return e[r]=!1,"/./"[n](e)}catch(n){}}return!1}},function(n,e,t){var r=t(0),a=t(258);r({global:!0,forced:parseFloat!=a},{parseFloat:a})},function(n,e,t){"use strict";var r=t(2),a=t(7),o=t(230),i=t(26),s=t(111),l=t(1),c=t(81),d=t(32),p=t(9),u=t(240),h=t(323),m=t(85),f=t(82),g=t(57).f,v=t(10).f,b=t(226),y=t(39),x=t(37),w=x.get,E=x.set,A=r.ArrayBuffer,S=A,M=r.DataView,C=M&&M.prototype,k=Object.prototype,T=r.RangeError,j=h.pack,I=h.unpack,B=function(n){return[255&n]},_=function(n){return[255&n,n>>8&255]},L=function(n){return[255&n,n>>8&255,n>>16&255,n>>24&255]},P=function(n){return n[3]<<24|n[2]<<16|n[1]<<8|n[0]},O=function(n){return j(n,23,4)},D=function(n){return j(n,52,8)},R=function(n,e){v(n.prototype,e,{get:function(){return w(this)[e]}})},z=function(n,e,t,r){var a=u(t),o=w(n);if(a+e>o.byteLength)throw T("Wrong index");var i=w(o.buffer).bytes,s=a+o.byteOffset,l=i.slice(s,s+e);return r?l:l.reverse()},q=function(n,e,t,r,a,o){var i=u(t),s=w(n);if(i+e>s.byteLength)throw T("Wrong index");for(var l=w(s.buffer).bytes,c=i+s.byteOffset,d=r(+a),p=0;p<e;p++)l[c+p]=d[o?p:e-p-1]};if(o){if(!l((function(){A(1)}))||!l((function(){new A(-1)}))||l((function(){return new A,new A(1.5),new A(NaN),"ArrayBuffer"!=A.name}))){for(var H,F=(S=function(n){return c(this,S),new A(u(n))}).prototype=A.prototype,N=g(A),U=0;N.length>U;)(H=N[U++])in S||i(S,H,A[H]);F.constructor=S}f&&m(C)!==k&&f(C,k);var J=new M(new S(2)),$=C.setInt8;J.setInt8(0,2147483648),J.setInt8(1,2147483649),!J.getInt8(0)&&J.getInt8(1)||s(C,{setInt8:function(n,e){$.call(this,n,e<<24>>24)},setUint8:function(n,e){$.call(this,n,e<<24>>24)}},{unsafe:!0})}else S=function(n){c(this,S,"ArrayBuffer");var e=u(n);E(this,{bytes:b.call(new Array(e),0),byteLength:e}),a||(this.byteLength=e)},M=function(n,e,t){c(this,M,"DataView"),c(n,S,"DataView");var r=w(n).byteLength,o=d(e);if(o<0||o>r)throw T("Wrong offset");if(o+(t=void 0===t?r-o:p(t))>r)throw T("Wrong length");E(this,{buffer:n,byteLength:t,byteOffset:o}),a||(this.buffer=n,this.byteLength=t,this.byteOffset=o)},a&&(R(S,"byteLength"),R(M,"buffer"),R(M,"byteLength"),R(M,"byteOffset")),s(M.prototype,{getInt8:function(n){return z(this,1,n)[0]<<24>>24},getUint8:function(n){return z(this,1,n)[0]},getInt16:function(n){var e=z(this,2,n,arguments.length>1?arguments[1]:void 0);return(e[1]<<8|e[0])<<16>>16},getUint16:function(n){var e=z(this,2,n,arguments.length>1?arguments[1]:void 0);return e[1]<<8|e[0]},getInt32:function(n){return P(z(this,4,n,arguments.length>1?arguments[1]:void 0))},getUint32:function(n){return P(z(this,4,n,arguments.length>1?arguments[1]:void 0))>>>0},getFloat32:function(n){return I(z(this,4,n,arguments.length>1?arguments[1]:void 0),23)},getFloat64:function(n){return I(z(this,8,n,arguments.length>1?arguments[1]:void 0),52)},setInt8:function(n,e){q(this,1,n,B,e)},setUint8:function(n,e){q(this,1,n,B,e)},setInt16:function(n,e){q(this,2,n,_,e,arguments.length>2?arguments[2]:void 0)},setUint16:function(n,e){q(this,2,n,_,e,arguments.length>2?arguments[2]:void 0)},setInt32:function(n,e){q(this,4,n,L,e,arguments.length>2?arguments[2]:void 0)},setUint32:function(n,e){q(this,4,n,L,e,arguments.length>2?arguments[2]:void 0)},setFloat32:function(n,e){q(this,4,n,O,e,arguments.length>2?arguments[2]:void 0)},setFloat64:function(n,e){q(this,8,n,D,e,arguments.length>2?arguments[2]:void 0)}});y(S,"ArrayBuffer"),y(M,"DataView"),n.exports={ArrayBuffer:S,DataView:M}},function(n,e,t){var r=t(7),a=t(10),o=t(8),i=t(88);n.exports=r?Object.defineProperties:function(n,e){o(n);for(var t,r=i(e),s=r.length,l=0;s>l;)a.f(n,t=r[l++],e[t]);return n}},function(n,e,t){var r=t(5),a=t(71),o=r("iterator"),i=Array.prototype;n.exports=function(n){return void 0!==n&&(a.Array===n||i[o]===n)}},function(n,e,t){var r=t(32),a=t(24),o=function(n){return function(e,t){var o,i,s=String(a(e)),l=r(t),c=s.length;return l<0||l>=c?n?"":void 0:(o=s.charCodeAt(l))<55296||o>56319||l+1===c||(i=s.charCodeAt(l+1))<56320||i>57343?n?s.charAt(l):o:n?s.slice(l,l+2):i-56320+(o-55296<<10)+65536}};n.exports={codeAt:o(!1),charAt:o(!0)}},function(n,e,t){var r=t(0),a=t(1),o=t(184).f;r({target:"Object",stat:!0,forced:a((function(){return!Object.getOwnPropertyNames(1)}))},{getOwnPropertyNames:o})},function(n,e,t){t(0)({target:"Date",stat:!0},{now:function(){return(new Date).getTime()}})},function(n,e,t){var r=t(0),a=t(239);r({target:"Array",stat:!0,forced:!t(112)((function(n){Array.from(n)}))},{from:a})},function(n,e,t){var r=t(11).default;t(151),t(4),t(25),t(20),t(30),t(23),t(12),t(28);var a=/^\s+|\s+$/g,o=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,s=/^0o[0-7]+$/i,l=parseInt,c="object"==("undefined"==typeof global?"undefined":r(global))&&global&&global.Object===Object&&global,d="object"==("undefined"==typeof self?"undefined":r(self))&&self&&self.Object===Object&&self,p=c||d||Function("return this")(),u=Object.prototype.toString,h=Math.max,m=Math.min,f=function(){return p.Date.now()};function g(n){var e=r(n);return!!n&&("object"==e||"function"==e)}function v(n){return"symbol"==r(n)||function(n){return!!n&&"object"==r(n)}(n)&&"[object Symbol]"==u.call(n)}function b(n){if("number"==typeof n)return n;if(v(n))return NaN;if(g(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=g(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(a,"");var t=i.test(n);return t||s.test(n)?l(n.slice(2),t?2:8):o.test(n)?NaN:+n}n.exports=function(n,e,t){var r,a,o,i,s,l,c=0,d=!1,p=!1,u=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function v(e){var t=r,o=a;return r=a=void 0,c=e,i=n.apply(o,t)}function y(n){return c=n,s=setTimeout(w,e),d?v(n):i}function x(n){var t=n-l;return void 0===l||t>=e||t<0||p&&n-c>=o}function w(){var n=f();if(x(n))return E(n);s=setTimeout(w,function(n){var t=e-(n-l);return p?m(t,o-(n-c)):t}(n))}function E(n){return s=void 0,u&&r?v(n):(r=a=void 0,i)}function A(){var n=f(),t=x(n);if(r=arguments,a=this,l=n,t){if(void 0===s)return y(l);if(p)return s=setTimeout(w,e),v(l)}return void 0===s&&(s=setTimeout(w,e)),i}return e=b(e)||0,g(t)&&(d=!!t.leading,o=(p="maxWait"in t)?h(b(t.maxWait)||0,e):o,u="trailing"in t?!!t.trailing:u),A.cancel=function(){void 0!==s&&clearTimeout(s),c=0,r=l=a=s=void 0},A.flush=function(){return void 0===s?i:E(f())},A}},function(n,e,t){"use strict";var r=t(0),a=t(232).start;r({target:"String",proto:!0,forced:t(242)},{padStart:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(7),a=t(1),o=t(122);n.exports=!r&&!a((function(){return 7!=Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var r=t(2);n.exports=r},function(n,e,t){var r=t(123);n.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var r=t(17),a=t(29),o=t(109).indexOf,i=t(70);n.exports=function(n,e){var t,s=a(n),l=0,c=[];for(t in s)!r(i,t)&&r(s,t)&&c.push(t);for(;e.length>l;)r(s,t=e[l++])&&(~o(c,t)||c.push(t));return c}},function(n,e,t){var r=t(40);n.exports=r("document","documentElement")},function(n,e,t){var r=t(17),a=t(128),o=t(38),i=t(10);n.exports=function(n,e){for(var t=a(e),s=i.f,l=o.f,c=0;c<t.length;c++){var d=t[c];r(n,d)||s(n,d,l(e,d))}}},function(n,e,t){"use strict";var r,a,o,i=t(1),s=t(85),l=t(26),c=t(17),d=t(5),p=t(46),u=d("iterator"),h=!1;[].keys&&("next"in(o=[].keys())?(a=s(s(o)))!==Object.prototype&&(r=a):h=!0);var m=null==r||i((function(){var n={};return r[u].call(n)!==n}));m&&(r={}),p&&!m||c(r,u)||l(r,u,(function(){return this})),n.exports={IteratorPrototype:r,BUGGY_SAFARI_ITERATORS:h}},function(n,e,t){var r=t(1);n.exports=!r((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){var r=t(2);n.exports=r.Promise},function(n,e,t){var r=t(8);n.exports=function(n){var e=n.return;if(void 0!==e)return r(e.call(n)).value}},function(n,e,t){var r=t(69);n.exports=/(iphone|ipod|ipad).*applewebkit/i.test(r)},function(n,e,t){var r=t(8),a=t(6),o=t(183);n.exports=function(n,e){if(r(n),a(e)&&e.constructor===n)return e;var t=o.f(n);return(0,t.resolve)(e),t.promise}},function(n,e,t){"use strict";var r=t(41),a=function(n){var e,t;this.promise=new n((function(n,r){if(void 0!==e||void 0!==t)throw TypeError("Bad Promise constructor");e=n,t=r})),this.resolve=r(e),this.reject=r(t)};n.exports.f=function(n){return new a(n)}},function(n,e,t){var r=t(29),a=t(57).f,o={}.toString,i="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];n.exports.f=function(n){return i&&"[object Window]"==o.call(n)?function(n){try{return a(n)}catch(n){return i.slice()}}(n):a(r(n))}},function(n,e,t){var r=t(5);e.f=r},function(n,e){n.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(n,e,t){"use strict";var r=t(52).forEach,a=t(47)("forEach");n.exports=a?[].forEach:function(n){return r(this,n,arguments.length>1?arguments[1]:void 0)}},function(n,e,t){var r=t(0),a=t(7),o=t(128),i=t(29),s=t(38),l=t(73);r({target:"Object",stat:!0,sham:!a},{getOwnPropertyDescriptors:function(n){for(var e,t,r=i(n),a=s.f,c=o(r),d={},p=0;c.length>p;)void 0!==(t=a(r,e=c[p++]))&&l(d,e,t);return d}})},function(n,e,t){var r=t(1);n.exports=!r((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(n,e,t){"use strict";var r=t(1);function a(n,e){return RegExp(n,e)}e.UNSUPPORTED_Y=r((function(){var n=a("a","y");return n.lastIndex=2,null!=n.exec("abcd")})),e.BROKEN_CARET=r((function(){var n=a("^r","gy");return n.lastIndex=2,null!=n.exec("str")}))},function(n,e,t){"use strict";var r=t(41),a=t(6),o=[].slice,i={},s=function(n,e,t){if(!(e in i)){for(var r=[],a=0;a<e;a++)r[a]="a["+a+"]";i[e]=Function("C,a","return new C("+r.join(",")+")")}return i[e](n,t)};n.exports=Function.bind||function(n){var e=r(this),t=o.call(arguments,1),i=function(){var r=t.concat(o.call(arguments));return this instanceof i?s(e,r.length,r):e.apply(n,r)};return a(e.prototype)&&(i.prototype=e.prototype),i}},function(n,e,t){var r=t(0),a=t(1),o=t(29),i=t(38).f,s=t(7),l=a((function(){i(1)}));r({target:"Object",stat:!0,forced:!s||l,sham:!s},{getOwnPropertyDescriptor:function(n,e){return i(o(n),e)}})},function(n,e){n.exports=function(n,e){for(var t=-1,r=e.length,a=n.length;++t<r;)n[a+t]=e[t];return n}},function(n,e,t){var r=t(11).default,a="object"==("undefined"==typeof global?"undefined":r(global))&&global&&global.Object===Object&&global;n.exports=a},function(n,e,t){var r=t(96),a=t(278),o=t(279),i=t(280),s=t(281),l=t(282);function c(n){var e=this.__data__=new r(n);this.size=e.size}c.prototype.clear=a,c.prototype.delete=o,c.prototype.get=i,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var r=t(67),a=t(140);n.exports=function(n){if(!a(n))return!1;var e=r(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e,t){t(4),t(25),t(20);var r=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return r.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var r=t(299),a=t(58);n.exports=function n(e,t,o,i,s){return e===t||(null==e||null==t||!a(e)&&!a(t)?e!=e&&t!=t:r(e,t,o,i,n,s))}},function(n,e,t){var r=t(201),a=t(302),o=t(202);n.exports=function(n,e,t,i,s,l){var c=1&t,d=n.length,p=e.length;if(d!=p&&!(c&&p>d))return!1;var u=l.get(n),h=l.get(e);if(u&&h)return u==e&&h==n;var m=-1,f=!0,g=2&t?new r:void 0;for(l.set(n,e),l.set(e,n);++m<d;){var v=n[m],b=e[m];if(i)var y=c?i(b,v,m,e,n,l):i(v,b,m,n,e,l);if(void 0!==y){if(y)continue;f=!1;break}if(g){if(!a(e,(function(n,e){if(!o(g,e)&&(v===n||s(v,n,t,i,l)))return g.push(e)}))){f=!1;break}}else if(v!==b&&!s(v,b,t,i,l)){f=!1;break}}return l.delete(n),l.delete(e),f}},function(n,e,t){var r=t(141),a=t(300),o=t(301);function i(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new r;++e<t;)this.add(n[e])}i.prototype.add=i.prototype.push=a,i.prototype.has=o,n.exports=i},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var r=t(312),a=t(318),o=t(207);n.exports=function(n){return o(n)?r(n):a(n)}},function(n,e,t){(function(n){var r=t(11).default,a=t(35),o=t(314),i="object"==r(e)&&e&&!e.nodeType&&e,s=i&&"object"==r(n)&&n&&!n.nodeType&&n,l=s&&s.exports===i?a.Buffer:void 0,c=(l?l.isBuffer:void 0)||o;n.exports=c}).call(this,t(110)(n))},function(n,e,t){var r=t(11).default,a=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var t=r(n);return!!(e=null==e?9007199254740991:e)&&("number"==t||"symbol"!=t&&a.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var r=t(315),a=t(316),o=t(317),i=o&&o.isTypedArray,s=i?a(i):r;n.exports=s},function(n,e,t){var r=t(197),a=t(143);n.exports=function(n){return null!=n&&a(n.length)&&!r(n)}},function(n,e,t){var r=t(51)(t(35),"Set");n.exports=r},function(n,e,t){var r=t(140);n.exports=function(n){return n==n&&!r(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var r=t(212),a=t(100);n.exports=function(n,e){for(var t=0,o=(e=r(e,n)).length;null!=n&&t<o;)n=n[a(e[t++])];return t&&t==o?n:void 0}},function(n,e,t){var r=t(34),a=t(144),o=t(330),i=t(333);n.exports=function(n,e){return r(n)?n:a(n,e)?[n]:o(i(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var r=t(0),a=t(40),o=t(41),i=t(8),s=t(6),l=t(48),c=t(191),d=t(1),p=a("Reflect","construct"),u=d((function(){function n(){}return!(p((function(){}),[],n)instanceof n)})),h=!d((function(){p((function(){}))})),m=u||h;r({target:"Reflect",stat:!0,forced:m,sham:m},{construct:function(n,e){o(n),i(e);var t=arguments.length<3?n:o(arguments[2]);if(h&&!u)return p(n,e,t);if(n==t){switch(e.length){case 0:return new n;case 1:return new n(e[0]);case 2:return new n(e[0],e[1]);case 3:return new n(e[0],e[1],e[2]);case 4:return new n(e[0],e[1],e[2],e[3])}var r=[null];return r.push.apply(r,e),new(c.apply(n,r))}var a=t.prototype,d=l(s(a)?a:Object.prototype),m=Function.apply.call(n,d,e);return s(m)?m:d}})},function(n,e,t){},function(n,e,t){var r=t(265),a=t(270),o=t(342),i=t(350),s=t(359),l=t(241),c=o((function(n){var e=l(n);return s(e)&&(e=void 0),i(r(n,1,s,!0),a(e,2))}));n.exports=c},function(n,e,t){"use strict";t.r(e);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},a=(t(365),t(16)),o=Object(a.a)(r,(function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=o.exports},function(n,e,t){"use strict";t.r(e);t(14),t(15),t(31),t(22);var r={name:"CodeGroup",data:function(){return{codeTabs:[],activeCodeTabIndex:-1}},watch:{activeCodeTabIndex:function(n){this.codeTabs.forEach((function(n){n.elm.classList.remove("theme-code-block__active")})),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted:function(){var n=this;this.codeTabs=(this.$slots.default||[]).filter((function(n){return Boolean(n.componentOptions)})).map((function(e,t){return""===e.componentOptions.propsData.active&&(n.activeCodeTabIndex=t),{title:e.componentOptions.propsData.title,elm:e.elm}})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab:function(n){this.activeCodeTabIndex=n}}},a=(t(366),t(16)),o=Object(a.a)(r,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"theme-code-group"},[t("div",{staticClass:"theme-code-group__nav"},[t("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(e,r){return t("li",{key:e.title,staticClass:"theme-code-group__li"},[t("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(r)}}},[n._v("\n            "+n._s(e.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?t("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=o.exports},function(n,e,t){"use strict";var r=t(93),a=t(8),o=t(24),i=t(371),s=t(95);r("search",1,(function(n,e,t){return[function(e){var t=o(this),r=null==e?void 0:e[n];return void 0!==r?r.call(e,t):new RegExp(e)[n](String(t))},function(n){var r=t(e,n,this);if(r.done)return r.value;var o=a(n),l=String(this),c=o.lastIndex;i(c,0)||(o.lastIndex=0);var d=s(o,l);return i(o.lastIndex,c)||(o.lastIndex=c),null===d?-1:d.index}]}))},function(n,e,t){"use strict";var r=t(0),a=t(223).left,o=t(47),i=t(66),s=t(65);r({target:"Array",proto:!0,forced:!o("reduce")||!s&&i>79&&i<83},{reduce:function(n){return a(this,n,arguments.length,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var r=t(41),a=t(19),o=t(68),i=t(9),s=function(n){return function(e,t,s,l){r(t);var c=a(e),d=o(c),p=i(c.length),u=n?p-1:0,h=n?-1:1;if(s<2)for(;;){if(u in d){l=d[u],u+=h;break}if(u+=h,n?u<0:p<=u)throw TypeError("Reduce of empty array with no initial value")}for(;n?u>=0:p>u;u+=h)u in d&&(l=t(l,d[u],u,c));return l}};n.exports={left:s(!1),right:s(!0)}},function(n,e,t){"use strict";var r=t(0),a=t(109).includes,o=t(150);r({target:"Array",proto:!0},{includes:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}}),o("includes")},function(n,e,t){"use strict";var r=t(0),a=t(159),o=t(24);r({target:"String",proto:!0,forced:!t(160)("includes")},{includes:function(n){return!!~String(o(this)).indexOf(a(n),arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var r=t(19),a=t(64),o=t(9);n.exports=function(n){for(var e=r(this),t=o(e.length),i=arguments.length,s=a(i>1?arguments[1]:void 0,t),l=i>2?arguments[2]:void 0,c=void 0===l?t:a(l,t);c>s;)e[s++]=n;return e}},function(n,e,t){"use strict";var r,a=t(0),o=t(38).f,i=t(9),s=t(159),l=t(24),c=t(160),d=t(46),p="".startsWith,u=Math.min,h=c("startsWith");a({target:"String",proto:!0,forced:!!(d||h||(r=o(String.prototype,"startsWith"),!r||r.writable))&&!h},{startsWith:function(n){var e=String(l(this));s(n);var t=i(u(arguments.length>1?arguments[1]:void 0,e.length)),r=String(n);return p?p.call(e,r,t):e.slice(t,t+r.length)===r}})},function(n,e,t){var r=t(1),a=t(92);n.exports=function(n){return r((function(){return!!a[n]()||"​᠎"!="​᠎"[n]()||a[n].name!==n}))}},function(n,e,t){"use strict";var r=t(0),a=t(2),o=t(162),i=t(86),s=o.ArrayBuffer;r({global:!0,forced:a.ArrayBuffer!==s},{ArrayBuffer:s}),i("ArrayBuffer")},function(n,e){n.exports="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof DataView},function(n,e,t){"use strict";var r=t(0),a=t(1),o=t(162),i=t(8),s=t(64),l=t(9),c=t(79),d=o.ArrayBuffer,p=o.DataView,u=d.prototype.slice;r({target:"ArrayBuffer",proto:!0,unsafe:!0,forced:a((function(){return!new d(2).slice(1,void 0).byteLength}))},{slice:function(n,e){if(void 0!==u&&void 0===e)return u.call(i(this),n);for(var t=i(this).byteLength,r=s(n,t),a=s(void 0===e?t:e,t),o=new(c(this,d))(l(a-r)),h=new p(this),m=new p(o),f=0;r<a;)m.setUint8(f++,h.getUint8(r++));return o}})},function(n,e,t){var r=t(9),a=t(147),o=t(24),i=Math.ceil,s=function(n){return function(e,t,s){var l,c,d=String(o(e)),p=d.length,u=void 0===s?" ":String(s),h=r(t);return h<=p||""==u?d:(l=h-p,(c=a.call(u,i(l/u.length))).length>l&&(c=c.slice(0,l)),n?d+c:c+d)}};n.exports={start:s(!1),end:s(!0)}},function(n,e,t){"use strict";var r=t(177).IteratorPrototype,a=t(48),o=t(63),i=t(39),s=t(71),l=function(){return this};n.exports=function(n,e,t){var c=e+" Iterator";return n.prototype=a(r,{next:o(1,t)}),i(n,c,!1,!0),s[c]=l,n}},function(n,e,t){"use strict";var r=t(7),a=t(1),o=t(88),i=t(129),s=t(127),l=t(19),c=t(68),d=Object.assign,p=Object.defineProperty;n.exports=!d||a((function(){if(r&&1!==d({b:1},d(p({},"a",{enumerable:!0,get:function(){p(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var n={},e={},t=Symbol();return n[t]=7,"abcdefghijklmnopqrst".split("").forEach((function(n){e[n]=n})),7!=d({},n)[t]||"abcdefghijklmnopqrst"!=o(d({},e)).join("")}))?function(n,e){for(var t=l(n),a=arguments.length,d=1,p=i.f,u=s.f;a>d;)for(var h,m=c(arguments[d++]),f=p?o(m).concat(p(m)):o(m),g=f.length,v=0;g>v;)h=f[v++],r&&!u.call(m,h)||(t[h]=m[h]);return t}:d},function(n,e,t){"use strict";var r=t(236),a=t(237);n.exports=r("Set",(function(n){return function(){return n(this,arguments.length?arguments[0]:void 0)}}),a)},function(n,e,t){"use strict";var r=t(0),a=t(2),o=t(72),i=t(21),s=t(135),l=t(130),c=t(81),d=t(6),p=t(1),u=t(112),h=t(39),m=t(118);n.exports=function(n,e,t){var f=-1!==n.indexOf("Map"),g=-1!==n.indexOf("Weak"),v=f?"set":"add",b=a[n],y=b&&b.prototype,x=b,w={},E=function(n){var e=y[n];i(y,n,"add"==n?function(n){return e.call(this,0===n?0:n),this}:"delete"==n?function(n){return!(g&&!d(n))&&e.call(this,0===n?0:n)}:"get"==n?function(n){return g&&!d(n)?void 0:e.call(this,0===n?0:n)}:"has"==n?function(n){return!(g&&!d(n))&&e.call(this,0===n?0:n)}:function(n,t){return e.call(this,0===n?0:n,t),this})};if(o(n,"function"!=typeof b||!(g||y.forEach&&!p((function(){(new b).entries().next()})))))x=t.getConstructor(e,n,f,v),s.REQUIRED=!0;else if(o(n,!0)){var A=new x,S=A[v](g?{}:-0,1)!=A,M=p((function(){A.has(1)})),C=u((function(n){new b(n)})),k=!g&&p((function(){for(var n=new b,e=5;e--;)n[v](e,e);return!n.has(-0)}));C||((x=e((function(e,t){c(e,x,n);var r=m(new b,e,x);return null!=t&&l(t,r[v],{that:r,AS_ENTRIES:f}),r}))).prototype=y,y.constructor=x),(M||k)&&(E("delete"),E("has"),f&&E("get")),(k||S)&&E(v),g&&y.clear&&delete y.clear}return w[n]=x,r({global:!0,forced:x!=b},w),h(x,n),g||t.setStrong(x,n,f),x}},function(n,e,t){"use strict";var r=t(10).f,a=t(48),o=t(111),i=t(61),s=t(81),l=t(130),c=t(126),d=t(86),p=t(7),u=t(135).fastKey,h=t(37),m=h.set,f=h.getterFor;n.exports={getConstructor:function(n,e,t,c){var d=n((function(n,r){s(n,d,e),m(n,{type:e,index:a(null),first:void 0,last:void 0,size:0}),p||(n.size=0),null!=r&&l(r,n[c],{that:n,AS_ENTRIES:t})})),h=f(e),g=function(n,e,t){var r,a,o=h(n),i=v(n,e);return i?i.value=t:(o.last=i={index:a=u(e,!0),key:e,value:t,previous:r=o.last,next:void 0,removed:!1},o.first||(o.first=i),r&&(r.next=i),p?o.size++:n.size++,"F"!==a&&(o.index[a]=i)),n},v=function(n,e){var t,r=h(n),a=u(e);if("F"!==a)return r.index[a];for(t=r.first;t;t=t.next)if(t.key==e)return t};return o(d.prototype,{clear:function(){for(var n=h(this),e=n.index,t=n.first;t;)t.removed=!0,t.previous&&(t.previous=t.previous.next=void 0),delete e[t.index],t=t.next;n.first=n.last=void 0,p?n.size=0:this.size=0},delete:function(n){var e=h(this),t=v(this,n);if(t){var r=t.next,a=t.previous;delete e.index[t.index],t.removed=!0,a&&(a.next=r),r&&(r.previous=a),e.first==t&&(e.first=r),e.last==t&&(e.last=a),p?e.size--:this.size--}return!!t},forEach:function(n){for(var e,t=h(this),r=i(n,arguments.length>1?arguments[1]:void 0,3);e=e?e.next:t.first;)for(r(e.value,e.key,this);e&&e.removed;)e=e.previous},has:function(n){return!!v(this,n)}}),o(d.prototype,t?{get:function(n){var e=v(this,n);return e&&e.value},set:function(n,e){return g(this,0===n?0:n,e)}}:{add:function(n){return g(this,n=0===n?0:n,n)}}),p&&r(d.prototype,"size",{get:function(){return h(this).size}}),d},setStrong:function(n,e,t){var r=e+" Iterator",a=f(e),o=f(r);c(n,e,(function(n,e){m(this,{type:r,target:n,state:a(n),kind:e,last:void 0})}),(function(){for(var n=o(this),e=n.kind,t=n.last;t&&t.removed;)t=t.previous;return n.target&&(n.last=t=t?t.next:n.state.first)?"keys"==e?{value:t.key,done:!1}:"values"==e?{value:t.value,done:!1}:{value:[t.key,t.value],done:!1}:(n.target=void 0,{value:void 0,done:!0})}),t?"entries":"values",!t,!0),d(e)}}},function(n,e,t){var r=t(0),a=t(1),o=t(6),i=Object.isFrozen;r({target:"Object",stat:!0,forced:a((function(){i(1)}))},{isFrozen:function(n){return!o(n)||!!i&&i(n)}})},function(n,e,t){"use strict";var r=t(61),a=t(19),o=t(264),i=t(164),s=t(9),l=t(73),c=t(153);n.exports=function(n){var e,t,d,p,u,h,m=a(n),f="function"==typeof this?this:Array,g=arguments.length,v=g>1?arguments[1]:void 0,b=void 0!==v,y=c(m),x=0;if(b&&(v=r(v,g>2?arguments[2]:void 0,2)),null==y||f==Array&&i(y))for(t=new f(e=s(m.length));e>x;x++)h=b?v(m[x],x):m[x],l(t,x,h);else for(u=(p=y.call(m)).next,t=new f;!(d=u.call(p)).done;x++)h=b?o(p,v,[d.value,x],!0):d.value,l(t,x,h);return t.length=x,t}},function(n,e,t){var r=t(32),a=t(9);n.exports=function(n){if(void 0===n)return 0;var e=r(n),t=a(e);if(e!==t)throw RangeError("Wrong length or index");return t}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){var r=t(69);n.exports=/Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(r)},function(n,e,t){t(0)({target:"String",proto:!0},{repeat:t(147)})},function(n,e,t){"use strict";var r=t(0),a=t(32),o=t(245),i=t(147),s=t(1),l=1..toFixed,c=Math.floor,d=function(n,e,t){return 0===e?t:e%2==1?d(n,e-1,t*n):d(n*n,e/2,t)},p=function(n,e,t){for(var r=-1,a=t;++r<6;)a+=e*n[r],n[r]=a%1e7,a=c(a/1e7)},u=function(n,e){for(var t=6,r=0;--t>=0;)r+=n[t],n[t]=c(r/e),r=r%e*1e7},h=function(n){for(var e=6,t="";--e>=0;)if(""!==t||0===e||0!==n[e]){var r=String(n[e]);t=""===t?r:t+i.call("0",7-r.length)+r}return t};r({target:"Number",proto:!0,forced:l&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!s((function(){l.call({})}))},{toFixed:function(n){var e,t,r,s,l=o(this),c=a(n),m=[0,0,0,0,0,0],f="",g="0";if(c<0||c>20)throw RangeError("Incorrect fraction digits");if(l!=l)return"NaN";if(l<=-1e21||l>=1e21)return String(l);if(l<0&&(f="-",l=-l),l>1e-21)if(t=(e=function(n){for(var e=0,t=n;t>=4096;)e+=12,t/=4096;for(;t>=2;)e+=1,t/=2;return e}(l*d(2,69,1))-69)<0?l*d(2,-e,1):l/d(2,e,1),t*=4503599627370496,(e=52-e)>0){for(p(m,0,t),r=c;r>=7;)p(m,1e7,0),r-=7;for(p(m,d(10,r,1),0),r=e-1;r>=23;)u(m,1<<23),r-=23;u(m,1<<r),p(m,1,1),u(m,2),g=h(m)}else p(m,0,t),p(m,1<<-e,0),g=h(m)+i.call("0",c);return g=c>0?f+((s=g.length)<=c?"0."+i.call("0",c-s)+g:g.slice(0,s-c)+"."+g.slice(s-c)):f+g}})},function(n,e,t){var r=t(42);n.exports=function(n){if("number"!=typeof n&&"Number"!=r(n))throw TypeError("Incorrect invocation");return+n}},function(n,e,t){n.exports=t(372)},function(n,e,t){var r=t(2),a=t(125),o=r.WeakMap;n.exports="function"==typeof o&&/native code/.test(a(o))},function(n,e,t){var r=t(6);n.exports=function(n){if(!r(n)&&null!==n)throw TypeError("Can't set "+String(n)+" as a prototype");return n}},function(n,e,t){"use strict";var r,a,o,i,s=t(0),l=t(46),c=t(2),d=t(40),p=t(179),u=t(21),h=t(111),m=t(39),f=t(86),g=t(6),v=t(41),b=t(81),y=t(125),x=t(130),w=t(112),E=t(79),A=t(132).set,S=t(250),M=t(182),C=t(252),k=t(183),T=t(253),j=t(37),I=t(72),B=t(5),_=t(65),L=t(66),P=B("species"),O="Promise",D=j.get,R=j.set,z=j.getterFor(O),q=p,H=c.TypeError,F=c.document,N=c.process,U=d("fetch"),J=k.f,$=J,V=!!(F&&F.createEvent&&c.dispatchEvent),W="function"==typeof PromiseRejectionEvent,G=I(O,(function(){if(!(y(q)!==String(q))){if(66===L)return!0;if(!_&&!W)return!0}if(l&&!q.prototype.finally)return!0;if(L>=51&&/native code/.test(q))return!1;var n=q.resolve(1),e=function(n){n((function(){}),(function(){}))};return(n.constructor={})[P]=e,!(n.then((function(){}))instanceof e)})),X=G||!w((function(n){q.all(n).catch((function(){}))})),K=function(n){var e;return!(!g(n)||"function"!=typeof(e=n.then))&&e},Y=function(n,e){if(!n.notified){n.notified=!0;var t=n.reactions;S((function(){for(var r=n.value,a=1==n.state,o=0;t.length>o;){var i,s,l,c=t[o++],d=a?c.ok:c.fail,p=c.resolve,u=c.reject,h=c.domain;try{d?(a||(2===n.rejection&&en(n),n.rejection=1),!0===d?i=r:(h&&h.enter(),i=d(r),h&&(h.exit(),l=!0)),i===c.promise?u(H("Promise-chain cycle")):(s=K(i))?s.call(i,p,u):p(i)):u(r)}catch(n){h&&!l&&h.exit(),u(n)}}n.reactions=[],n.notified=!1,e&&!n.rejection&&Q(n)}))}},Z=function(n,e,t){var r,a;V?((r=F.createEvent("Event")).promise=e,r.reason=t,r.initEvent(n,!1,!0),c.dispatchEvent(r)):r={promise:e,reason:t},!W&&(a=c["on"+n])?a(r):"unhandledrejection"===n&&C("Unhandled promise rejection",t)},Q=function(n){A.call(c,(function(){var e,t=n.facade,r=n.value;if(nn(n)&&(e=T((function(){_?N.emit("unhandledRejection",r,t):Z("unhandledrejection",t,r)})),n.rejection=_||nn(n)?2:1,e.error))throw e.value}))},nn=function(n){return 1!==n.rejection&&!n.parent},en=function(n){A.call(c,(function(){var e=n.facade;_?N.emit("rejectionHandled",e):Z("rejectionhandled",e,n.value)}))},tn=function(n,e,t){return function(r){n(e,r,t)}},rn=function(n,e,t){n.done||(n.done=!0,t&&(n=t),n.value=e,n.state=2,Y(n,!0))},an=function(n,e,t){if(!n.done){n.done=!0,t&&(n=t);try{if(n.facade===e)throw H("Promise can't be resolved itself");var r=K(e);r?S((function(){var t={done:!1};try{r.call(e,tn(an,t,n),tn(rn,t,n))}catch(e){rn(t,e,n)}})):(n.value=e,n.state=1,Y(n,!1))}catch(e){rn({done:!1},e,n)}}};G&&(q=function(n){b(this,q,O),v(n),r.call(this);var e=D(this);try{n(tn(an,e),tn(rn,e))}catch(n){rn(e,n)}},(r=function(n){R(this,{type:O,done:!1,notified:!1,parent:!1,reactions:[],rejection:!1,state:0,value:void 0})}).prototype=h(q.prototype,{then:function(n,e){var t=z(this),r=J(E(this,q));return r.ok="function"!=typeof n||n,r.fail="function"==typeof e&&e,r.domain=_?N.domain:void 0,t.parent=!0,t.reactions.push(r),0!=t.state&&Y(t,!1),r.promise},catch:function(n){return this.then(void 0,n)}}),a=function(){var n=new r,e=D(n);this.promise=n,this.resolve=tn(an,e),this.reject=tn(rn,e)},k.f=J=function(n){return n===q||n===o?new a(n):$(n)},l||"function"!=typeof p||(i=p.prototype.then,u(p.prototype,"then",(function(n,e){var t=this;return new q((function(n,e){i.call(t,n,e)})).then(n,e)}),{unsafe:!0}),"function"==typeof U&&s({global:!0,enumerable:!0,forced:!0},{fetch:function(n){return M(q,U.apply(c,arguments))}}))),s({global:!0,wrap:!0,forced:G},{Promise:q}),m(q,O,!1,!0),f(O),o=d(O),s({target:O,stat:!0,forced:G},{reject:function(n){var e=J(this);return e.reject.call(void 0,n),e.promise}}),s({target:O,stat:!0,forced:l||G},{resolve:function(n){return M(l&&this===o?q:this,n)}}),s({target:O,stat:!0,forced:X},{all:function(n){var e=this,t=J(e),r=t.resolve,a=t.reject,o=T((function(){var t=v(e.resolve),o=[],i=0,s=1;x(n,(function(n){var l=i++,c=!1;o.push(void 0),s++,t.call(e,n).then((function(n){c||(c=!0,o[l]=n,--s||r(o))}),a)})),--s||r(o)}));return o.error&&a(o.value),t.promise},race:function(n){var e=this,t=J(e),r=t.reject,a=T((function(){var a=v(e.resolve);x(n,(function(n){a.call(e,n).then(t.resolve,r)}))}));return a.error&&r(a.value),t.promise}})},function(n,e,t){var r,a,o,i,s,l,c,d,p=t(2),u=t(38).f,h=t(132).set,m=t(181),f=t(251),g=t(65),v=p.MutationObserver||p.WebKitMutationObserver,b=p.document,y=p.process,x=p.Promise,w=u(p,"queueMicrotask"),E=w&&w.value;E||(r=function(){var n,e;for(g&&(n=y.domain)&&n.exit();a;){e=a.fn,a=a.next;try{e()}catch(n){throw a?i():o=void 0,n}}o=void 0,n&&n.enter()},m||g||f||!v||!b?x&&x.resolve?(c=x.resolve(void 0),d=c.then,i=function(){d.call(c,r)}):i=g?function(){y.nextTick(r)}:function(){h.call(p,r)}:(s=!0,l=b.createTextNode(""),new v(r).observe(l,{characterData:!0}),i=function(){l.data=s=!s})),n.exports=E||function(n){var e={fn:n,next:void 0};o&&(o.next=e),a||(a=e,i()),o=e}},function(n,e,t){var r=t(69);n.exports=/web0s(?!.*chrome)/i.test(r)},function(n,e,t){var r=t(2);n.exports=function(n,e){var t=r.console;t&&t.error&&(1===arguments.length?t.error(n):t.error(n,e))}},function(n,e){n.exports=function(n){try{return{error:!1,value:n()}}catch(n){return{error:!0,value:n}}}},function(n,e,t){var r=t(0),a=t(234);r({target:"Object",stat:!0,forced:Object.assign!==a},{assign:a})},function(n,e,t){"use strict";var r=t(0),a=t(46),o=t(179),i=t(1),s=t(40),l=t(79),c=t(182),d=t(21);r({target:"Promise",proto:!0,real:!0,forced:!!o&&i((function(){o.prototype.finally.call({then:function(){}},(function(){}))}))},{finally:function(n){var e=l(this,s("Promise")),t="function"==typeof n;return this.then(t?function(t){return c(e,n()).then((function(){return t}))}:n,t?function(t){return c(e,n()).then((function(){throw t}))}:n)}}),a||"function"!=typeof o||o.prototype.finally||d(o.prototype,"finally",s("Promise").prototype.finally)},function(n,e,t){"use strict";var r=t(131),a=t(154);n.exports=r?{}.toString:function(){return"[object "+a(this)+"]"}},function(n,e,t){t(91)("asyncIterator")},function(n,e,t){var r=t(2),a=t(83).trim,o=t(92),i=r.parseFloat,s=1/i(o+"-0")!=-1/0;n.exports=s?function(n){var e=a(String(n)),t=i(e);return 0===t&&"-"==e.charAt(0)?-0:t}:i},function(n,e,t){var r=t(19),a=Math.floor,o="".replace,i=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,s=/\$([$&'`]|\d{1,2})/g;n.exports=function(n,e,t,l,c,d){var p=t+n.length,u=l.length,h=s;return void 0!==c&&(c=r(c),h=i),o.call(d,h,(function(r,o){var i;switch(o.charAt(0)){case"$":return"$";case"&":return n;case"`":return e.slice(0,t);case"'":return e.slice(p);case"<":i=c[o.slice(1,-1)];break;default:var s=+o;if(0===s)return r;if(s>u){var d=a(s/10);return 0===d?r:d<=u?void 0===l[d-1]?o.charAt(1):l[d-1]+o.charAt(1):r}i=l[s-1]}return void 0===i?"":i}))}},function(n,e,t){t(0)({target:"Reflect",stat:!0},{ownKeys:t(128)})},function(n,e,t){var r=t(0),a=t(1),o=t(6),i=Object.isExtensible;r({target:"Object",stat:!0,forced:a((function(){i(1)}))},{isExtensible:function(n){return!!o(n)&&(!i||i(n))}})},function(n,e,t){var r=t(0),a=t(2),o=t(132);r({global:!0,bind:!0,enumerable:!0,forced:!a.setImmediate||!a.clearImmediate},{setImmediate:o.set,clearImmediate:o.clear})},function(n,e,t){var r=t(2),a=t(83).trim,o=t(92),i=r.parseInt,s=/^[+-]?0[Xx]/,l=8!==i(o+"08")||22!==i(o+"0x16");n.exports=l?function(n,e){var t=a(String(n));return i(t,e>>>0||(s.test(t)?16:10))}:i},function(n,e,t){var r=t(8),a=t(180);n.exports=function(n,e,t,o){try{return o?e(r(t)[0],t[1]):e(t)}catch(e){throw a(n),e}}},function(n,e,t){var r=t(193),a=t(266);n.exports=function n(e,t,o,i,s){var l=-1,c=e.length;for(o||(o=a),s||(s=[]);++l<c;){var d=e[l];t>0&&o(d)?t>1?n(d,t-1,o,i,s):r(s,d):i||(s[s.length]=d)}return s}},function(n,e,t){var r=t(75),a=t(138),o=t(34),i=r?r.isConcatSpreadable:void 0;n.exports=function(n){return o(n)||a(n)||!!(i&&n&&n[i])}},function(n,e,t){var r=t(67),a=t(58);n.exports=function(n){return a(n)&&"[object Arguments]"==r(n)}},function(n,e,t){t(4),t(25),t(20);var r=t(75),a=Object.prototype,o=a.hasOwnProperty,i=a.toString,s=r?r.toStringTag:void 0;n.exports=function(n){var e=o.call(n,s),t=n[s];try{n[s]=void 0;var r=!0}catch(n){}var a=i.call(n);return r&&(e?n[s]=t:delete n[s]),a}},function(n,e,t){t(4),t(25),t(20);var r=Object.prototype.toString;n.exports=function(n){return r.call(n)}},function(n,e,t){var r=t(11).default,a=t(271),o=t(328),i=t(146),s=t(34),l=t(339);n.exports=function(n){return"function"==typeof n?n:null==n?i:"object"==r(n)?s(n)?o(n[0],n[1]):a(n):l(n)}},function(n,e,t){var r=t(272),a=t(327),o=t(210);n.exports=function(n){var e=a(n);return 1==e.length&&e[0][2]?o(e[0][0],e[0][1]):function(t){return t===n||r(t,n,e)}}},function(n,e,t){var r=t(195),a=t(199);n.exports=function(n,e,t,o){var i=t.length,s=i,l=!o;if(null==n)return!s;for(n=Object(n);i--;){var c=t[i];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++i<s;){var d=(c=t[i])[0],p=n[d],u=c[1];if(l&&c[2]){if(void 0===p&&!(d in n))return!1}else{var h=new r;if(o)var m=o(p,u,d,n,e,h);if(!(void 0===m?a(u,p,3,o,h):m))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){t(80);var r=t(97),a=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=r(e,n);return!(t<0)&&(t==e.length-1?e.pop():a.call(e,t,1),--this.size,!0)}},function(n,e,t){var r=t(97);n.exports=function(n){var e=this.__data__,t=r(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var r=t(97);n.exports=function(n){return r(this.__data__,n)>-1}},function(n,e,t){var r=t(97);n.exports=function(n,e){var t=this.__data__,a=r(t,n);return a<0?(++this.size,t.push([n,e])):t[a][1]=e,this}},function(n,e,t){var r=t(96);n.exports=function(){this.__data__=new r,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var r=t(96),a=t(139),o=t(141);n.exports=function(n,e){var t=this.__data__;if(t instanceof r){var i=t.__data__;if(!a||i.length<199)return i.push([n,e]),this.size=++t.size,this;t=this.__data__=new o(i)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){t(4),t(25),t(20),t(105),t(12),t(23);var r=t(197),a=t(284),o=t(140),i=t(198),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,d=l.toString,p=c.hasOwnProperty,u=RegExp("^"+d.call(p).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!o(n)||a(n))&&(r(n)?u:s).test(i(n))}},function(n,e,t){t(12),t(4),t(13);var r,a=t(285),o=(r=/[^.]+$/.exec(a&&a.keys&&a.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";n.exports=function(n){return!!o&&o in n}},function(n,e,t){var r=t(35)["__core-js_shared__"];n.exports=r},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var r=t(288),a=t(96),o=t(139);n.exports=function(){this.size=0,this.__data__={hash:new r,map:new(o||a),string:new r}}},function(n,e,t){var r=t(289),a=t(290),o=t(291),i=t(292),s=t(293);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var r=n[e];this.set(r[0],r[1])}}l.prototype.clear=r,l.prototype.delete=a,l.prototype.get=o,l.prototype.has=i,l.prototype.set=s,n.exports=l},function(n,e,t){var r=t(98);n.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var r=t(98),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(r){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return a.call(e,n)?e[n]:void 0}},function(n,e,t){var r=t(98),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return r?void 0!==e[n]:a.call(e,n)}},function(n,e,t){var r=t(98);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=r&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var r=t(99);n.exports=function(n){var e=r(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e,t){var r=t(11).default;n.exports=function(n){var e=r(n);return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var r=t(99);n.exports=function(n){return r(this,n).get(n)}},function(n,e,t){var r=t(99);n.exports=function(n){return r(this,n).has(n)}},function(n,e,t){var r=t(99);n.exports=function(n,e){var t=r(this,n),a=t.size;return t.set(n,e),this.size+=t.size==a?0:1,this}},function(n,e,t){var r=t(195),a=t(200),o=t(303),i=t(306),s=t(322),l=t(34),c=t(204),d=t(206),p="[object Object]",u=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,h,m,f){var g=l(n),v=l(e),b=g?"[object Array]":s(n),y=v?"[object Array]":s(e),x=(b="[object Arguments]"==b?p:b)==p,w=(y="[object Arguments]"==y?p:y)==p,E=b==y;if(E&&c(n)){if(!c(e))return!1;g=!0,x=!1}if(E&&!x)return f||(f=new r),g||d(n)?a(n,e,t,h,m,f):o(n,e,b,t,h,m,f);if(!(1&t)){var A=x&&u.call(n,"__wrapped__"),S=w&&u.call(e,"__wrapped__");if(A||S){var M=A?n.value():n,C=S?e.value():e;return f||(f=new r),m(M,C,t,h,f)}}return!!E&&(f||(f=new r),i(n,e,t,h,m,f))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length;++t<r;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){t(44);var r=t(75),a=t(304),o=t(196),i=t(200),s=t(305),l=t(142),c=r?r.prototype:void 0,d=c?c.valueOf:void 0;n.exports=function(n,e,t,r,c,p,u){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!p(new a(n),new a(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return o(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var h=s;case"[object Set]":var m=1&r;if(h||(h=l),n.size!=e.size&&!m)return!1;var f=u.get(n);if(f)return f==e;r|=2,u.set(n,e);var g=i(h(n),h(e),r,c,p,u);return u.delete(n),g;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var r=t(35).Uint8Array;n.exports=r},function(n,e,t){t(14),t(15),n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,r){t[++e]=[r,n]})),t}},function(n,e,t){var r=t(307),a=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,o,i,s){var l=1&t,c=r(n),d=c.length;if(d!=r(e).length&&!l)return!1;for(var p=d;p--;){var u=c[p];if(!(l?u in e:a.call(e,u)))return!1}var h=s.get(n),m=s.get(e);if(h&&m)return h==e&&m==n;var f=!0;s.set(n,e),s.set(e,n);for(var g=l;++p<d;){var v=n[u=c[p]],b=e[u];if(o)var y=l?o(b,v,u,e,n,s):o(v,b,u,n,e,s);if(!(void 0===y?v===b||i(v,b,t,o,s):y)){f=!1;break}g||(g="constructor"==u)}if(f&&!g){var x=n.constructor,w=e.constructor;x==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof w&&w instanceof w||(f=!1)}return s.delete(n),s.delete(e),f}},function(n,e,t){var r=t(308),a=t(309),o=t(203);n.exports=function(n){return r(n,o,a)}},function(n,e,t){var r=t(193),a=t(34);n.exports=function(n,e,t){var o=e(n);return a(n)?o:r(o,t(n))}},function(n,e,t){t(27);var r=t(310),a=t(311),o=Object.prototype.propertyIsEnumerable,i=Object.getOwnPropertySymbols,s=i?function(n){return null==n?[]:(n=Object(n),r(i(n),(function(e){return o.call(n,e)})))}:a;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=0,o=[];++t<r;){var i=n[t];e(i,t,n)&&(o[a++]=i)}return o}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var r=t(313),a=t(138),o=t(34),i=t(204),s=t(205),l=t(206),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=o(n),d=!t&&a(n),p=!t&&!d&&i(n),u=!t&&!d&&!p&&l(n),h=t||d||p||u,m=h?r(n.length,String):[],f=m.length;for(var g in n)!e&&!c.call(n,g)||h&&("length"==g||p&&("offset"==g||"parent"==g)||u&&("buffer"==g||"byteLength"==g||"byteOffset"==g)||s(g,f))||m.push(g);return m}},function(n,e){n.exports=function(n,e){for(var t=-1,r=Array(n);++t<n;)r[t]=e(t);return r}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var r=t(67),a=t(143),o=t(58),i={};i["[object Float32Array]"]=i["[object Float64Array]"]=i["[object Int8Array]"]=i["[object Int16Array]"]=i["[object Int32Array]"]=i["[object Uint8Array]"]=i["[object Uint8ClampedArray]"]=i["[object Uint16Array]"]=i["[object Uint32Array]"]=!0,i["[object Arguments]"]=i["[object Array]"]=i["[object ArrayBuffer]"]=i["[object Boolean]"]=i["[object DataView]"]=i["[object Date]"]=i["[object Error]"]=i["[object Function]"]=i["[object Map]"]=i["[object Number]"]=i["[object Object]"]=i["[object RegExp]"]=i["[object Set]"]=i["[object String]"]=i["[object WeakMap]"]=!1,n.exports=function(n){return o(n)&&a(n.length)&&!!i[r(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var r=t(11).default,a=t(194),o="object"==r(e)&&e&&!e.nodeType&&e,i=o&&"object"==r(n)&&n&&!n.nodeType&&n,s=i&&i.exports===o&&a.process,l=function(){try{var n=i&&i.require&&i.require("util").types;return n||s&&s.binding&&s.binding("util")}catch(n){}}();n.exports=l}).call(this,t(110)(n))},function(n,e,t){var r=t(319),a=t(320),o=Object.prototype.hasOwnProperty;n.exports=function(n){if(!r(n))return a(n);var e=[];for(var t in Object(n))o.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){t(45);var r=t(321)(Object.keys,Object);n.exports=r},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){t(229),t(231),t(4);var r=t(324),a=t(139),o=t(325),i=t(208),s=t(326),l=t(67),c=t(198),d=c(r),p=c(a),u=c(o),h=c(i),m=c(s),f=l;(r&&"[object DataView]"!=f(new r(new ArrayBuffer(1)))||a&&"[object Map]"!=f(new a)||o&&"[object Promise]"!=f(o.resolve())||i&&"[object Set]"!=f(new i)||s&&"[object WeakMap]"!=f(new s))&&(f=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,r=t?c(t):"";if(r)switch(r){case d:return"[object DataView]";case p:return"[object Map]";case u:return"[object Promise]";case h:return"[object Set]";case m:return"[object WeakMap]"}return e}),n.exports=f},function(n,e){var t=Math.abs,r=Math.pow,a=Math.floor,o=Math.log,i=Math.LN2;n.exports={pack:function(n,e,s){var l,c,d,p=new Array(s),u=8*s-e-1,h=(1<<u)-1,m=h>>1,f=23===e?r(2,-24)-r(2,-77):0,g=n<0||0===n&&1/n<0?1:0,v=0;for((n=t(n))!=n||n===1/0?(c=n!=n?1:0,l=h):(l=a(o(n)/i),n*(d=r(2,-l))<1&&(l--,d*=2),(n+=l+m>=1?f/d:f*r(2,1-m))*d>=2&&(l++,d/=2),l+m>=h?(c=0,l=h):l+m>=1?(c=(n*d-1)*r(2,e),l+=m):(c=n*r(2,m-1)*r(2,e),l=0));e>=8;p[v++]=255&c,c/=256,e-=8);for(l=l<<e|c,u+=e;u>0;p[v++]=255&l,l/=256,u-=8);return p[--v]|=128*g,p},unpack:function(n,e){var t,a=n.length,o=8*a-e-1,i=(1<<o)-1,s=i>>1,l=o-7,c=a-1,d=n[c--],p=127&d;for(d>>=7;l>0;p=256*p+n[c],c--,l-=8);for(t=p&(1<<-l)-1,p>>=-l,l+=e;l>0;t=256*t+n[c],c--,l-=8);if(0===p)p=1-s;else{if(p===i)return t?NaN:d?-1/0:1/0;t+=r(2,e),p-=s}return(d?-1:1)*t*r(2,p-e)}}},function(n,e,t){var r=t(51)(t(35),"DataView");n.exports=r},function(n,e,t){var r=t(51)(t(35),"Promise");n.exports=r},function(n,e,t){var r=t(51)(t(35),"WeakMap");n.exports=r},function(n,e,t){var r=t(209),a=t(203);n.exports=function(n){for(var e=a(n),t=e.length;t--;){var o=e[t],i=n[o];e[t]=[o,i,r(i)]}return e}},function(n,e,t){var r=t(199),a=t(329),o=t(336),i=t(144),s=t(209),l=t(210),c=t(100);n.exports=function(n,e){return i(n)&&s(e)?l(c(n),e):function(t){var i=a(t,n);return void 0===i&&i===e?o(t,n):r(e,i,3)}}},function(n,e,t){var r=t(211);n.exports=function(n,e,t){var a=null==n?void 0:r(n,e);return void 0===a?t:a}},function(n,e,t){t(23),t(12);var r=t(331),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,i=r((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(a,(function(n,t,r,a){e.push(r?a.replace(o,"$1"):t||n)})),e}));n.exports=i},function(n,e,t){var r=t(332);n.exports=function(n){var e=r(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var r=t(141);function a(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function t(){var r=arguments,a=e?e.apply(this,r):r[0],o=t.cache;if(o.has(a))return o.get(a);var i=n.apply(this,r);return t.cache=o.set(a,i)||o,i};return t.cache=new(a.Cache||r),t}a.Cache=r,n.exports=a},function(n,e,t){var r=t(334);n.exports=function(n){return null==n?"":r(n)}},function(n,e,t){t(4),t(25),t(20);var r=t(75),a=t(335),o=t(34),i=t(145),s=r?r.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(o(e))return a(e,n)+"";if(i(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,r=null==n?0:n.length,a=Array(r);++t<r;)a[t]=e(n[t],t,n);return a}},function(n,e,t){var r=t(337),a=t(338);n.exports=function(n,e){return null!=n&&a(n,e,r)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var r=t(212),a=t(138),o=t(34),i=t(205),s=t(143),l=t(100);n.exports=function(n,e,t){for(var c=-1,d=(e=r(e,n)).length,p=!1;++c<d;){var u=l(e[c]);if(!(p=null!=n&&t(n,u)))break;n=n[u]}return p||++c!=d?p:!!(d=null==n?0:n.length)&&s(d)&&i(u,d)&&(o(n)||a(n))}},function(n,e,t){var r=t(340),a=t(341),o=t(144),i=t(100);n.exports=function(n){return o(n)?r(i(n)):a(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var r=t(211);n.exports=function(n){return function(e){return r(e,n)}}},function(n,e,t){var r=t(146),a=t(343),o=t(345);n.exports=function(n,e){return o(a(n,e,r),n+"")}},function(n,e,t){var r=t(344),a=Math.max;n.exports=function(n,e,t){return e=a(void 0===e?n.length-1:e,0),function(){for(var o=arguments,i=-1,s=a(o.length-e,0),l=Array(s);++i<s;)l[i]=o[e+i];i=-1;for(var c=Array(e+1);++i<e;)c[i]=o[i];return c[e]=t(l),r(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var r=t(346),a=t(349)(r);n.exports=a},function(n,e,t){var r=t(347),a=t(348),o=t(146),i=a?function(n,e){return a(n,"toString",{configurable:!0,enumerable:!1,value:r(e),writable:!0})}:o;n.exports=i},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var r=t(51),a=function(){try{var n=r(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=a},function(n,e,t){t(167),t(20);var r=Date.now;n.exports=function(n){var e=0,t=0;return function(){var a=r(),o=16-(a-t);if(t=a,o>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var r=t(201),a=t(351),o=t(356),i=t(202),s=t(357),l=t(142);n.exports=function(n,e,t){var c=-1,d=a,p=n.length,u=!0,h=[],m=h;if(t)u=!1,d=o;else if(p>=200){var f=e?null:s(n);if(f)return l(f);u=!1,d=i,m=new r}else m=e?[]:h;n:for(;++c<p;){var g=n[c],v=e?e(g):g;if(g=t||0!==g?g:0,u&&v==v){for(var b=m.length;b--;)if(m[b]===v)continue n;e&&m.push(v),h.push(g)}else d(m,v,t)||(m!==h&&m.push(v),h.push(g))}return h}},function(n,e,t){var r=t(352);n.exports=function(n,e){return!!(null==n?0:n.length)&&r(n,e,0)>-1}},function(n,e,t){var r=t(353),a=t(354),o=t(355);n.exports=function(n,e,t){return e==e?o(n,e,t):r(n,a,t)}},function(n,e){n.exports=function(n,e,t,r){for(var a=n.length,o=t+(r?1:-1);r?o--:++o<a;)if(e(n[o],o,n))return o;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var r=t-1,a=n.length;++r<a;)if(n[r]===e)return r;return-1}},function(n,e){n.exports=function(n,e,t){for(var r=-1,a=null==n?0:n.length;++r<a;)if(t(e,n[r]))return!0;return!1}},function(n,e,t){var r=t(208),a=t(358),o=t(142),i=r&&1/o(new r([,-0]))[1]==1/0?function(n){return new r(n)}:a;n.exports=i},function(n,e){n.exports=function(){}},function(n,e,t){var r=t(207),a=t(58);n.exports=function(n){return a(n)&&r(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(213)},function(n,e,t){"use strict";t(214)},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(215)},function(n,e,t){"use strict";t(217)},function(n,e){n.exports=Object.is||function(n,e){return n===e?0!==n||1/n==1/e:n!=n&&e!=e}},function(n,e,t){"use strict";t.r(e);t(156),t(249),t(254),t(255);var r=t(90),a=(t(157),t(28),t(4),t(18),t(13),t(31),t(22),t(3)),o=(t(117),t(161),t(49),t(25),t(20),t(55),t(59),t(12),t(43),t(80),t(23),t(104),t(155),t(45),t(36),t(105),t(78),t(27),t(33),t(260),t(235),t(44),t(60),t(106),t(137),t(14),t(166),t(261),t(192),t(53),t(149),t(103),t(30),t(262),t(238),t(15),t(50),t(113),t(114),t(115),t(167),t(151),t(108),Object.freeze({}));function i(n){return null==n}function s(n){return null!=n}function l(n){return!0===n}function c(n){return"string"==typeof n||"number"==typeof n||"symbol"===Object(a.a)(n)||"boolean"==typeof n}function d(n){return null!==n&&"object"===Object(a.a)(n)}var p=Object.prototype.toString;function u(n){return"[object Object]"===p.call(n)}function h(n){return"[object RegExp]"===p.call(n)}function m(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function f(n){return s(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||u(n)&&n.toString===p?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function b(n,e){for(var t=Object.create(null),r=n.split(","),a=0;a<r.length;a++)t[r[a]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}b("slot,component",!0);var y=b("key,ref,slot,slot-scope,is");function x(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var w=Object.prototype.hasOwnProperty;function E(n,e){return w.call(n,e)}function A(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var S=/-(\w)/g,M=A((function(n){return n.replace(S,(function(n,e){return e?e.toUpperCase():""}))})),C=A((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),k=/\B([A-Z])/g,T=A((function(n){return n.replace(k,"-$1").toLowerCase()}));var j=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var r=arguments.length;return r?r>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function I(n,e){e=e||0;for(var t=n.length-e,r=new Array(t);t--;)r[t]=n[t+e];return r}function B(n,e){for(var t in e)n[t]=e[t];return n}function _(n){for(var e={},t=0;t<n.length;t++)n[t]&&B(e,n[t]);return e}function L(n,e,t){}var P=function(n,e,t){return!1},O=function(n){return n};function D(n,e){if(n===e)return!0;var t=d(n),r=d(e);if(!t||!r)return!t&&!r&&String(n)===String(e);try{var a=Array.isArray(n),o=Array.isArray(e);if(a&&o)return n.length===e.length&&n.every((function(n,t){return D(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(a||o)return!1;var i=Object.keys(n),s=Object.keys(e);return i.length===s.length&&i.every((function(t){return D(n[t],e[t])}))}catch(n){return!1}}function R(n,e){for(var t=0;t<n.length;t++)if(D(n[t],e))return t;return-1}function z(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var q=["component","directive","filter"],H=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],F={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:P,isReservedAttr:P,isUnknownElement:P,getTagNamespace:L,parsePlatformTagName:O,mustUseProp:P,async:!0,_lifecycleHooks:H},N=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function U(n,e,t,r){Object.defineProperty(n,e,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var J=new RegExp("[^"+N.source+".$_\\d]");var $,V="__proto__"in{},W="undefined"!=typeof window,G="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,X=G&&WXEnvironment.platform.toLowerCase(),K=W&&window.navigator.userAgent.toLowerCase(),Y=K&&/msie|trident/.test(K),Z=K&&K.indexOf("msie 9.0")>0,Q=K&&K.indexOf("edge/")>0,nn=(K&&K.indexOf("android"),K&&/iphone|ipad|ipod|ios/.test(K)||"ios"===X),en=(K&&/chrome\/\d+/.test(K),K&&/phantomjs/.test(K),K&&K.match(/firefox\/(\d+)/)),tn={}.watch,rn=!1;if(W)try{var an={};Object.defineProperty(an,"passive",{get:function(){rn=!0}}),window.addEventListener("test-passive",null,an)}catch(n){}var on=function(){return void 0===$&&($=!W&&!G&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),$},sn=W&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,dn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var pn=L,un=0,hn=function(){this.id=un++,this.subs=[]};hn.prototype.addSub=function(n){this.subs.push(n)},hn.prototype.removeSub=function(n){x(this.subs,n)},hn.prototype.depend=function(){hn.target&&hn.target.addDep(this)},hn.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},hn.target=null;var mn=[];function fn(n){mn.push(n),hn.target=n}function gn(){mn.pop(),hn.target=mn[mn.length-1]}var vn=function(n,e,t,r,a,o,i,s){this.tag=n,this.data=e,this.children=t,this.text=r,this.elm=a,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=i,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},bn={child:{configurable:!0}};bn.child.get=function(){return this.componentInstance},Object.defineProperties(vn.prototype,bn);var yn=function(n){void 0===n&&(n="");var e=new vn;return e.text=n,e.isComment=!0,e};function xn(n){return new vn(void 0,void 0,void 0,String(n))}function wn(n){var e=new vn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var En=Array.prototype,An=Object.create(En);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=En[n];U(An,n,(function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];var a,o=e.apply(this,t),i=this.__ob__;switch(n){case"push":case"unshift":a=t;break;case"splice":a=t.slice(2)}return a&&i.observeArray(a),i.dep.notify(),o}))}));var Sn=Object.getOwnPropertyNames(An),Mn=!0;function Cn(n){Mn=n}var kn=function(n){this.value=n,this.dep=new hn,this.vmCount=0,U(n,"__ob__",this),Array.isArray(n)?(V?function(n,e){n.__proto__=e}(n,An):function(n,e,t){for(var r=0,a=t.length;r<a;r++){var o=t[r];U(n,o,e[o])}}(n,An,Sn),this.observeArray(n)):this.walk(n)};function Tn(n,e){var t;if(d(n)&&!(n instanceof vn))return E(n,"__ob__")&&n.__ob__ instanceof kn?t=n.__ob__:Mn&&!on()&&(Array.isArray(n)||u(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new kn(n)),e&&t&&t.vmCount++,t}function jn(n,e,t,r,a){var o=new hn,i=Object.getOwnPropertyDescriptor(n,e);if(!i||!1!==i.configurable){var s=i&&i.get,l=i&&i.set;s&&!l||2!==arguments.length||(t=n[e]);var c=!a&&Tn(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=s?s.call(n):t;return hn.target&&(o.depend(),c&&(c.dep.depend(),Array.isArray(e)&&_n(e))),e},set:function(e){var r=s?s.call(n):t;e===r||e!=e&&r!=r||s&&!l||(l?l.call(n,e):t=e,c=!a&&Tn(e),o.notify())}})}}function In(n,e,t){if(Array.isArray(n)&&m(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var r=n.__ob__;return n._isVue||r&&r.vmCount?t:r?(jn(r.value,e,t),r.dep.notify(),t):(n[e]=t,t)}function Bn(n,e){if(Array.isArray(n)&&m(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||E(n,e)&&(delete n[e],t&&t.dep.notify())}}function _n(n){for(var e=void 0,t=0,r=n.length;t<r;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&_n(e)}kn.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)jn(n,e[t])},kn.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)Tn(n[e])};var Ln=F.optionMergeStrategies;function Pn(n,e){if(!e)return n;for(var t,r,a,o=dn?Reflect.ownKeys(e):Object.keys(e),i=0;i<o.length;i++)"__ob__"!==(t=o[i])&&(r=n[t],a=e[t],E(n,t)?r!==a&&u(r)&&u(a)&&Pn(r,a):In(n,t,a));return n}function On(n,e,t){return t?function(){var r="function"==typeof e?e.call(t,t):e,a="function"==typeof n?n.call(t,t):n;return r?Pn(r,a):a}:e?n?function(){return Pn("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function Dn(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Rn(n,e,t,r){var a=Object.create(n||null);return e?B(a,e):a}Ln.data=function(n,e,t){return t?On(n,e,t):e&&"function"!=typeof e?n:On(n,e)},H.forEach((function(n){Ln[n]=Dn})),q.forEach((function(n){Ln[n+"s"]=Rn})),Ln.watch=function(n,e,t,r){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var o in B(a,n),e){var i=a[o],s=e[o];i&&!Array.isArray(i)&&(i=[i]),a[o]=i?i.concat(s):Array.isArray(s)?s:[s]}return a},Ln.props=Ln.methods=Ln.inject=Ln.computed=function(n,e,t,r){if(!n)return e;var a=Object.create(null);return B(a,n),e&&B(a,e),a},Ln.provide=On;var zn=function(n,e){return void 0===e?n:e};function qn(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var r,a,o={};if(Array.isArray(t))for(r=t.length;r--;)"string"==typeof(a=t[r])&&(o[M(a)]={type:null});else if(u(t))for(var i in t)a=t[i],o[M(i)]=u(a)?a:{type:a};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var r=n.inject={};if(Array.isArray(t))for(var a=0;a<t.length;a++)r[t[a]]={from:t[a]};else if(u(t))for(var o in t){var i=t[o];r[o]=u(i)?B({from:o},i):{from:i}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var r=e[t];"function"==typeof r&&(e[t]={bind:r,update:r})}}(e),!e._base&&(e.extends&&(n=qn(n,e.extends,t)),e.mixins))for(var r=0,a=e.mixins.length;r<a;r++)n=qn(n,e.mixins[r],t);var o,i={};for(o in n)s(o);for(o in e)E(n,o)||s(o);function s(r){var a=Ln[r]||zn;i[r]=a(n[r],e[r],t,r)}return i}function Hn(n,e,t,r){if("string"==typeof t){var a=n[e];if(E(a,t))return a[t];var o=M(t);if(E(a,o))return a[o];var i=C(o);return E(a,i)?a[i]:a[t]||a[o]||a[i]}}function Fn(n,e,t,r){var a=e[n],o=!E(t,n),i=t[n],s=Jn(Boolean,a.type);if(s>-1)if(o&&!E(a,"default"))i=!1;else if(""===i||i===T(n)){var l=Jn(String,a.type);(l<0||s<l)&&(i=!0)}if(void 0===i){i=function(n,e,t){if(!E(e,"default"))return;var r=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof r&&"Function"!==Nn(e.type)?r.call(n):r}(r,a,n);var c=Mn;Cn(!0),Tn(i),Cn(c)}return i}function Nn(n){var e=n&&n.toString().match(/^\s*function (\w+)/);return e?e[1]:""}function Un(n,e){return Nn(n)===Nn(e)}function Jn(n,e){if(!Array.isArray(e))return Un(e,n)?0:-1;for(var t=0,r=e.length;t<r;t++)if(Un(e[t],n))return t;return-1}function $n(n,e,t){fn();try{if(e)for(var r=e;r=r.$parent;){var a=r.$options.errorCaptured;if(a)for(var o=0;o<a.length;o++)try{if(!1===a[o].call(r,n,e,t))return}catch(n){Wn(n,r,"errorCaptured hook")}}Wn(n,e,t)}finally{gn()}}function Vn(n,e,t,r,a){var o;try{(o=t?n.apply(e,t):n.call(e))&&!o._isVue&&f(o)&&!o._handled&&(o.catch((function(n){return $n(n,r,a+" (Promise/async)")})),o._handled=!0)}catch(n){$n(n,r,a)}return o}function Wn(n,e,t){if(F.errorHandler)try{return F.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Gn(e,null,"config.errorHandler")}Gn(n,e,t)}function Gn(n,e,t){if(!W&&!G||"undefined"==typeof console)throw n;console.error(n)}var Xn,Kn=!1,Yn=[],Zn=!1;function Qn(){Zn=!1;var n=Yn.slice(0);Yn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var ne=Promise.resolve();Xn=function(){ne.then(Qn),nn&&setTimeout(L)},Kn=!0}else if(Y||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Xn="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Qn)}:function(){setTimeout(Qn,0)};else{var ee=1,te=new MutationObserver(Qn),re=document.createTextNode(String(ee));te.observe(re,{characterData:!0}),Xn=function(){ee=(ee+1)%2,re.data=String(ee)},Kn=!0}function ae(n,e){var t;if(Yn.push((function(){if(n)try{n.call(e)}catch(n){$n(n,e,"nextTick")}else t&&t(e)})),Zn||(Zn=!0,Xn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var oe=new cn;function ie(n){!function n(e,t){var r,a,o=Array.isArray(e);if(!o&&!d(e)||Object.isFrozen(e)||e instanceof vn)return;if(e.__ob__){var i=e.__ob__.dep.id;if(t.has(i))return;t.add(i)}if(o)for(r=e.length;r--;)n(e[r],t);else for(a=Object.keys(e),r=a.length;r--;)n(e[a[r]],t)}(n,oe),oe.clear()}var se=A((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),r="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=r?n.slice(1):n,once:t,capture:r,passive:e}}));function le(n,e){function t(){var n=arguments,r=t.fns;if(!Array.isArray(r))return Vn(r,null,arguments,e,"v-on handler");for(var a=r.slice(),o=0;o<a.length;o++)Vn(a[o],null,n,e,"v-on handler")}return t.fns=n,t}function ce(n,e,t,r,a,o){var s,c,d,p;for(s in n)c=n[s],d=e[s],p=se(s),i(c)||(i(d)?(i(c.fns)&&(c=n[s]=le(c,o)),l(p.once)&&(c=n[s]=a(p.name,c,p.capture)),t(p.name,c,p.capture,p.passive,p.params)):c!==d&&(d.fns=c,n[s]=d));for(s in e)i(n[s])&&r((p=se(s)).name,e[s],p.capture)}function de(n,e,t){var r;n instanceof vn&&(n=n.data.hook||(n.data.hook={}));var a=n[e];function o(){t.apply(this,arguments),x(r.fns,o)}i(a)?r=le([o]):s(a.fns)&&l(a.merged)?(r=a).fns.push(o):r=le([a,o]),r.merged=!0,n[e]=r}function pe(n,e,t,r,a){if(s(e)){if(E(e,t))return n[t]=e[t],a||delete e[t],!0;if(E(e,r))return n[t]=e[r],a||delete e[r],!0}return!1}function ue(n){return c(n)?[xn(n)]:Array.isArray(n)?function n(e,t){var r,a,o,d,p=[];for(r=0;r<e.length;r++)i(a=e[r])||"boolean"==typeof a||(o=p.length-1,d=p[o],Array.isArray(a)?a.length>0&&(he((a=n(a,(t||"")+"_"+r))[0])&&he(d)&&(p[o]=xn(d.text+a[0].text),a.shift()),p.push.apply(p,a)):c(a)?he(d)?p[o]=xn(d.text+a):""!==a&&p.push(xn(a)):he(a)&&he(d)?p[o]=xn(d.text+a.text):(l(e._isVList)&&s(a.tag)&&i(a.key)&&s(t)&&(a.key="__vlist"+t+"_"+r+"__"),p.push(a)));return p}(n):void 0}function he(n){return s(n)&&s(n.text)&&!1===n.isComment}function me(n,e){if(n){for(var t=Object.create(null),r=dn?Reflect.ownKeys(n):Object.keys(n),a=0;a<r.length;a++){var o=r[a];if("__ob__"!==o){for(var i=n[o].from,s=e;s;){if(s._provided&&E(s._provided,i)){t[o]=s._provided[i];break}s=s.$parent}if(!s)if("default"in n[o]){var l=n[o].default;t[o]="function"==typeof l?l.call(e):l}else 0}}return t}}function fe(n,e){if(!n||!n.length)return{};for(var t={},r=0,a=n.length;r<a;r++){var o=n[r],i=o.data;if(i&&i.attrs&&i.attrs.slot&&delete i.attrs.slot,o.context!==e&&o.fnContext!==e||!i||null==i.slot)(t.default||(t.default=[])).push(o);else{var s=i.slot,l=t[s]||(t[s]=[]);"template"===o.tag?l.push.apply(l,o.children||[]):l.push(o)}}for(var c in t)t[c].every(ge)&&delete t[c];return t}function ge(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ve(n,e,t){var r,a=Object.keys(e).length>0,i=n?!!n.$stable:!a,s=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(i&&t&&t!==o&&s===t.$key&&!a&&!t.$hasNormal)return t;for(var l in r={},n)n[l]&&"$"!==l[0]&&(r[l]=be(e,l,n[l]))}else r={};for(var c in e)c in r||(r[c]=ye(e,c));return n&&Object.isExtensible(n)&&(n._normalized=r),U(r,"$stable",i),U(r,"$key",s),U(r,"$hasNormal",a),r}function be(n,e,t){var r=function(){var n=arguments.length?t.apply(null,arguments):t({});return(n=n&&"object"===Object(a.a)(n)&&!Array.isArray(n)?[n]:ue(n))&&(0===n.length||1===n.length&&n[0].isComment)?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:r,enumerable:!0,configurable:!0}),r}function ye(n,e){return function(){return n[e]}}function xe(n,e){var t,r,a,o,i;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),r=0,a=n.length;r<a;r++)t[r]=e(n[r],r);else if("number"==typeof n)for(t=new Array(n),r=0;r<n;r++)t[r]=e(r+1,r);else if(d(n))if(dn&&n[Symbol.iterator]){t=[];for(var l=n[Symbol.iterator](),c=l.next();!c.done;)t.push(e(c.value,t.length)),c=l.next()}else for(o=Object.keys(n),t=new Array(o.length),r=0,a=o.length;r<a;r++)i=o[r],t[r]=e(n[i],i,r);return s(t)||(t=[]),t._isVList=!0,t}function we(n,e,t,r){var a,o=this.$scopedSlots[n];o?(t=t||{},r&&(t=B(B({},r),t)),a=o(t)||e):a=this.$slots[n]||e;var i=t&&t.slot;return i?this.$createElement("template",{slot:i},a):a}function Ee(n){return Hn(this.$options,"filters",n)||O}function Ae(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function Se(n,e,t,r,a){var o=F.keyCodes[e]||t;return a&&r&&!F.keyCodes[e]?Ae(a,r):o?Ae(o,n):r?T(r)!==e:void 0}function Me(n,e,t,r,a){if(t)if(d(t)){var o;Array.isArray(t)&&(t=_(t));var i=function(i){if("class"===i||"style"===i||y(i))o=n;else{var s=n.attrs&&n.attrs.type;o=r||F.mustUseProp(e,s,i)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=M(i),c=T(i);l in o||c in o||(o[i]=t[i],a&&((n.on||(n.on={}))["update:"+i]=function(n){t[i]=n}))};for(var s in t)i(s)}else;return n}function Ce(n,e){var t=this._staticTrees||(this._staticTrees=[]),r=t[n];return r&&!e||Te(r=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),r}function ke(n,e,t){return Te(n,"__once__"+e+(t?"_"+t:""),!0),n}function Te(n,e,t){if(Array.isArray(n))for(var r=0;r<n.length;r++)n[r]&&"string"!=typeof n[r]&&je(n[r],e+"_"+r,t);else je(n,e,t)}function je(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function Ie(n,e){if(e)if(u(e)){var t=n.on=n.on?B({},n.on):{};for(var r in e){var a=t[r],o=e[r];t[r]=a?[].concat(a,o):o}}else;return n}function Be(n,e,t,r){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var o=n[a];Array.isArray(o)?Be(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return r&&(e.$key=r),e}function _e(n,e){for(var t=0;t<e.length;t+=2){var r=e[t];"string"==typeof r&&r&&(n[e[t]]=e[t+1])}return n}function Le(n,e){return"string"==typeof n?e+n:n}function Pe(n){n._o=ke,n._n=v,n._s=g,n._l=xe,n._t=we,n._q=D,n._i=R,n._m=Ce,n._f=Ee,n._k=Se,n._b=Me,n._v=xn,n._e=yn,n._u=Be,n._g=Ie,n._d=_e,n._p=Le}function Oe(n,e,t,r,a){var i,s=this,c=a.options;E(r,"_uid")?(i=Object.create(r))._original=r:(i=r,r=r._original);var d=l(c._compiled),p=!d;this.data=n,this.props=e,this.children=t,this.parent=r,this.listeners=n.on||o,this.injections=me(c.inject,r),this.slots=function(){return s.$slots||ve(n.scopedSlots,s.$slots=fe(t,r)),s.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return ve(n.scopedSlots,this.slots())}}),d&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=ve(n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,a){var o=Ne(i,n,e,t,a,p);return o&&!Array.isArray(o)&&(o.fnScopeId=c._scopeId,o.fnContext=r),o}:this._c=function(n,e,t,r){return Ne(i,n,e,t,r,p)}}function De(n,e,t,r,a){var o=wn(n);return o.fnContext=t,o.fnOptions=r,e.slot&&((o.data||(o.data={})).slot=e.slot),o}function Re(n,e){for(var t in e)n[M(t)]=e[t]}Pe(Oe.prototype);var ze={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;ze.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},r=n.data.inlineTemplate;s(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ze)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,a){0;var i=r.data.scopedSlots,s=n.$scopedSlots,l=!!(i&&!i.$stable||s!==o&&!s.$stable||i&&n.$scopedSlots.$key!==i.$key),c=!!(a||n.$options._renderChildren||l);n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r);if(n.$options._renderChildren=a,n.$attrs=r.data.attrs||o,n.$listeners=t||o,e&&n.$options.props){Cn(!1);for(var d=n._props,p=n.$options._propKeys||[],u=0;u<p.length;u++){var h=p[u],m=n.$options.props;d[h]=Fn(h,m,e,n)}Cn(!0),n.$options.propsData=e}t=t||o;var f=n.$options._parentListeners;n.$options._parentListeners=t,Ye(n,t,f),c&&(n.$slots=fe(a,r.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,r=n.componentInstance;r._isMounted||(r._isMounted=!0,tt(r,"mounted")),n.data.keepAlive&&(t._isMounted?((e=r)._inactive=!1,at.push(e)):et(r,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,nt(e)))return;if(!e._inactive){e._inactive=!0;for(var r=0;r<e.$children.length;r++)n(e.$children[r]);tt(e,"deactivated")}}(e,!0):e.$destroy())}},qe=Object.keys(ze);function He(n,e,t,r,a){if(!i(n)){var c=t.$options._base;if(d(n)&&(n=c.extend(n)),"function"==typeof n){var p;if(i(n.cid)&&void 0===(n=function(n,e){if(l(n.error)&&s(n.errorComp))return n.errorComp;if(s(n.resolved))return n.resolved;var t=Je;t&&s(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(l(n.loading)&&s(n.loadingComp))return n.loadingComp;if(t&&!s(n.owners)){var r=n.owners=[t],a=!0,o=null,c=null;t.$on("hook:destroyed",(function(){return x(r,t)}));var p=function(n){for(var e=0,t=r.length;e<t;e++)r[e].$forceUpdate();n&&(r.length=0,null!==o&&(clearTimeout(o),o=null),null!==c&&(clearTimeout(c),c=null))},u=z((function(t){n.resolved=$e(t,e),a?r.length=0:p(!0)})),h=z((function(e){s(n.errorComp)&&(n.error=!0,p(!0))})),m=n(u,h);return d(m)&&(f(m)?i(n.resolved)&&m.then(u,h):f(m.component)&&(m.component.then(u,h),s(m.error)&&(n.errorComp=$e(m.error,e)),s(m.loading)&&(n.loadingComp=$e(m.loading,e),0===m.delay?n.loading=!0:o=setTimeout((function(){o=null,i(n.resolved)&&i(n.error)&&(n.loading=!0,p(!1))}),m.delay||200)),s(m.timeout)&&(c=setTimeout((function(){c=null,i(n.resolved)&&h(null)}),m.timeout)))),a=!1,n.loading?n.loadingComp:n.resolved}}(p=n,c)))return function(n,e,t,r,a){var o=yn();return o.asyncFactory=n,o.asyncMeta={data:e,context:t,children:r,tag:a},o}(p,e,t,r,a);e=e||{},St(n),s(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",r=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),o=a[r],i=e.model.callback;s(o)?(Array.isArray(o)?-1===o.indexOf(i):o!==i)&&(a[r]=[i].concat(o)):a[r]=i}(n.options,e);var u=function(n,e,t){var r=e.options.props;if(!i(r)){var a={},o=n.attrs,l=n.props;if(s(o)||s(l))for(var c in r){var d=T(c);pe(a,l,c,d,!0)||pe(a,o,c,d,!1)}return a}}(e,n);if(l(n.options.functional))return function(n,e,t,r,a){var i=n.options,l={},c=i.props;if(s(c))for(var d in c)l[d]=Fn(d,c,e||o);else s(t.attrs)&&Re(l,t.attrs),s(t.props)&&Re(l,t.props);var p=new Oe(t,l,a,r,n),u=i.render.call(null,p._c,p);if(u instanceof vn)return De(u,t,p.parent,i,p);if(Array.isArray(u)){for(var h=ue(u)||[],m=new Array(h.length),f=0;f<h.length;f++)m[f]=De(h[f],t,p.parent,i,p);return m}}(n,u,e,t,r);var h=e.on;if(e.on=e.nativeOn,l(n.options.abstract)){var m=e.slot;e={},m&&(e.slot=m)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<qe.length;t++){var r=qe[t],a=e[r],o=ze[r];a===o||a&&a._merged||(e[r]=a?Fe(o,a):o)}}(e);var g=n.options.name||a;return new vn("vue-component-"+n.cid+(g?"-"+g:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:u,listeners:h,tag:a,children:r},p)}}}function Fe(n,e){var t=function(t,r){n(t,r),e(t,r)};return t._merged=!0,t}function Ne(n,e,t,r,a,o){return(Array.isArray(t)||c(t))&&(a=r,r=t,t=void 0),l(o)&&(a=2),function(n,e,t,r,a){if(s(t)&&s(t.__ob__))return yn();s(t)&&s(t.is)&&(e=t.is);if(!e)return yn();0;Array.isArray(r)&&"function"==typeof r[0]&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===a?r=ue(r):1===a&&(r=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(r));var o,c;if("string"==typeof e){var p;c=n.$vnode&&n.$vnode.ns||F.getTagNamespace(e),o=F.isReservedTag(e)?new vn(F.parsePlatformTagName(e),t,r,void 0,void 0,n):t&&t.pre||!s(p=Hn(n.$options,"components",e))?new vn(e,t,r,void 0,void 0,n):He(p,t,n,r,e)}else o=He(e,t,n,r);return Array.isArray(o)?o:s(o)?(s(c)&&function n(e,t,r){e.ns=t,"foreignObject"===e.tag&&(t=void 0,r=!0);if(s(e.children))for(var a=0,o=e.children.length;a<o;a++){var c=e.children[a];s(c.tag)&&(i(c.ns)||l(r)&&"svg"!==c.tag)&&n(c,t,r)}}(o,c),s(t)&&function(n){d(n.style)&&ie(n.style);d(n.class)&&ie(n.class)}(t),o):yn()}(n,e,t,r,a)}var Ue,Je=null;function $e(n,e){return(n.__esModule||dn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),d(n)?e.extend(n):n}function Ve(n){return n.isComment&&n.asyncFactory}function We(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(s(t)&&(s(t.componentOptions)||Ve(t)))return t}}function Ge(n,e){Ue.$on(n,e)}function Xe(n,e){Ue.$off(n,e)}function Ke(n,e){var t=Ue;return function r(){var a=e.apply(null,arguments);null!==a&&t.$off(n,r)}}function Ye(n,e,t){Ue=n,ce(e,t||{},Ge,Xe,Ke,n),Ue=void 0}var Ze=null;function Qe(n){var e=Ze;return Ze=n,function(){Ze=e}}function nt(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function et(n,e){if(e){if(n._directInactive=!1,nt(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)et(n.$children[t]);tt(n,"activated")}}function tt(n,e){fn();var t=n.$options[e],r=e+" hook";if(t)for(var a=0,o=t.length;a<o;a++)Vn(t[a],n,null,n,r);n._hasHookEvent&&n.$emit("hook:"+e),gn()}var rt=[],at=[],ot={},it=!1,st=!1,lt=0;var ct=0,dt=Date.now;if(W&&!Y){var pt=window.performance;pt&&"function"==typeof pt.now&&dt()>document.createEvent("Event").timeStamp&&(dt=function(){return pt.now()})}function ut(){var n,e;for(ct=dt(),st=!0,rt.sort((function(n,e){return n.id-e.id})),lt=0;lt<rt.length;lt++)(n=rt[lt]).before&&n.before(),e=n.id,ot[e]=null,n.run();var t=at.slice(),r=rt.slice();lt=rt.length=at.length=0,ot={},it=st=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,et(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],r=t.vm;r._watcher===t&&r._isMounted&&!r._isDestroyed&&tt(r,"updated")}}(r),sn&&F.devtools&&sn.emit("flush")}var ht=0,mt=function(n,e,t,r,a){this.vm=n,a&&(n._watcher=this),n._watchers.push(this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++ht,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!J.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=L)),this.value=this.lazy?void 0:this.get()};mt.prototype.get=function(){var n;fn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;$n(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&ie(n),gn(),this.cleanupDeps()}return n},mt.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},mt.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},mt.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==ot[e]){if(ot[e]=!0,st){for(var t=rt.length-1;t>lt&&rt[t].id>n.id;)t--;rt.splice(t+1,0,n)}else rt.push(n);it||(it=!0,ae(ut))}}(this)},mt.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||d(n)||this.deep){var e=this.value;if(this.value=n,this.user)try{this.cb.call(this.vm,n,e)}catch(n){$n(n,this.vm,'callback for watcher "'+this.expression+'"')}else this.cb.call(this.vm,n,e)}}},mt.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},mt.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},mt.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||x(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var ft={enumerable:!0,configurable:!0,get:L,set:L};function gt(n,e,t){ft.get=function(){return this[e][t]},ft.set=function(n){this[e][t]=n},Object.defineProperty(n,t,ft)}function vt(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},r=n._props={},a=n.$options._propKeys=[];n.$parent&&Cn(!1);var o=function(o){a.push(o);var i=Fn(o,e,t,n);jn(r,o,i),o in n||gt(n,"_props",o)};for(var i in e)o(i);Cn(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?L:j(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;u(e=n._data="function"==typeof e?function(n,e){fn();try{return n.call(e,e)}catch(n){return $n(n,e,"data()"),{}}finally{gn()}}(e,n):e||{})||(e={});var t=Object.keys(e),r=n.$options.props,a=(n.$options.methods,t.length);for(;a--;){var o=t[a];0,r&&E(r,o)||(i=void 0,36!==(i=(o+"").charCodeAt(0))&&95!==i&&gt(n,"_data",o))}var i;Tn(e,!0)}(n):Tn(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),r=on();for(var a in e){var o=e[a],i="function"==typeof o?o:o.get;0,r||(t[a]=new mt(n,i||L,L,bt)),a in n||yt(n,a,o)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var r=e[t];if(Array.isArray(r))for(var a=0;a<r.length;a++)Et(n,t,r[a]);else Et(n,t,r)}}(n,e.watch)}var bt={lazy:!0};function yt(n,e,t){var r=!on();"function"==typeof t?(ft.get=r?xt(e):wt(t),ft.set=L):(ft.get=t.get?r&&!1!==t.cache?xt(e):wt(t.get):L,ft.set=t.set||L),Object.defineProperty(n,e,ft)}function xt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),hn.target&&e.depend(),e.value}}function wt(n){return function(){return n.call(this,this)}}function Et(n,e,t,r){return u(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,r)}var At=0;function St(n){var e=n.options;if(n.super){var t=St(n.super);if(t!==n.superOptions){n.superOptions=t;var r=function(n){var e,t=n.options,r=n.sealedOptions;for(var a in t)t[a]!==r[a]&&(e||(e={}),e[a]=t[a]);return e}(n);r&&B(n.extendOptions,r),(e=n.options=qn(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Mt(n){this._init(n)}function Ct(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,r=t.cid,a=n._Ctor||(n._Ctor={});if(a[r])return a[r];var o=n.name||t.options.name;var i=function(n){this._init(n)};return(i.prototype=Object.create(t.prototype)).constructor=i,i.cid=e++,i.options=qn(t.options,n),i.super=t,i.options.props&&function(n){var e=n.options.props;for(var t in e)gt(n.prototype,"_props",t)}(i),i.options.computed&&function(n){var e=n.options.computed;for(var t in e)yt(n.prototype,t,e[t])}(i),i.extend=t.extend,i.mixin=t.mixin,i.use=t.use,q.forEach((function(n){i[n]=t[n]})),o&&(i.options.components[o]=i),i.superOptions=t.options,i.extendOptions=n,i.sealedOptions=B({},i.options),a[r]=i,i}}function kt(n){return n&&(n.Ctor.options.name||n.tag)}function Tt(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!h(n)&&n.test(e)}function jt(n,e){var t=n.cache,r=n.keys,a=n._vnode;for(var o in t){var i=t[o];if(i){var s=kt(i.componentOptions);s&&!e(s)&&It(t,o,r,a)}}}function It(n,e,t,r){var a=n[e];!a||r&&a.tag===r.tag||a.componentInstance.$destroy(),n[e]=null,x(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=At++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),r=e._parentVnode;t.parent=e.parent,t._parentVnode=r;var a=r.componentOptions;t.propsData=a.propsData,t._parentListeners=a.listeners,t._renderChildren=a.children,t._componentTag=a.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=qn(St(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Ye(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=fe(e._renderChildren,r),n.$scopedSlots=o,n._c=function(e,t,r,a){return Ne(n,e,t,r,a,!1)},n.$createElement=function(e,t,r,a){return Ne(n,e,t,r,a,!0)};var a=t&&t.data;jn(n,"$attrs",a&&a.attrs||o,null,!0),jn(n,"$listeners",e._parentListeners||o,null,!0)}(e),tt(e,"beforeCreate"),function(n){var e=me(n.$options.inject,n);e&&(Cn(!1),Object.keys(e).forEach((function(t){jn(n,t,e[t])})),Cn(!0))}(e),vt(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),tt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Mt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=In,n.prototype.$delete=Bn,n.prototype.$watch=function(n,e,t){if(u(e))return Et(this,n,e,t);(t=t||{}).user=!0;var r=new mt(this,n,e,t);if(t.immediate)try{e.call(this,r.value)}catch(n){$n(n,this,'callback for immediate watcher "'+r.expression+'"')}return function(){r.teardown()}}}(Mt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var r=this;if(Array.isArray(n))for(var a=0,o=n.length;a<o;a++)r.$on(n[a],t);else(r._events[n]||(r._events[n]=[])).push(t),e.test(n)&&(r._hasHookEvent=!0);return r},n.prototype.$once=function(n,e){var t=this;function r(){t.$off(n,r),e.apply(t,arguments)}return r.fn=e,t.$on(n,r),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var r=0,a=n.length;r<a;r++)t.$off(n[r],e);return t}var o,i=t._events[n];if(!i)return t;if(!e)return t._events[n]=null,t;for(var s=i.length;s--;)if((o=i[s])===e||o.fn===e){i.splice(s,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?I(t):t;for(var r=I(arguments,1),a='event handler for "'+n+'"',o=0,i=t.length;o<i;o++)Vn(t[o],e,r,e,a)}return e}}(Mt),function(n){n.prototype._update=function(n,e){var t=this,r=t.$el,a=t._vnode,o=Qe(t);t._vnode=n,t.$el=a?t.__patch__(a,n):t.__patch__(t.$el,n,e,!1),o(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){tt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),tt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Mt),function(n){Pe(n.prototype),n.prototype.$nextTick=function(n){return ae(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,r=t.render,a=t._parentVnode;a&&(e.$scopedSlots=ve(a.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=a;try{Je=e,n=r.call(e._renderProxy,e.$createElement)}catch(t){$n(t,e,"render"),n=e._vnode}finally{Je=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof vn||(n=yn()),n.parent=a,n}}(Mt);var Bt=[String,RegExp,Array],_t={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Bt,exclude:Bt,max:[String,Number]},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)It(this.cache,n,this.keys)},mounted:function(){var n=this;this.$watch("include",(function(e){jt(n,(function(n){return Tt(e,n)}))})),this.$watch("exclude",(function(e){jt(n,(function(n){return!Tt(e,n)}))}))},render:function(){var n=this.$slots.default,e=We(n),t=e&&e.componentOptions;if(t){var r=kt(t),a=this.include,o=this.exclude;if(a&&(!r||!Tt(a,r))||o&&r&&Tt(o,r))return e;var i=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;i[l]?(e.componentInstance=i[l].componentInstance,x(s,l),s.push(l)):(i[l]=e,s.push(l),this.max&&s.length>parseInt(this.max)&&It(i,s[0],s,this._vnode)),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return F}};Object.defineProperty(n,"config",e),n.util={warn:pn,extend:B,mergeOptions:qn,defineReactive:jn},n.set=In,n.delete=Bn,n.nextTick=ae,n.observable=function(n){return Tn(n),n},n.options=Object.create(null),q.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,B(n.options.components,_t),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=I(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=qn(this.options,n),this}}(n),Ct(n),function(n){q.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&u(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Mt),Object.defineProperty(Mt.prototype,"$isServer",{get:on}),Object.defineProperty(Mt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Mt,"FunctionalRenderContext",{value:Oe}),Mt.version="2.6.12";var Lt=b("style,class"),Pt=b("input,textarea,option,select,progress"),Ot=b("contenteditable,draggable,spellcheck"),Dt=b("events,caret,typing,plaintext-only"),Rt=b("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible"),zt="http://www.w3.org/1999/xlink",qt=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Ht=function(n){return qt(n)?n.slice(6,n.length):""},Ft=function(n){return null==n||!1===n};function Nt(n){for(var e=n.data,t=n,r=n;s(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(e=Ut(r.data,e));for(;s(t=t.parent);)t&&t.data&&(e=Ut(e,t.data));return function(n,e){if(s(n)||s(e))return Jt(n,$t(e));return""}(e.staticClass,e.class)}function Ut(n,e){return{staticClass:Jt(n.staticClass,e.staticClass),class:s(n.class)?[n.class,e.class]:e.class}}function Jt(n,e){return n?e?n+" "+e:n:e||""}function $t(n){return Array.isArray(n)?function(n){for(var e,t="",r=0,a=n.length;r<a;r++)s(e=$t(n[r]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):d(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Vt={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Wt=b("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Gt=b("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Xt=function(n){return Wt(n)||Gt(n)};var Kt=Object.create(null);var Yt=b("text,number,password,search,email,tel,url");var Zt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(Vt[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Qt={create:function(n,e){nr(e)},update:function(n,e){n.data.ref!==e.data.ref&&(nr(n,!0),nr(e))},destroy:function(n){nr(n,!0)}};function nr(n,e){var t=n.data.ref;if(s(t)){var r=n.context,a=n.componentInstance||n.elm,o=r.$refs;e?Array.isArray(o[t])?x(o[t],a):o[t]===a&&(o[t]=void 0):n.data.refInFor?Array.isArray(o[t])?o[t].indexOf(a)<0&&o[t].push(a):o[t]=[a]:o[t]=a}}var er=new vn("",{},[]),tr=["create","activate","update","remove","destroy"];function rr(n,e){return n.key===e.key&&(n.tag===e.tag&&n.isComment===e.isComment&&s(n.data)===s(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,r=s(t=n.data)&&s(t=t.attrs)&&t.type,a=s(t=e.data)&&s(t=t.attrs)&&t.type;return r===a||Yt(r)&&Yt(a)}(n,e)||l(n.isAsyncPlaceholder)&&n.asyncFactory===e.asyncFactory&&i(e.asyncFactory.error))}function ar(n,e,t){var r,a,o={};for(r=e;r<=t;++r)s(a=n[r].key)&&(o[a]=r);return o}var or={create:ir,update:ir,destroy:function(n){ir(n,er)}};function ir(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,r,a,o=n===er,i=e===er,s=lr(n.data.directives,n.context),l=lr(e.data.directives,e.context),c=[],d=[];for(t in l)r=s[t],a=l[t],r?(a.oldValue=r.value,a.oldArg=r.arg,dr(a,"update",e,n),a.def&&a.def.componentUpdated&&d.push(a)):(dr(a,"bind",e,n),a.def&&a.def.inserted&&c.push(a));if(c.length){var p=function(){for(var t=0;t<c.length;t++)dr(c[t],"inserted",e,n)};o?de(e,"insert",p):p()}d.length&&de(e,"postpatch",(function(){for(var t=0;t<d.length;t++)dr(d[t],"componentUpdated",e,n)}));if(!o)for(t in s)l[t]||dr(s[t],"unbind",n,n,i)}(n,e)}var sr=Object.create(null);function lr(n,e){var t,r,a=Object.create(null);if(!n)return a;for(t=0;t<n.length;t++)(r=n[t]).modifiers||(r.modifiers=sr),a[cr(r)]=r,r.def=Hn(e.$options,"directives",r.name);return a}function cr(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function dr(n,e,t,r,a){var o=n.def&&n.def[e];if(o)try{o(t.elm,n,t,r,a)}catch(r){$n(r,t.context,"directive "+n.name+" "+e+" hook")}}var pr=[Qt,or];function ur(n,e){var t=e.componentOptions;if(!(s(t)&&!1===t.Ctor.options.inheritAttrs||i(n.data.attrs)&&i(e.data.attrs))){var r,a,o=e.elm,l=n.data.attrs||{},c=e.data.attrs||{};for(r in s(c.__ob__)&&(c=e.data.attrs=B({},c)),c)a=c[r],l[r]!==a&&hr(o,r,a);for(r in(Y||Q)&&c.value!==l.value&&hr(o,"value",c.value),l)i(c[r])&&(qt(r)?o.removeAttributeNS(zt,Ht(r)):Ot(r)||o.removeAttribute(r))}}function hr(n,e,t){n.tagName.indexOf("-")>-1?mr(n,e,t):Rt(e)?Ft(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):Ot(e)?n.setAttribute(e,function(n,e){return Ft(e)||"false"===e?"false":"contenteditable"===n&&Dt(e)?e:"true"}(e,t)):qt(e)?Ft(t)?n.removeAttributeNS(zt,Ht(e)):n.setAttributeNS(zt,e,t):mr(n,e,t)}function mr(n,e,t){if(Ft(t))n.removeAttribute(e);else{if(Y&&!Z&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){n.addEventListener("input",(function e(t){t.stopImmediatePropagation(),n.removeEventListener("input",e)})),n.__ieph=!0}n.setAttribute(e,t)}}var fr={create:ur,update:ur};function gr(n,e){var t=e.elm,r=e.data,a=n.data;if(!(i(r.staticClass)&&i(r.class)&&(i(a)||i(a.staticClass)&&i(a.class)))){var o=Nt(e),l=t._transitionClasses;s(l)&&(o=Jt(o,$t(l))),o!==t._prevClass&&(t.setAttribute("class",o),t._prevClass=o)}}var vr,br={create:gr,update:gr};function yr(n,e,t){var r=vr;return function a(){var o=e.apply(null,arguments);null!==o&&Er(n,a,t,r)}}var xr=Kn&&!(en&&Number(en[1])<=53);function wr(n,e,t,r){if(xr){var a=ct,o=e;e=o._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=a||n.timeStamp<=0||n.target.ownerDocument!==document)return o.apply(this,arguments)}}vr.addEventListener(n,e,rn?{capture:t,passive:r}:t)}function Er(n,e,t,r){(r||vr).removeEventListener(n,e._wrapper||e,t)}function Ar(n,e){if(!i(n.data.on)||!i(e.data.on)){var t=e.data.on||{},r=n.data.on||{};vr=e.elm,function(n){if(s(n.__r)){var e=Y?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}s(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),ce(t,r,wr,Er,yr,e.context),vr=void 0}}var Sr,Mr={create:Ar,update:Ar};function Cr(n,e){if(!i(n.data.domProps)||!i(e.data.domProps)){var t,r,a=e.elm,o=n.data.domProps||{},l=e.data.domProps||{};for(t in s(l.__ob__)&&(l=e.data.domProps=B({},l)),o)t in l||(a[t]="");for(t in l){if(r=l[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),r===o[t])continue;1===a.childNodes.length&&a.removeChild(a.childNodes[0])}if("value"===t&&"PROGRESS"!==a.tagName){a._value=r;var c=i(r)?"":String(r);kr(a,c)&&(a.value=c)}else if("innerHTML"===t&&Gt(a.tagName)&&i(a.innerHTML)){(Sr=Sr||document.createElement("div")).innerHTML="<svg>"+r+"</svg>";for(var d=Sr.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;d.firstChild;)a.appendChild(d.firstChild)}else if(r!==o[t])try{a[t]=r}catch(n){}}}}function kr(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,r=n._vModifiers;if(s(r)){if(r.number)return v(t)!==v(e);if(r.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Tr={create:Cr,update:Cr},jr=A((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var r=n.split(t);r.length>1&&(e[r[0].trim()]=r[1].trim())}})),e}));function Ir(n){var e=Br(n.style);return n.staticStyle?B(n.staticStyle,e):e}function Br(n){return Array.isArray(n)?_(n):"string"==typeof n?jr(n):n}var _r,Lr=/^--/,Pr=/\s*!important$/,Or=function(n,e,t){if(Lr.test(e))n.style.setProperty(e,t);else if(Pr.test(t))n.style.setProperty(T(e),t.replace(Pr,""),"important");else{var r=Rr(e);if(Array.isArray(t))for(var a=0,o=t.length;a<o;a++)n.style[r]=t[a];else n.style[r]=t}},Dr=["Webkit","Moz","ms"],Rr=A((function(n){if(_r=_r||document.createElement("div").style,"filter"!==(n=M(n))&&n in _r)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<Dr.length;t++){var r=Dr[t]+e;if(r in _r)return r}}));function zr(n,e){var t=e.data,r=n.data;if(!(i(t.staticStyle)&&i(t.style)&&i(r.staticStyle)&&i(r.style))){var a,o,l=e.elm,c=r.staticStyle,d=r.normalizedStyle||r.style||{},p=c||d,u=Br(e.data.style)||{};e.data.normalizedStyle=s(u.__ob__)?B({},u):u;var h=function(n,e){var t,r={};if(e)for(var a=n;a.componentInstance;)(a=a.componentInstance._vnode)&&a.data&&(t=Ir(a.data))&&B(r,t);(t=Ir(n.data))&&B(r,t);for(var o=n;o=o.parent;)o.data&&(t=Ir(o.data))&&B(r,t);return r}(e,!0);for(o in p)i(h[o])&&Or(l,o,"");for(o in h)(a=h[o])!==p[o]&&Or(l,o,null==a?"":a)}}var qr={create:zr,update:zr},Hr=/\s+/;function Fr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Hr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function Nr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Hr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",r=" "+e+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function Ur(n){if(n){if("object"===Object(a.a)(n)){var e={};return!1!==n.css&&B(e,Jr(n.name||"v")),B(e,n),e}return"string"==typeof n?Jr(n):void 0}}var Jr=A((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),$r=W&&!Z,Vr="transition",Wr="transitionend",Gr="animation",Xr="animationend";$r&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Vr="WebkitTransition",Wr="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Gr="WebkitAnimation",Xr="webkitAnimationEnd"));var Kr=W?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Yr(n){Kr((function(){Kr(n)}))}function Zr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),Fr(n,e))}function Qr(n,e){n._transitionClasses&&x(n._transitionClasses,e),Nr(n,e)}function na(n,e,t){var r=ta(n,e),a=r.type,o=r.timeout,i=r.propCount;if(!a)return t();var s="transition"===a?Wr:Xr,l=0,c=function(){n.removeEventListener(s,d),t()},d=function(e){e.target===n&&++l>=i&&c()};setTimeout((function(){l<i&&c()}),o+1),n.addEventListener(s,d)}var ea=/\b(transform|all)(,|$)/;function ta(n,e){var t,r=window.getComputedStyle(n),a=(r[Vr+"Delay"]||"").split(", "),o=(r[Vr+"Duration"]||"").split(", "),i=ra(a,o),s=(r[Gr+"Delay"]||"").split(", "),l=(r[Gr+"Duration"]||"").split(", "),c=ra(s,l),d=0,p=0;return"transition"===e?i>0&&(t="transition",d=i,p=o.length):"animation"===e?c>0&&(t="animation",d=c,p=l.length):p=(t=(d=Math.max(i,c))>0?i>c?"transition":"animation":null)?"transition"===t?o.length:l.length:0,{type:t,timeout:d,propCount:p,hasTransform:"transition"===t&&ea.test(r[Vr+"Property"])}}function ra(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return aa(e)+aa(n[t])})))}function aa(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function oa(n,e){var t=n.elm;s(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=Ur(n.data.transition);if(!i(r)&&!s(t._enterCb)&&1===t.nodeType){for(var a=r.css,o=r.type,l=r.enterClass,c=r.enterToClass,p=r.enterActiveClass,u=r.appearClass,h=r.appearToClass,m=r.appearActiveClass,f=r.beforeEnter,g=r.enter,b=r.afterEnter,y=r.enterCancelled,x=r.beforeAppear,w=r.appear,E=r.afterAppear,A=r.appearCancelled,S=r.duration,M=Ze,C=Ze.$vnode;C&&C.parent;)M=C.context,C=C.parent;var k=!M._isMounted||!n.isRootInsert;if(!k||w||""===w){var T=k&&u?u:l,j=k&&m?m:p,I=k&&h?h:c,B=k&&x||f,_=k&&"function"==typeof w?w:g,L=k&&E||b,P=k&&A||y,O=v(d(S)?S.enter:S);0;var D=!1!==a&&!Z,R=la(_),q=t._enterCb=z((function(){D&&(Qr(t,I),Qr(t,j)),q.cancelled?(D&&Qr(t,T),P&&P(t)):L&&L(t),t._enterCb=null}));n.data.show||de(n,"insert",(function(){var e=t.parentNode,r=e&&e._pending&&e._pending[n.key];r&&r.tag===n.tag&&r.elm._leaveCb&&r.elm._leaveCb(),_&&_(t,q)})),B&&B(t),D&&(Zr(t,T),Zr(t,j),Yr((function(){Qr(t,T),q.cancelled||(Zr(t,I),R||(sa(O)?setTimeout(q,O):na(t,o,q)))}))),n.data.show&&(e&&e(),_&&_(t,q)),D||R||q()}}}function ia(n,e){var t=n.elm;s(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=Ur(n.data.transition);if(i(r)||1!==t.nodeType)return e();if(!s(t._leaveCb)){var a=r.css,o=r.type,l=r.leaveClass,c=r.leaveToClass,p=r.leaveActiveClass,u=r.beforeLeave,h=r.leave,m=r.afterLeave,f=r.leaveCancelled,g=r.delayLeave,b=r.duration,y=!1!==a&&!Z,x=la(h),w=v(d(b)?b.leave:b);0;var E=t._leaveCb=z((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(Qr(t,c),Qr(t,p)),E.cancelled?(y&&Qr(t,l),f&&f(t)):(e(),m&&m(t)),t._leaveCb=null}));g?g(A):A()}function A(){E.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),u&&u(t),y&&(Zr(t,l),Zr(t,p),Yr((function(){Qr(t,l),E.cancelled||(Zr(t,c),x||(sa(w)?setTimeout(E,w):na(t,o,E)))}))),h&&h(t,E),y||x||E())}}function sa(n){return"number"==typeof n&&!isNaN(n)}function la(n){if(i(n))return!1;var e=n.fns;return s(e)?la(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function ca(n,e){!0!==e.data.show&&oa(e)}var da=function(n){var e,t,r={},a=n.modules,o=n.nodeOps;for(e=0;e<tr.length;++e)for(r[tr[e]]=[],t=0;t<a.length;++t)s(a[t][tr[e]])&&r[tr[e]].push(a[t][tr[e]]);function d(n){var e=o.parentNode(n);s(e)&&o.removeChild(e,n)}function p(n,e,t,a,i,c,d){if(s(n.elm)&&s(c)&&(n=c[d]=wn(n)),n.isRootInsert=!i,!function(n,e,t,a){var o=n.data;if(s(o)){var i=s(n.componentInstance)&&o.keepAlive;if(s(o=o.hook)&&s(o=o.init)&&o(n,!1),s(n.componentInstance))return u(n,e),h(t,n.elm,a),l(i)&&function(n,e,t,a){var o,i=n;for(;i.componentInstance;)if(i=i.componentInstance._vnode,s(o=i.data)&&s(o=o.transition)){for(o=0;o<r.activate.length;++o)r.activate[o](er,i);e.push(i);break}h(t,n.elm,a)}(n,e,t,a),!0}}(n,e,t,a)){var p=n.data,f=n.children,b=n.tag;s(b)?(n.elm=n.ns?o.createElementNS(n.ns,b):o.createElement(b,n),v(n),m(n,f,e),s(p)&&g(n,e),h(t,n.elm,a)):l(n.isComment)?(n.elm=o.createComment(n.text),h(t,n.elm,a)):(n.elm=o.createTextNode(n.text),h(t,n.elm,a))}}function u(n,e){s(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,f(n)?(g(n,e),v(n)):(nr(n),e.push(n))}function h(n,e,t){s(n)&&(s(t)?o.parentNode(t)===n&&o.insertBefore(n,e,t):o.appendChild(n,e))}function m(n,e,t){if(Array.isArray(e)){0;for(var r=0;r<e.length;++r)p(e[r],t,n.elm,null,!0,e,r)}else c(n.text)&&o.appendChild(n.elm,o.createTextNode(String(n.text)))}function f(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return s(n.tag)}function g(n,t){for(var a=0;a<r.create.length;++a)r.create[a](er,n);s(e=n.data.hook)&&(s(e.create)&&e.create(er,n),s(e.insert)&&t.push(n))}function v(n){var e;if(s(e=n.fnScopeId))o.setStyleScope(n.elm,e);else for(var t=n;t;)s(e=t.context)&&s(e=e.$options._scopeId)&&o.setStyleScope(n.elm,e),t=t.parent;s(e=Ze)&&e!==n.context&&e!==n.fnContext&&s(e=e.$options._scopeId)&&o.setStyleScope(n.elm,e)}function y(n,e,t,r,a,o){for(;r<=a;++r)p(t[r],o,n,e,!1,t,r)}function x(n){var e,t,a=n.data;if(s(a))for(s(e=a.hook)&&s(e=e.destroy)&&e(n),e=0;e<r.destroy.length;++e)r.destroy[e](n);if(s(e=n.children))for(t=0;t<n.children.length;++t)x(n.children[t])}function w(n,e,t){for(;e<=t;++e){var r=n[e];s(r)&&(s(r.tag)?(E(r),x(r)):d(r.elm))}}function E(n,e){if(s(e)||s(n.data)){var t,a=r.remove.length+1;for(s(e)?e.listeners+=a:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,a),s(t=n.componentInstance)&&s(t=t._vnode)&&s(t.data)&&E(t,e),t=0;t<r.remove.length;++t)r.remove[t](n,e);s(t=n.data.hook)&&s(t=t.remove)?t(n,e):e()}else d(n.elm)}function A(n,e,t,r){for(var a=t;a<r;a++){var o=e[a];if(s(o)&&rr(n,o))return a}}function S(n,e,t,a,c,d){if(n!==e){s(e.elm)&&s(a)&&(e=a[c]=wn(e));var u=e.elm=n.elm;if(l(n.isAsyncPlaceholder))s(e.asyncFactory.resolved)?k(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(l(e.isStatic)&&l(n.isStatic)&&e.key===n.key&&(l(e.isCloned)||l(e.isOnce)))e.componentInstance=n.componentInstance;else{var h,m=e.data;s(m)&&s(h=m.hook)&&s(h=h.prepatch)&&h(n,e);var g=n.children,v=e.children;if(s(m)&&f(e)){for(h=0;h<r.update.length;++h)r.update[h](n,e);s(h=m.hook)&&s(h=h.update)&&h(n,e)}i(e.text)?s(g)&&s(v)?g!==v&&function(n,e,t,r,a){var l,c,d,u=0,h=0,m=e.length-1,f=e[0],g=e[m],v=t.length-1,b=t[0],x=t[v],E=!a;for(0;u<=m&&h<=v;)i(f)?f=e[++u]:i(g)?g=e[--m]:rr(f,b)?(S(f,b,r,t,h),f=e[++u],b=t[++h]):rr(g,x)?(S(g,x,r,t,v),g=e[--m],x=t[--v]):rr(f,x)?(S(f,x,r,t,v),E&&o.insertBefore(n,f.elm,o.nextSibling(g.elm)),f=e[++u],x=t[--v]):rr(g,b)?(S(g,b,r,t,h),E&&o.insertBefore(n,g.elm,f.elm),g=e[--m],b=t[++h]):(i(l)&&(l=ar(e,u,m)),i(c=s(b.key)?l[b.key]:A(b,e,u,m))?p(b,r,n,f.elm,!1,t,h):rr(d=e[c],b)?(S(d,b,r,t,h),e[c]=void 0,E&&o.insertBefore(n,d.elm,f.elm)):p(b,r,n,f.elm,!1,t,h),b=t[++h]);u>m?y(n,i(t[v+1])?null:t[v+1].elm,t,h,v,r):h>v&&w(e,u,m)}(u,g,v,t,d):s(v)?(s(n.text)&&o.setTextContent(u,""),y(u,null,v,0,v.length-1,t)):s(g)?w(g,0,g.length-1):s(n.text)&&o.setTextContent(u,""):n.text!==e.text&&o.setTextContent(u,e.text),s(m)&&s(h=m.hook)&&s(h=h.postpatch)&&h(n,e)}}}function M(n,e,t){if(l(t)&&s(n.parent))n.parent.data.pendingInsert=e;else for(var r=0;r<e.length;++r)e[r].data.hook.insert(e[r])}var C=b("attrs,class,staticClass,staticStyle,key");function k(n,e,t,r){var a,o=e.tag,i=e.data,c=e.children;if(r=r||i&&i.pre,e.elm=n,l(e.isComment)&&s(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(s(i)&&(s(a=i.hook)&&s(a=a.init)&&a(e,!0),s(a=e.componentInstance)))return u(e,t),!0;if(s(o)){if(s(c))if(n.hasChildNodes())if(s(a=i)&&s(a=a.domProps)&&s(a=a.innerHTML)){if(a!==n.innerHTML)return!1}else{for(var d=!0,p=n.firstChild,h=0;h<c.length;h++){if(!p||!k(p,c[h],t,r)){d=!1;break}p=p.nextSibling}if(!d||p)return!1}else m(e,c,t);if(s(i)){var f=!1;for(var v in i)if(!C(v)){f=!0,g(e,t);break}!f&&i.class&&ie(i.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,a){if(!i(e)){var c,d=!1,u=[];if(i(n))d=!0,p(e,u);else{var h=s(n.nodeType);if(!h&&rr(n,e))S(n,e,u,null,null,a);else{if(h){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),l(t)&&k(n,e,u))return M(e,u,!0),n;c=n,n=new vn(o.tagName(c).toLowerCase(),{},[],void 0,c)}var m=n.elm,g=o.parentNode(m);if(p(e,u,m._leaveCb?null:g,o.nextSibling(m)),s(e.parent))for(var v=e.parent,b=f(e);v;){for(var y=0;y<r.destroy.length;++y)r.destroy[y](v);if(v.elm=e.elm,b){for(var E=0;E<r.create.length;++E)r.create[E](er,v);var A=v.data.hook.insert;if(A.merged)for(var C=1;C<A.fns.length;C++)A.fns[C]()}else nr(v);v=v.parent}s(g)?w([n],0,0):s(n.tag)&&x(n)}}return M(e,u,d),e.elm}s(n)&&x(n)}}({nodeOps:Zt,modules:[fr,br,Mr,Tr,qr,W?{create:ca,activate:ca,remove:function(n,e){!0!==n.data.show?ia(n,e):e()}}:{}].concat(pr)});Z&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&ya(n,"input")}));var pa={inserted:function(n,e,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?de(t,"postpatch",(function(){pa.componentUpdated(n,e,t)})):ua(n,e,t.context),n._vOptions=[].map.call(n.options,fa)):("textarea"===t.tag||Yt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",va),n.addEventListener("compositionend",ba),n.addEventListener("change",ba),Z&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){ua(n,e,t.context);var r=n._vOptions,a=n._vOptions=[].map.call(n.options,fa);if(a.some((function(n,e){return!D(n,r[e])})))(n.multiple?e.value.some((function(n){return ma(n,a)})):e.value!==e.oldValue&&ma(e.value,a))&&ya(n,"change")}}};function ua(n,e,t){ha(n,e,t),(Y||Q)&&setTimeout((function(){ha(n,e,t)}),0)}function ha(n,e,t){var r=e.value,a=n.multiple;if(!a||Array.isArray(r)){for(var o,i,s=0,l=n.options.length;s<l;s++)if(i=n.options[s],a)o=R(r,fa(i))>-1,i.selected!==o&&(i.selected=o);else if(D(fa(i),r))return void(n.selectedIndex!==s&&(n.selectedIndex=s));a||(n.selectedIndex=-1)}}function ma(n,e){return e.every((function(e){return!D(e,n)}))}function fa(n){return"_value"in n?n._value:n.value}function va(n){n.target.composing=!0}function ba(n){n.target.composing&&(n.target.composing=!1,ya(n.target,"input"))}function ya(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function xa(n){return!n.componentInstance||n.data&&n.data.transition?n:xa(n.componentInstance._vnode)}var wa={model:pa,show:{bind:function(n,e,t){var r=e.value,a=(t=xa(t)).data&&t.data.transition,o=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;r&&a?(t.data.show=!0,oa(t,(function(){n.style.display=o}))):n.style.display=r?o:"none"},update:function(n,e,t){var r=e.value;!r!=!e.oldValue&&((t=xa(t)).data&&t.data.transition?(t.data.show=!0,r?oa(t,(function(){n.style.display=n.__vOriginalDisplay})):ia(t,(function(){n.style.display="none"}))):n.style.display=r?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,r,a){a||(n.style.display=n.__vOriginalDisplay)}}},Ea={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Aa(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?Aa(We(e.children)):n}function Sa(n){var e={},t=n.$options;for(var r in t.propsData)e[r]=n[r];var a=t._parentListeners;for(var o in a)e[M(o)]=a[o];return e}function Ma(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Ca=function(n){return n.tag||Ve(n)},ka=function(n){return"show"===n.name},Ta={name:"transition",props:Ea,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Ca)).length){0;var r=this.mode;0;var a=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return a;var o=Aa(a);if(!o)return a;if(this._leaving)return Ma(n,a);var i="__transition-"+this._uid+"-";o.key=null==o.key?o.isComment?i+"comment":i+o.tag:c(o.key)?0===String(o.key).indexOf(i)?o.key:i+o.key:o.key;var s=(o.data||(o.data={})).transition=Sa(this),l=this._vnode,d=Aa(l);if(o.data.directives&&o.data.directives.some(ka)&&(o.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(o,d)&&!Ve(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var p=d.data.transition=B({},s);if("out-in"===r)return this._leaving=!0,de(p,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Ma(n,a);if("in-out"===r){if(Ve(o))return l;var u,h=function(){u()};de(s,"afterEnter",h),de(s,"enterCancelled",h),de(p,"delayLeave",(function(n){u=n}))}}return a}}},ja=B({tag:String,moveClass:String},Ea);function Ia(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Ba(n){n.data.newPos=n.elm.getBoundingClientRect()}function _a(n){var e=n.data.pos,t=n.data.newPos,r=e.left-t.left,a=e.top-t.top;if(r||a){n.data.moved=!0;var o=n.elm.style;o.transform=o.WebkitTransform="translate("+r+"px,"+a+"px)",o.transitionDuration="0s"}}delete ja.mode;var La={Transition:Ta,TransitionGroup:{props:ja,beforeMount:function(){var n=this,e=this._update;this._update=function(t,r){var a=Qe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,a(),e.call(n,t,r)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,a=this.$slots.default||[],o=this.children=[],i=Sa(this),s=0;s<a.length;s++){var l=a[s];if(l.tag)if(null!=l.key&&0!==String(l.key).indexOf("__vlist"))o.push(l),t[l.key]=l,(l.data||(l.data={})).transition=i;else;}if(r){for(var c=[],d=[],p=0;p<r.length;p++){var u=r[p];u.data.transition=i,u.data.pos=u.elm.getBoundingClientRect(),t[u.key]?c.push(u):d.push(u)}this.kept=n(e,null,c),this.removed=d}return n(e,null,o)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Ia),n.forEach(Ba),n.forEach(_a),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,r=t.style;Zr(t,e),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(Wr,t._moveCb=function n(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(Wr,n),t._moveCb=null,Qr(t,e))})}})))},methods:{hasMove:function(n,e){if(!$r)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){Nr(t,n)})),Fr(t,e),t.style.display="none",this.$el.appendChild(t);var r=ta(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};Mt.config.mustUseProp=function(n,e,t){return"value"===t&&Pt(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Mt.config.isReservedTag=Xt,Mt.config.isReservedAttr=Lt,Mt.config.getTagNamespace=function(n){return Gt(n)?"svg":"math"===n?"math":void 0},Mt.config.isUnknownElement=function(n){if(!W)return!0;if(Xt(n))return!1;if(n=n.toLowerCase(),null!=Kt[n])return Kt[n];var e=document.createElement(n);return n.indexOf("-")>-1?Kt[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Kt[n]=/HTMLUnknownElement/.test(e.toString())},B(Mt.options.directives,wa),B(Mt.options.components,La),Mt.prototype.__patch__=W?da:L,Mt.prototype.$mount=function(n,e){return function(n,e,t){var r;return n.$el=e,n.$options.render||(n.$options.render=yn),tt(n,"beforeMount"),r=function(){n._update(n._render(),t)},new mt(n,r,L,{before:function(){n._isMounted&&!n._isDestroyed&&tt(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,tt(n,"mounted")),n}(this,n=n&&W?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},W&&setTimeout((function(){F.devtools&&sn&&sn.emit("init",Mt)}),0);var Pa=Mt;t(243),t(244),t(158),t(221);function Oa(n,e){for(var t in e)n[t]=e[t];return n}var Da=/[!'()*]/g,Ra=function(n){return"%"+n.charCodeAt(0).toString(16)},za=/%2C/g,qa=function(n){return encodeURIComponent(n).replace(Da,Ra).replace(za,",")};function Ha(n){try{return decodeURIComponent(n)}catch(n){0}return n}var Fa=function(n){return null==n||"object"===Object(a.a)(n)?n:String(n)};function Na(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),r=Ha(t.shift()),a=t.length>0?Ha(t.join("=")):null;void 0===e[r]?e[r]=a:Array.isArray(e[r])?e[r].push(a):e[r]=[e[r],a]})),e):e}function Ua(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return qa(e);if(Array.isArray(t)){var r=[];return t.forEach((function(n){void 0!==n&&(null===n?r.push(qa(e)):r.push(qa(e)+"="+qa(n)))})),r.join("&")}return qa(e)+"="+qa(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var Ja=/\/?$/;function $a(n,e,t,r){var a=r&&r.options.stringifyQuery,o=e.query||{};try{o=Va(o)}catch(n){}var i={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:o,params:e.params||{},fullPath:Xa(e,a),matched:n?Ga(n):[]};return t&&(i.redirectedFrom=Xa(t,a)),Object.freeze(i)}function Va(n){if(Array.isArray(n))return n.map(Va);if(n&&"object"===Object(a.a)(n)){var e={};for(var t in n)e[t]=Va(n[t]);return e}return n}var Wa=$a(null,{path:"/"});function Ga(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function Xa(n,e){var t=n.path,r=n.query;void 0===r&&(r={});var a=n.hash;return void 0===a&&(a=""),(t||"/")+(e||Ua)(r)+a}function Ka(n,e,t){return e===Wa?n===e:!!e&&(n.path&&e.path?n.path.replace(Ja,"")===e.path.replace(Ja,"")&&(t||n.hash===e.hash&&Ya(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&Ya(n.query,e.query)&&Ya(n.params,e.params))))}function Ya(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),r=Object.keys(e).sort();return t.length===r.length&&t.every((function(t,o){var i=n[t];if(r[o]!==t)return!1;var s=e[t];return null==i||null==s?i===s:"object"===Object(a.a)(i)&&"object"===Object(a.a)(s)?Ya(i,s):String(i)===String(s)}))}function Za(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var r in t.instances){var a=t.instances[r],o=t.enteredCbs[r];if(a&&o){delete t.enteredCbs[r];for(var i=0;i<o.length;i++)a._isBeingDestroyed||o[i](a)}}}}var Qa={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,r=e.children,a=e.parent,o=e.data;o.routerView=!0;for(var i=a.$createElement,s=t.name,l=a.$route,c=a._routerViewCache||(a._routerViewCache={}),d=0,p=!1;a&&a._routerRoot!==a;){var u=a.$vnode?a.$vnode.data:{};u.routerView&&d++,u.keepAlive&&a._directInactive&&a._inactive&&(p=!0),a=a.$parent}if(o.routerViewDepth=d,p){var h=c[s],m=h&&h.component;return m?(h.configProps&&no(m,o,h.route,h.configProps),i(m,o,r)):i()}var f=l.matched[d],g=f&&f.components[s];if(!f||!g)return c[s]=null,i();c[s]={component:g},o.registerRouteInstance=function(n,e){var t=f.instances[s];(e&&t!==n||!e&&t===n)&&(f.instances[s]=e)},(o.hook||(o.hook={})).prepatch=function(n,e){f.instances[s]=e.componentInstance},o.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==f.instances[s]&&(f.instances[s]=n.componentInstance),Za(l)};var v=f.props&&f.props[s];return v&&(Oa(c[s],{route:l,configProps:v}),no(g,o,l,v)),i(g,o,r)}};function no(n,e,t,r){var o=e.props=function(n,e){switch(Object(a.a)(e)){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,r);if(o){o=e.props=Oa({},o);var i=e.attrs=e.attrs||{};for(var s in o)n.props&&s in n.props||(i[s]=o[s],delete o[s])}}function eo(n,e,t){var r=n.charAt(0);if("/"===r)return n;if("?"===r||"#"===r)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var o=n.replace(/^\//,"").split("/"),i=0;i<o.length;i++){var s=o[i];".."===s?a.pop():"."!==s&&a.push(s)}return""!==a[0]&&a.unshift(""),a.join("/")}function to(n){return n.replace(/\/\//g,"/")}var ro=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},ao=yo,oo=po,io=function(n,e){return ho(po(n,e),e)},so=ho,lo=bo,co=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function po(n,e){for(var t,r=[],a=0,o=0,i="",s=e&&e.delimiter||"/";null!=(t=co.exec(n));){var l=t[0],c=t[1],d=t.index;if(i+=n.slice(o,d),o=d+l.length,c)i+=c[1];else{var p=n[o],u=t[2],h=t[3],m=t[4],f=t[5],g=t[6],v=t[7];i&&(r.push(i),i="");var b=null!=u&&null!=p&&p!==u,y="+"===g||"*"===g,x="?"===g||"*"===g,w=t[2]||s,E=m||f;r.push({name:h||a++,prefix:u||"",delimiter:w,optional:x,repeat:y,partial:b,asterisk:!!v,pattern:E?fo(E):v?".*":"[^"+mo(w)+"]+?"})}}return o<n.length&&(i+=n.substr(o)),i&&r.push(i),r}function uo(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function ho(n,e){for(var t=new Array(n.length),r=0;r<n.length;r++)"object"===Object(a.a)(n[r])&&(t[r]=new RegExp("^(?:"+n[r].pattern+")$",vo(e)));return function(e,r){for(var a="",o=e||{},i=(r||{}).pretty?uo:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,d=o[l.name];if(null==d){if(l.optional){l.partial&&(a+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(ro(d)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var p=0;p<d.length;p++){if(c=i(d[p]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");a+=(0===p?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):i(d),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');a+=l.prefix+c}}else a+=l}return a}}function mo(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function fo(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function go(n,e){return n.keys=e,n}function vo(n){return n&&n.sensitive?"":"i"}function bo(n,e,t){ro(e)||(t=e||t,e=[]);for(var r=(t=t||{}).strict,a=!1!==t.end,o="",i=0;i<n.length;i++){var s=n[i];if("string"==typeof s)o+=mo(s);else{var l=mo(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),o+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var d=mo(t.delimiter||"/"),p=o.slice(-d.length)===d;return r||(o=(p?o.slice(0,-d.length):o)+"(?:"+d+"(?=$))?"),o+=a?"$":r&&p?"":"(?="+d+"|$)",go(new RegExp("^"+o,vo(t)),e)}function yo(n,e,t){return ro(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)e.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return go(n,e)}(n,e):ro(n)?function(n,e,t){for(var r=[],a=0;a<n.length;a++)r.push(yo(n[a],e,t).source);return go(new RegExp("(?:"+r.join("|")+")",vo(t)),e)}(n,e,t):function(n,e,t){return bo(po(n,t),e,t)}(n,e,t)}ao.parse=oo,ao.compile=io,ao.tokensToFunction=so,ao.tokensToRegExp=lo;var xo=Object.create(null);function wo(n,e,t){e=e||{};try{var r=xo[n]||(xo[n]=ao.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),r(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Eo(n,e,t,r){var o="string"==typeof n?{path:n}:n;if(o._normalized)return o;if(o.name){var i=(o=Oa({},n)).params;return i&&"object"===Object(a.a)(i)&&(o.params=Oa({},i)),o}if(!o.path&&o.params&&e){(o=Oa({},o))._normalized=!0;var s=Oa(Oa({},e.params),o.params);if(e.name)o.name=e.name,o.params=s;else if(e.matched.length){var l=e.matched[e.matched.length-1].path;o.path=wo(l,s,e.path)}else 0;return o}var c=function(n){var e="",t="",r=n.indexOf("#");r>=0&&(e=n.slice(r),n=n.slice(0,r));var a=n.indexOf("?");return a>=0&&(t=n.slice(a+1),n=n.slice(0,a)),{path:n,query:t,hash:e}}(o.path||""),d=e&&e.path||"/",p=c.path?eo(c.path,d,t||o.append):d,u=function(n,e,t){void 0===e&&(e={});var r,a=t||Na;try{r=a(n||"")}catch(n){r={}}for(var o in e){var i=e[o];r[o]=Array.isArray(i)?i.map(Fa):Fa(i)}return r}(c.query,o.query,r&&r.options.parseQuery),h=o.hash||c.hash;return h&&"#"!==h.charAt(0)&&(h="#"+h),{_normalized:!0,path:p,query:u,hash:h}}var Ao,So=function(){},Mo={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,r=this.$route,a=t.resolve(this.to,r,this.append),o=a.location,i=a.route,s=a.href,l={},c=t.options.linkActiveClass,d=t.options.linkExactActiveClass,p=null==c?"router-link-active":c,u=null==d?"router-link-exact-active":d,h=null==this.activeClass?p:this.activeClass,m=null==this.exactActiveClass?u:this.exactActiveClass,f=i.redirectedFrom?$a(null,Eo(i.redirectedFrom),null,t):i;l[m]=Ka(r,f,this.exactPath),l[h]=this.exact||this.exactPath?l[m]:function(n,e){return 0===n.path.replace(Ja,"/").indexOf(e.path.replace(Ja,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(r,f);var g=l[m]?this.ariaCurrentValue:null,v=function(n){Co(n)&&(e.replace?t.replace(o,So):t.push(o,So))},b={click:Co};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=v})):b[this.event]=v;var y={class:l},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:i,navigate:v,isActive:l[h],isExactActive:l[m]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)y.on=b,y.attrs={href:s,"aria-current":g};else{var w=function n(e){var t;if(e)for(var r=0;r<e.length;r++){if("a"===(t=e[r]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(w){w.isStatic=!1;var E=w.data=Oa({},w.data);for(var A in E.on=E.on||{},E.on){var S=E.on[A];A in b&&(E.on[A]=Array.isArray(S)?S:[S])}for(var M in b)M in E.on?E.on[M].push(b[M]):E.on[M]=v;var C=w.data.attrs=Oa({},w.data.attrs);C.href=s,C["aria-current"]=g}else y.on=b}return n(this.tag,y,this.$slots.default)}};function Co(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var ko="undefined"!=typeof window;function To(n,e,t,r,a){var o=e||[],i=t||Object.create(null),s=r||Object.create(null);n.forEach((function(n){!function n(e,t,r,a,o,i){var s=a.path,l=a.name;0;var c=a.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return to(e.path+"/"+n)}(s,o,c.strict);"boolean"==typeof a.caseSensitive&&(c.sensitive=a.caseSensitive);var p={path:d,regex:jo(d,c),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:l,parent:o,matchAs:i,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};a.children&&a.children.forEach((function(a){var o=i?to(i+"/"+a.path):void 0;n(e,t,r,a,p,o)}));t[p.path]||(e.push(p.path),t[p.path]=p);if(void 0!==a.alias)for(var u=Array.isArray(a.alias)?a.alias:[a.alias],h=0;h<u.length;++h){0;var m={path:u[h],children:a.children};n(e,t,r,m,o,p.path||"/")}l&&(r[l]||(r[l]=p))}(o,i,s,n,a)}));for(var l=0,c=o.length;l<c;l++)"*"===o[l]&&(o.push(o.splice(l,1)[0]),c--,l--);return{pathList:o,pathMap:i,nameMap:s}}function jo(n,e){return ao(n,[],e)}function Io(n,e){var t=To(n),r=t.pathList,o=t.pathMap,i=t.nameMap;function s(n,t,s){var l=Eo(n,t,!1,e),d=l.name;if(d){var p=i[d];if(!p)return c(null,l);var u=p.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!==Object(a.a)(l.params)&&(l.params={}),t&&"object"===Object(a.a)(t.params))for(var h in t.params)!(h in l.params)&&u.indexOf(h)>-1&&(l.params[h]=t.params[h]);return l.path=wo(p.path,l.params),c(p,l,s)}if(l.path){l.params={};for(var m=0;m<r.length;m++){var f=r[m],g=o[f];if(Bo(g.regex,l.path,l.params))return c(g,l,s)}}return c(null,l)}function l(n,t){var r=n.redirect,o="function"==typeof r?r($a(n,t,null,e)):r;if("string"==typeof o&&(o={path:o}),!o||"object"!==Object(a.a)(o))return c(null,t);var l=o,d=l.name,p=l.path,u=t.query,h=t.hash,m=t.params;if(u=l.hasOwnProperty("query")?l.query:u,h=l.hasOwnProperty("hash")?l.hash:h,m=l.hasOwnProperty("params")?l.params:m,d){i[d];return s({_normalized:!0,name:d,query:u,hash:h,params:m},void 0,t)}if(p){var f=function(n,e){return eo(n,e.parent?e.parent.path:"/",!0)}(p,n);return s({_normalized:!0,path:wo(f,m),query:u,hash:h},void 0,t)}return c(null,t)}function c(n,t,r){return n&&n.redirect?l(n,r||t):n&&n.matchAs?function(n,e,t){var r=s({_normalized:!0,path:wo(t,e.params)});if(r){var a=r.matched,o=a[a.length-1];return e.params=r.params,c(o,e)}return c(null,e)}(0,t,n.matchAs):$a(n,t,r,e)}return{match:s,addRoute:function(n,e){var t="object"!==Object(a.a)(n)?i[n]:void 0;To([e||n],r,o,i,t),t&&To(t.alias.map((function(n){return{path:n,children:[e]}})),r,o,i,t)},getRoutes:function(){return r.map((function(n){return o[n]}))},addRoutes:function(n){To(n,r,o,i)}}}function Bo(n,e,t){var r=e.match(n);if(!r)return!1;if(!t)return!0;for(var a=1,o=r.length;a<o;++a){var i=n.keys[a-1];i&&(t[i.name||"pathMatch"]="string"==typeof r[a]?Ha(r[a]):r[a])}return!0}var _o=ko&&window.performance&&window.performance.now?window.performance:Date;function Lo(){return _o.now().toFixed(3)}var Po=Lo();function Oo(){return Po}function Do(n){return Po=n}var Ro=Object.create(null);function zo(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=Oa({},window.history.state);return t.key=Oo(),window.history.replaceState(t,"",e),window.addEventListener("popstate",Fo),function(){window.removeEventListener("popstate",Fo)}}function qo(n,e,t,r){if(n.app){var a=n.options.scrollBehavior;a&&n.app.$nextTick((function(){var o=function(){var n=Oo();if(n)return Ro[n]}(),i=a.call(n,e,t,r?o:null);i&&("function"==typeof i.then?i.then((function(n){Vo(n,o)})).catch((function(n){0})):Vo(i,o))}))}}function Ho(){var n=Oo();n&&(Ro[n]={x:window.pageXOffset,y:window.pageYOffset})}function Fo(n){Ho(),n.state&&n.state.key&&Do(n.state.key)}function No(n){return Jo(n.x)||Jo(n.y)}function Uo(n){return{x:Jo(n.x)?n.x:window.pageXOffset,y:Jo(n.y)?n.y:window.pageYOffset}}function Jo(n){return"number"==typeof n}var $o=/^#\d/;function Vo(n,e){var t,r="object"===Object(a.a)(n);if(r&&"string"==typeof n.selector){var o=$o.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(o){var i=n.offset&&"object"===Object(a.a)(n.offset)?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),r=n.getBoundingClientRect();return{x:r.left-t.left-e.x,y:r.top-t.top-e.y}}(o,i={x:Jo((t=i).x)?t.x:0,y:Jo(t.y)?t.y:0})}else No(n)&&(e=Uo(n))}else r&&No(n)&&(e=Uo(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var Wo,Go=ko&&((-1===(Wo=window.navigator.userAgent).indexOf("Android 2.")&&-1===Wo.indexOf("Android 4.0")||-1===Wo.indexOf("Mobile Safari")||-1!==Wo.indexOf("Chrome")||-1!==Wo.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function Xo(n,e){Ho();var t=window.history;try{if(e){var r=Oa({},t.state);r.key=Oo(),t.replaceState(r,"",n)}else t.pushState({key:Do(Lo())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function Ko(n){Xo(n,!0)}function Yo(n,e,t){!function r(a){a>=n.length?t():n[a]?e(n[a],(function(){r(a+1)})):r(a+1)}(0)}var Zo={redirected:2,aborted:4,cancelled:8,duplicated:16};function Qo(n,e){return ei(n,e,Zo.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return ti.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function ni(n,e){return ei(n,e,Zo.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function ei(n,e,t,r){var a=new Error(r);return a._isRouter=!0,a.from=n,a.to=e,a.type=t,a}var ti=["params","query","hash"];function ri(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function ai(n,e){return ri(n)&&n._isRouter&&(null==e||n.type===e)}function oi(n){return function(e,t,r){var a=!1,o=0,i=null;ii(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){a=!0,o++;var l,c=ci((function(e){var a;((a=e).__esModule||li&&"Module"===a[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Ao.extend(e),t.components[s]=e,--o<=0&&r()})),d=ci((function(n){var e="Failed to resolve async component "+s+": "+n;i||(i=ri(n)?n:new Error(e),r(i))}));try{l=n(c,d)}catch(n){d(n)}if(l)if("function"==typeof l.then)l.then(c,d);else{var p=l.component;p&&"function"==typeof p.then&&p.then(c,d)}}})),a||r()}}function ii(n,e){return si(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function si(n){return Array.prototype.concat.apply([],n)}var li="function"==typeof Symbol&&"symbol"===Object(a.a)(Symbol.toStringTag);function ci(n){var e=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!e)return e=!0,n.apply(this,t)}}var di=function(n,e){this.router=n,this.base=function(n){if(!n)if(ko){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=Wa,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function pi(n,e,t,r){var a=ii(n,(function(n,r,a,o){var i=function(n,e){"function"!=typeof n&&(n=Ao.extend(n));return n.options[e]}(n,e);if(i)return Array.isArray(i)?i.map((function(n){return t(n,r,a,o)})):t(i,r,a,o)}));return si(r?a.reverse():a)}function ui(n,e){if(e)return function(){return n.apply(e,arguments)}}di.prototype.listen=function(n){this.cb=n},di.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},di.prototype.onError=function(n){this.errorCbs.push(n)},di.prototype.transitionTo=function(n,e,t){var r,a=this;try{r=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var o=this.current;this.confirmTransition(r,(function(){a.updateRoute(r),e&&e(r),a.ensureURL(),a.router.afterHooks.forEach((function(n){n&&n(r,o)})),a.ready||(a.ready=!0,a.readyCbs.forEach((function(n){n(r)})))}),(function(n){t&&t(n),n&&!a.ready&&(ai(n,Zo.redirected)&&o===Wa||(a.ready=!0,a.readyErrorCbs.forEach((function(e){e(n)}))))}))},di.prototype.confirmTransition=function(n,e,t){var r=this,o=this.current;this.pending=n;var i,s,l=function(n){!ai(n)&&ri(n)&&(r.errorCbs.length?r.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},c=n.matched.length-1,d=o.matched.length-1;if(Ka(n,o)&&c===d&&n.matched[c]===o.matched[d])return this.ensureURL(),l(((s=ei(i=o,n,Zo.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",s));var p=function(n,e){var t,r=Math.max(n.length,e.length);for(t=0;t<r&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),u=p.updated,h=p.deactivated,m=p.activated,f=[].concat(function(n){return pi(n,"beforeRouteLeave",ui,!0)}(h),this.router.beforeHooks,function(n){return pi(n,"beforeRouteUpdate",ui)}(u),m.map((function(n){return n.beforeEnter})),oi(m)),g=function(e,t){if(r.pending!==n)return l(ni(o,n));try{e(n,o,(function(e){!1===e?(r.ensureURL(!0),l(function(n,e){return ei(n,e,Zo.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(o,n))):ri(e)?(r.ensureURL(!0),l(e)):"string"==typeof e||"object"===Object(a.a)(e)&&("string"==typeof e.path||"string"==typeof e.name)?(l(Qo(o,n)),"object"===Object(a.a)(e)&&e.replace?r.replace(e):r.push(e)):t(e)}))}catch(n){l(n)}};Yo(f,g,(function(){Yo(function(n){return pi(n,"beforeRouteEnter",(function(n,e,t,r){return function(n,e,t){return function(r,a,o){return n(r,a,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),o(n)}))}}(n,t,r)}))}(m).concat(r.router.resolveHooks),g,(function(){if(r.pending!==n)return l(ni(o,n));r.pending=null,e(n),r.router.app&&r.router.app.$nextTick((function(){Za(n)}))}))}))},di.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},di.prototype.setupListeners=function(){},di.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=Wa,this.pending=null};var hi=function(n){function e(e,t){n.call(this,e,t),this._startLocation=mi(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,r=Go&&t;r&&this.listeners.push(zo());var a=function(){var t=n.current,a=mi(n.base);n.current===Wa&&a===n._startLocation||n.transitionTo(a,(function(n){r&&qo(e,n,t,!0)}))};window.addEventListener("popstate",a),this.listeners.push((function(){window.removeEventListener("popstate",a)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Xo(to(r.base+n.fullPath)),qo(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){Ko(to(r.base+n.fullPath)),qo(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(mi(this.base)!==this.current.fullPath){var e=to(this.base+this.current.fullPath);n?Xo(e):Ko(e)}},e.prototype.getCurrentLocation=function(){return mi(this.base)},e}(di);function mi(n){var e=window.location.pathname;return n&&0===e.toLowerCase().indexOf(n.toLowerCase())&&(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var fi=function(n){function e(e,t,r){n.call(this,e,t),r&&function(n){var e=mi(n);if(!/^\/#/.test(e))return window.location.replace(to(n+"/#"+e)),!0}(this.base)||gi()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=Go&&e;t&&this.listeners.push(zo());var r=function(){var e=n.current;gi()&&n.transitionTo(vi(),(function(r){t&&qo(n.router,r,e,!0),Go||xi(r.fullPath)}))},a=Go?"popstate":"hashchange";window.addEventListener(a,r),this.listeners.push((function(){window.removeEventListener(a,r)}))}},e.prototype.push=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){yi(n.fullPath),qo(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this,a=this.current;this.transitionTo(n,(function(n){xi(n.fullPath),qo(r.router,n,a,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;vi()!==e&&(n?yi(e):xi(e))},e.prototype.getCurrentLocation=function(){return vi()},e}(di);function gi(){var n=vi();return"/"===n.charAt(0)||(xi("/"+n),!1)}function vi(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function bi(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function yi(n){Go?Xo(bi(n)):window.location.hash=n}function xi(n){Go?Ko(bi(n)):window.location.replace(bi(n))}var wi=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index+1).concat(n),r.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var r=this;this.transitionTo(n,(function(n){r.stack=r.stack.slice(0,r.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var n=e.current;e.index=t,e.updateRoute(r),e.router.afterHooks.forEach((function(e){e&&e(r,n)}))}),(function(n){ai(n,Zo.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(di),Ei=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Io(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!Go&&!1!==n.fallback,this.fallback&&(e="hash"),ko||(e="abstract"),this.mode=e,e){case"history":this.history=new hi(this,n.base);break;case"hash":this.history=new fi(this,n.base,this.fallback);break;case"abstract":this.history=new wi(this,n.base);break;default:0}},Ai={currentRoute:{configurable:!0}};function Si(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Ei.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Ai.currentRoute.get=function(){return this.history&&this.history.current},Ei.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof hi||t instanceof fi){var r=function(n){t.setupListeners(),function(n){var r=t.current,a=e.options.scrollBehavior;Go&&a&&"fullPath"in n&&qo(e,n,r,!1)}(n)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Ei.prototype.beforeEach=function(n){return Si(this.beforeHooks,n)},Ei.prototype.beforeResolve=function(n){return Si(this.resolveHooks,n)},Ei.prototype.afterEach=function(n){return Si(this.afterHooks,n)},Ei.prototype.onReady=function(n,e){this.history.onReady(n,e)},Ei.prototype.onError=function(n){this.history.onError(n)},Ei.prototype.push=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.push(n,e,t)}));this.history.push(n,e,t)},Ei.prototype.replace=function(n,e,t){var r=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){r.history.replace(n,e,t)}));this.history.replace(n,e,t)},Ei.prototype.go=function(n){this.history.go(n)},Ei.prototype.back=function(){this.go(-1)},Ei.prototype.forward=function(){this.go(1)},Ei.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Ei.prototype.resolve=function(n,e,t){var r=Eo(n,e=e||this.history.current,t,this),a=this.match(r,e),o=a.redirectedFrom||a.fullPath;return{location:r,route:a,href:function(n,e,t){var r="hash"===t?"#"+e:e;return n?to(n+"/"+r):r}(this.history.base,o,this.mode),normalizedTo:r,resolved:a}},Ei.prototype.getRoutes=function(){return this.matcher.getRoutes()},Ei.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==Wa&&this.history.transitionTo(this.history.getCurrentLocation())},Ei.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==Wa&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Ei.prototype,Ai),Ei.install=function n(e){if(!n.installed||Ao!==e){n.installed=!0,Ao=e;var t=function(n){return void 0!==n},r=function(n,e){var r=n.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",Qa),e.component("RouterLink",Mo);var a=e.config.optionMergeStrategies;a.beforeRouteEnter=a.beforeRouteLeave=a.beforeRouteUpdate=a.created}},Ei.version="3.5.1",Ei.isNavigationFailure=ai,Ei.NavigationFailureType=Zo,Ei.START_LOCATION=Wa,ko&&window.Vue&&window.Vue.use(Ei);var Mi=Ei;t(188),t(87),t(222),t(227);function Ci(n){n.locales&&Object.keys(n.locales).forEach((function(e){n.locales[e].path=e})),Object.freeze(n)}var ki=t(76),Ti=(t(224),t(225),{NotFound:function(){return Promise.all([t.e(0),t.e(5)]).then(t.bind(null,522))},Layout:function(){return Promise.all([t.e(0),t.e(2)]).then(t.bind(null,521))}}),ji={"v-45248497":function(){return t.e(6).then(t.bind(null,523))},"v-18fbc6ff":function(){return t.e(7).then(t.bind(null,524))},"v-0d3e36b3":function(){return t.e(8).then(t.bind(null,525))},"v-19c72b85":function(){return t.e(9).then(t.bind(null,526))},"v-6b4adb51":function(){return t.e(10).then(t.bind(null,527))},"v-0402a1bd":function(){return t.e(11).then(t.bind(null,528))},"v-4f8b20a7":function(){return t.e(12).then(t.bind(null,529))},"v-7eb01deb":function(){return t.e(13).then(t.bind(null,530))},"v-00ad09c8":function(){return t.e(14).then(t.bind(null,531))},"v-3d1ebebc":function(){return t.e(15).then(t.bind(null,532))},"v-3cc5bc10":function(){return t.e(16).then(t.bind(null,533))},"v-2ae52180":function(){return t.e(17).then(t.bind(null,534))},"v-4e171c5f":function(){return t.e(18).then(t.bind(null,535))},"v-36755d7a":function(){return t.e(19).then(t.bind(null,536))},"v-4fefe66d":function(){return t.e(20).then(t.bind(null,537))},"v-d51657cc":function(){return t.e(21).then(t.bind(null,538))},"v-2127413f":function(){return t.e(22).then(t.bind(null,539))},"v-5f9e1822":function(){return t.e(23).then(t.bind(null,540))},"v-d8f4ec52":function(){return t.e(24).then(t.bind(null,541))},"v-4e5c5b42":function(){return t.e(25).then(t.bind(null,542))},"v-8f833ce6":function(){return t.e(26).then(t.bind(null,543))},"v-4752b513":function(){return t.e(27).then(t.bind(null,544))},"v-7dbeb206":function(){return t.e(28).then(t.bind(null,545))},"v-07bf9581":function(){return t.e(29).then(t.bind(null,546))},"v-3d3237bb":function(){return t.e(30).then(t.bind(null,547))},"v-3ccab19a":function(){return t.e(31).then(t.bind(null,548))},"v-1b2b24b9":function(){return t.e(32).then(t.bind(null,549))},"v-5cdadc98":function(){return t.e(33).then(t.bind(null,550))},"v-622dd6e2":function(){return t.e(34).then(t.bind(null,551))},"v-4b50a00a":function(){return t.e(35).then(t.bind(null,552))},"v-03e359ac":function(){return t.e(36).then(t.bind(null,553))},"v-8b35246c":function(){return t.e(37).then(t.bind(null,554))},"v-b2e55526":function(){return t.e(38).then(t.bind(null,555))},"v-66d7ae3e":function(){return t.e(39).then(t.bind(null,556))},"v-0f156278":function(){return t.e(40).then(t.bind(null,557))},"v-3353134e":function(){return t.e(41).then(t.bind(null,558))},"v-373d1524":function(){return t.e(42).then(t.bind(null,559))},"v-0f580052":function(){return t.e(43).then(t.bind(null,560))},"v-562e8b1e":function(){return t.e(44).then(t.bind(null,561))},"v-2cb7c104":function(){return t.e(45).then(t.bind(null,562))},"v-35f7b9be":function(){return t.e(46).then(t.bind(null,563))},"v-44cd0617":function(){return t.e(47).then(t.bind(null,564))},"v-ea5e1dca":function(){return t.e(48).then(t.bind(null,565))},"v-f2f938b2":function(){return t.e(49).then(t.bind(null,566))},"v-edfc93ba":function(){return t.e(50).then(t.bind(null,567))},"v-7efc302c":function(){return t.e(51).then(t.bind(null,568))},"v-0ec4a241":function(){return t.e(52).then(t.bind(null,569))},"v-4494dd70":function(){return t.e(53).then(t.bind(null,570))},"v-6d65ba6a":function(){return t.e(54).then(t.bind(null,571))},"v-7a35187e":function(){return t.e(55).then(t.bind(null,572))},"v-85b99504":function(){return t.e(56).then(t.bind(null,573))},"v-17f5e21f":function(){return t.e(57).then(t.bind(null,574))},"v-172dff02":function(){return t.e(58).then(t.bind(null,575))},"v-7a7efcc2":function(){return t.e(59).then(t.bind(null,576))},"v-6a44bbb8":function(){return t.e(60).then(t.bind(null,577))}};function Ii(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var Bi=/-(\w)/g,_i=Ii((function(n){return n.replace(Bi,(function(n,e){return e?e.toUpperCase():""}))})),Li=/\B([A-Z])/g,Pi=Ii((function(n){return n.replace(Li,"-$1").toLowerCase()})),Oi=Ii((function(n){return n.charAt(0).toUpperCase()+n.slice(1)}));function Di(n,e){if(e)return n(e)?n(e):e.includes("-")?n(Oi(_i(e))):n(Oi(e))||n(Pi(e))}var Ri=Object.assign({},Ti,ji),zi=function(n){return Ri[n]},qi=function(n){return ji[n]},Hi=function(n){return Ti[n]},Fi=function(n){return Pa.component(n)};function Ni(n){return Di(qi,n)}function Ui(n){return Di(Hi,n)}function Ji(n){return Di(zi,n)}function $i(n){return Di(Fi,n)}function Vi(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return Promise.all(e.filter((function(n){return n})).map(function(){var n=Object(r.a)(regeneratorRuntime.mark((function n(e){var t;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if($i(e)||!Ji(e)){n.next=5;break}return n.next=3,Ji(e)();case 3:t=n.sent,Pa.component(e,t.default);case 5:case"end":return n.stop()}}),n)})));return function(e){return n.apply(this,arguments)}}()))}function Wi(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var Gi=t(148),Xi=t(218),Ki=t.n(Xi),Yi={created:function(){if(this.siteMeta=this.$site.headTags.filter((function(n){return"meta"===Object(Gi.a)(n,1)[0]})).map((function(n){var e=Object(Gi.a)(n,2);e[0];return e[1]})),this.$ssrContext){var n=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(e=n)?e.map((function(n){var e="<meta";return Object.keys(n).forEach((function(t){e+=" ".concat(t,'="').concat(n[t],'"')})),e+">"})).join("\n    "):""}var e},mounted:function(){this.currentMetaTags=Object(ki.a)(document.querySelectorAll("meta")),this.updateMeta()},methods:{updateMeta:function(){document.title=this.$title,document.documentElement.lang=this.$lang;var n=this.getMergedMetaTags();this.currentMetaTags=Zi(n,this.currentMetaTags)},getMergedMetaTags:function(){var n=this.$page.frontmatter.meta||[];return Ki()([{name:"description",content:this.$description}],n,this.siteMeta,Qi)}},watch:{$page:function(){this.updateMeta()}},beforeDestroy:function(){Zi(null,this.currentMetaTags)}};function Zi(n,e){if(e&&Object(ki.a)(e).filter((function(n){return n.parentNode===document.head})).forEach((function(n){return document.head.removeChild(n)})),n)return n.map((function(n){var e=document.createElement("meta");return Object.keys(n).forEach((function(t){e.setAttribute(t,n[t])})),document.head.appendChild(e),e}))}function Qi(n){for(var e=0,t=["name","property","itemprop"];e<t.length;e++){var r=t[e];if(n.hasOwnProperty(r))return n[r]+r}return JSON.stringify(n)}var ns=t(169),es={mounted:function(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ns)()((function(){this.setActiveHash()}),300),setActiveHash:function(){for(var n=this,e=[].slice.call(document.querySelectorAll(".sidebar-link")),t=[].slice.call(document.querySelectorAll(".header-anchor")).filter((function(n){return e.some((function(e){return e.hash===n.hash}))})),r=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),o=window.innerHeight+r,i=0;i<t.length;i++){var s=t[i],l=t[i+1],c=0===i&&0===r||r>=s.parentElement.offsetTop+10&&(!l||r<l.parentElement.offsetTop-10),d=decodeURIComponent(this.$route.hash);if(c&&d!==decodeURIComponent(s.hash)){var p=s;if(o===a)for(var u=i+1;u<t.length;u++)if(d===decodeURIComponent(t[u].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(p.hash),(function(){n.$nextTick((function(){n.$vuepress.$set("disableScrollBehavior",!1)}))}))}}}},beforeDestroy:function(){window.removeEventListener("scroll",this.onScroll)}},ts=t(102),rs=t.n(ts),as={mounted:function(){var n=this;rs.a.configure({showSpinner:!1}),this.$router.beforeEach((function(n,e,t){n.path===e.path||Pa.component(n.name)||rs.a.start(),t()})),this.$router.afterEach((function(){rs.a.done(),n.isSidebarOpen=!1}))}};t(360);function os(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function is(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function ss(n,e,t){return e&&is(n.prototype,e),t&&is(n,t),n}t(361);var ls=function(){function n(){os(this,n);this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}return ss(n,[{key:"show",value:function(n){var e=this,t=n.text,r=void 0===t?"":t,a=n.duration,o=void 0===a?3e3:a,i=document.createElement("div");i.className="message move-in",i.innerHTML='\n      <i style="fill: #06a35a;font-size: 14px;coolr: #06a35a" style="display:flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">'.concat(r,"</div>\n    "),this.containerEl.appendChild(i),o>0&&setTimeout((function(){e.close(i)}),o)}},{key:"close",value:function(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",(function(){n.remove()}))}}]),n}(),cs={mounted:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy:function(){var n=this;setTimeout((function(){(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach((function(e){document.querySelectorAll(e).forEach(n.generateCopyButton)}))}),1e3)},generateCopyButton:function(n){var e=this;if(!n.classList.contains("codecopy-enabled")){var t=document.createElement("i");t.className="code-copy",t.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',t.title="Click to Copy to Clipboard",t.addEventListener("click",(function(){e.copyToClipboard(n.innerText)})),n.appendChild(t),n.classList.add("codecopy-enabled")}},copyToClipboard:function(n){var e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);var t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy"),(new ls).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],a=document.createElement("style");a.type="text/css","top"===t&&r.firstChild?r.insertBefore(a,r.firstChild):r.appendChild(a),a.styleSheet?a.styleSheet.cssText=n:a.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var ds={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},ps={},us=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},hs=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:ds[n]},ms=function n(e,t,r){var a=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))a[n]=t[n];else{var e=n.replace("data","");a.dataset[e]=t[n]}})),r&&r.forEach((function(e){var t=e.tag,r=e.attrs,o=e.children;a.appendChild(n(t,r,o))})),a},fs=function(n,e,t){var r,a=(r=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(r));return 1!==a.length||t?a:a[0]},gs=function(n,e){var t,r,a=n.match(/<style>([\s\S]+)<\/style>/),o=n.match(/<template>([\s\S]+)<\/template>/),i=n.match(/<script>([\s\S]+)<\/script>/),s={css:a&&a[1].replace(/^\n|\n$/g,""),html:o&&o[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=us(s.html),s.jsTpl=(t=s.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),a=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,o=[eval][0](a);return o.template=e,o}(s.js,s.html);var l=hs("vue");return s.jsLib.unshift(l),s},vs=function(n,e){var t,r=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<html>([\s\S]+)<\/html>/),o=n.match(/<script>([\s\S]+)<\/script>/),i={css:r&&r[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return i.htmlTpl=i.html,i.jsTpl=i.js,i.script=(t=i.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),i},bs=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function ys(){var n=fs(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=fs(n,"vuepress-plugin-demo-block__code"),t=fs(n,"vuepress-plugin-demo-block__display"),r=fs(n,"vuepress-plugin-demo-block__footer"),a=fs(t,"vuepress-plugin-demo-block__app"),o=decodeURIComponent(n.dataset.code),i=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);i=i?JSON.parse(i):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),a=new Function("return ".concat(r))(),o={js:a,css:a.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:bs(n),htmlTpl:us("")},i=hs("react"),s=hs("reactDOM");return o.jsLib.unshift(i,s),o}(o,i):"vanilla"===s?vs(o,i):gs(o,i),d=ms("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(d),d.addEventListener("click",xs.bind(null,d,l,e,r)),hs("jsfiddle")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,a=n.jsLib,o=n.cssLib,i=a.concat(o).concat(hs("cssLib")).concat(hs("jsLib")).join(",");return ms("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:i}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),hs("codepen")&&r.appendChild(function(n){var e=n.css,t=n.htmlTpl,r=n.jsTpl,a=n.jsLib,o=n.cssLib,i=JSON.stringify({css:e,html:t,js:r,js_external:a.concat(hs("jsLib")).join(";"),css_external:o.concat(hs("cssLib")).join(";"),layout:hs("codepenLayout"),js_pre_processor:hs("codepenJsProcessor"),editors:hs("codepenEditors")});return ms("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:i}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==i.horizontal?i.horizontal:hs("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var p=e.firstChild.cloneNode(!0);p.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(p)}if(c.css&&function(n){if(!ps[n]){var e=ms("style",{innerHTML:n});document.body.appendChild(e),ps[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),a);else if("vue"===s){var u=(new(Vue.extend(c.script))).$mount();a.appendChild(u.$el)}else"vanilla"===s&&(a.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){ys()}),300)}function xs(n,e,t,r){var a="1"!==n.dataset.isExpand;t.style.height=a?"".concat(e,"px"):0,a?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=a?"1":"0"}var ws={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},ys()},updated:function(){ys()}},Es="auto",As="zoom-in",Ss="zoom-out",Ms="grab",Cs="move";function ks(n,e,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a={passive:!1};r?n.addEventListener(e,t,a):n.removeEventListener(e,t,a)}function Ts(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function js(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Is(n,e,t){!function(n){var e=Bs,t=_s;if(n.transition){var r=n.transition;delete n.transition,n[e]=r}if(n.transform){var a=n.transform;delete n.transform,n[t]=a}}(e);var r=n.style,a={};for(var o in e)t&&(a[o]=r[o]||""),r[o]=e[o];return a}var Bs="transition",_s="transform",Ls="transform",Ps="transitionend";var Os=function(){},Ds={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Os,onClose:Os,onGrab:Os,onMove:Os,onRelease:Os,onBeforeOpen:Os,onBeforeClose:Os,onBeforeGrab:Os,onBeforeRelease:Os,onImageLoading:Os,onImageLoaded:Os},Rs={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),qs(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var r=this.lastScrollPosition.x-e,a=this.lastScrollPosition.y-t,o=this.options.scrollThreshold;(Math.abs(a)>=o||Math.abs(r)>=o)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(zs(n)&&!qs(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){zs(n)&&!qs(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,r=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,r=e.clientY;this.move(t,r)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function zs(n){return 0===n.button}function qs(n){return n.metaKey||n.ctrlKey}var Hs={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Is(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),ks(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Is(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},Fs="function"==typeof Symbol&&"symbol"===Object(a.a)(Symbol.iterator)?function(n){return Object(a.a)(n)}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":Object(a.a)(n)},Ns=function(){function n(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}return function(e,t,r){return t&&n(e.prototype,t),r&&n(e,r),e}}(),Us=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(n[r]=t[r])}return n},Js={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=js(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,r=n.transitionDuration,a=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Ms:Ss,transition:Ls+"\n        "+r+"s\n        "+a,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Is(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Is(this.el,{transform:"none"})},grab:function(n,e,t){var r=$s(),a=r.x-n,o=r.y-e;Is(this.el,{cursor:Cs,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var r=$s(),a=r.x-n,o=r.y-e;Is(this.el,{transition:Ls,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Is(this.el,this.styleClose)},restoreOpenStyle:function(){Is(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=$s(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,r=this.instance.options,a=r.customSize,o=r.scaleBase;if(!a&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(a&&"object"===(void 0===a?"undefined":Fs(a)))return{x:a.width/this.rect.width,y:a.height/this.rect.height};var i=this.rect.width/2,s=this.rect.height/2,l=$s(),c={x:l.x-i,y:l.y-s},d=c.x/i,p=c.y/s,u=o+Math.min(d,p);if(a&&"string"==typeof a){var h=t||this.el.naturalWidth,m=e||this.el.naturalHeight,f=parseFloat(a)*h/(100*this.rect.width),g=parseFloat(a)*m/(100*this.rect.height);if(u>f||u>g)return{x:f,y:g}}return{x:u,y:u}}};function $s(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Vs(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){ks(n,r,e[r],t)}))}var Ws=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(Js),this.overlay=Object.create(Hs),this.handler=Object.create(Rs),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=Us({},Ds,e),this.overlay.init(this),this.handler.init(this)}return Ns(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=As,ks(n,"click",this.handler.click),this.options.preloadImage&&Ts(js(n)));return this}},{key:"config",value:function(n){return n?(Us(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof n?document.querySelector(n):n;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var a=this.target.srcOriginal;null!=a&&(this.options.onImageLoading(r),Ts(a,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),ks(document,"scroll",this.handler.scroll),ks(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&ks(window,"resize",this.handler.resizeWindow);var o=function n(){ks(r,Ps,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&Vs(document,e.handler,!0),t(r)};return ks(r,Ps,o),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Es,this.overlay.fadeOut(),this.target.zoomOut(),ks(document,"scroll",this.handler.scroll,!1),ks(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&ks(window,"resize",this.handler.resizeWindow,!1);var r=function r(){ks(t,Ps,r,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Vs(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return ks(t,Ps,r),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var a=this.target.el;this.options.onBeforeGrab(a),this.released=!1,this.target.grab(n,e,t);var o=function n(){ks(a,Ps,n,!1),r(a)};return ks(a,Ps,o),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Cs,this.target.move(n,e,t);var a=this.target.el,o=function n(){ks(a,Ps,n,!1),r(a)};return ks(a,Ps,o),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Es,this.target.restoreOpenStyle();var r=function r(){ks(t,Ps,r,!1),n.lock=!1,n.released=!0,e(t)};return ks(t,Ps,r),this}}}]),n}(),Gs=".theme-vdoing-content img:not(.no-zoom)",Xs=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),Ks=Number("500"),Ys=function(){function n(){os(this,n),this.instance=new Ws(Xs)}return ss(n,[{key:"update",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gs;"undefined"!=typeof window&&this.instance.listen(n)}},{key:"updateDelay",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gs,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Ks;setTimeout((function(){return n.update(e)}),t)}}]),n}(),Zs={watch:{"$page.path":function(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted:function(){this.$vuepress.zooming=new Ys,this.$vuepress.zooming.updateDelay()}},Qs=(t(362),t(363),t(364),[Yi,es,as,cs,ws,Zs,{}]),nl={name:"GlobalLayout",computed:{layout:function(){var n=this.getLayout();return Wi("layout",n),Pa.component(n)}},methods:{getLayout:function(){if(this.$page.path){var n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},el=t(16),tl=Object(el.a)(nl,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){var r;switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),(r=n[e]).push.apply(r,Object(ki.a)(t));break;default:throw new Error("Unknown option name.")}}(tl,"mixins",Qs);var rl=[{name:"v-45248497",path:"/pages/aaba75/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-45248497").then(t)}},{path:"/pages/aaba75/index.html",redirect:"/pages/aaba75/"},{path:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/01.%E5%9F%BA%E7%A1%80/02.Java%E4%B8%ADString%E7%9A%84%E5%AD%98%E5%82%A8.html",redirect:"/pages/aaba75/"},{name:"v-18fbc6ff",path:"/pages/39d636/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-18fbc6ff").then(t)}},{path:"/pages/39d636/index.html",redirect:"/pages/39d636/"},{path:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/01.%E5%9F%BA%E7%A1%80/03.Java%E4%B8%AD%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB.html",redirect:"/pages/39d636/"},{name:"v-0d3e36b3",path:"/pages/6cec3e/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-0d3e36b3").then(t)}},{path:"/pages/6cec3e/index.html",redirect:"/pages/6cec3e/"},{path:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/01.%E5%9F%BA%E7%A1%80/04.Java%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86.html",redirect:"/pages/6cec3e/"},{name:"v-19c72b85",path:"/pages/95a02e/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-19c72b85").then(t)}},{path:"/pages/95a02e/index.html",redirect:"/pages/95a02e/"},{path:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/01.%E5%9F%BA%E7%A1%80/05.Java%E4%B8%AD%E7%9A%84%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB.html",redirect:"/pages/95a02e/"},{name:"v-6b4adb51",path:"/pages/b725c0/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-6b4adb51").then(t)}},{path:"/pages/b725c0/index.html",redirect:"/pages/b725c0/"},{path:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/01.%E5%9F%BA%E7%A1%80/06.Java8%E6%96%B0%E6%97%A5%E6%9C%9FAPI.html",redirect:"/pages/b725c0/"},{name:"v-0402a1bd",path:"/pages/405394/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-0402a1bd").then(t)}},{path:"/pages/405394/index.html",redirect:"/pages/405394/"},{path:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/01.%E5%9F%BA%E7%A1%80/07.Java%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE.html",redirect:"/pages/405394/"},{name:"v-4f8b20a7",path:"/pages/226a87/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-4f8b20a7").then(t)}},{path:"/pages/226a87/index.html",redirect:"/pages/226a87/"},{path:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/01.%E5%9F%BA%E7%A1%80/08.Java%E4%B8%AD%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html",redirect:"/pages/226a87/"},{name:"v-7eb01deb",path:"/pages/72f0d2/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-7eb01deb").then(t)}},{path:"/pages/72f0d2/index.html",redirect:"/pages/72f0d2/"},{path:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/01.%E5%9F%BA%E7%A1%80/100.Java%E4%B8%AD%E7%9A%84%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A%E5%BC%95%E7%94%A8.html",redirect:"/pages/72f0d2/"},{name:"v-00ad09c8",path:"/pages/6ff86f/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-00ad09c8").then(t)}},{path:"/pages/6ff86f/index.html",redirect:"/pages/6ff86f/"},{path:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/01.%E5%9F%BA%E7%A1%80/21.Java%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%A5%E6%9F%84.html",redirect:"/pages/6ff86f/"},{name:"v-3d1ebebc",path:"/pages/0a8d09/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-3d1ebebc").then(t)}},{path:"/pages/0a8d09/index.html",redirect:"/pages/0a8d09/"},{path:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/01.%E5%9F%BA%E7%A1%80/22.Java%E5%8F%8D%E5%B0%84.html",redirect:"/pages/0a8d09/"},{name:"v-3cc5bc10",path:"/pages/3bb6cb/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-3cc5bc10").then(t)}},{path:"/pages/3bb6cb/index.html",redirect:"/pages/3bb6cb/"},{path:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/02.%E9%9B%86%E5%90%88/01.Java%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0.html",redirect:"/pages/3bb6cb/"},{name:"v-2ae52180",path:"/pages/574b5f/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-2ae52180").then(t)}},{path:"/pages/574b5f/index.html",redirect:"/pages/574b5f/"},{path:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/02.%E9%9B%86%E5%90%88/100.Java%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84ConcurrentModificationException.html",redirect:"/pages/574b5f/"},{name:"v-4e171c5f",path:"/pages/d1fc66/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-4e171c5f").then(t)}},{path:"/pages/d1fc66/index.html",redirect:"/pages/d1fc66/"},{path:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/03.%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/01.volatile%E5%85%B3%E9%94%AE%E5%AD%97.html",redirect:"/pages/d1fc66/"},{name:"v-36755d7a",path:"/pages/994e0e/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-36755d7a").then(t)}},{path:"/pages/994e0e/index.html",redirect:"/pages/994e0e/"},{path:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/03.%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/11.ThreadLocal.html",redirect:"/pages/994e0e/"},{name:"v-4fefe66d",path:"/pages/140566/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-4fefe66d").then(t)}},{path:"/pages/140566/index.html",redirect:"/pages/140566/"},{path:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/03.%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/12.Java%E4%B8%AD%E7%9A%84LockSupport.html",redirect:"/pages/140566/"},{name:"v-d51657cc",path:"/pages/4d7f44/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-d51657cc").then(t)}},{path:"/pages/4d7f44/index.html",redirect:"/pages/4d7f44/"},{path:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/03.%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/21.AtomicInteger.html",redirect:"/pages/4d7f44/"},{name:"v-2127413f",path:"/pages/5825a9/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-2127413f").then(t)}},{path:"/pages/5825a9/index.html",redirect:"/pages/5825a9/"},{path:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/05.JVM/01.%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/01.Java%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.html",redirect:"/pages/5825a9/"},{name:"v-5f9e1822",path:"/pages/e71797/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-5f9e1822").then(t)}},{path:"/pages/e71797/index.html",redirect:"/pages/e71797/"},{path:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/06.JDBC/01.API%E6%A6%82%E8%BF%B0.html",redirect:"/pages/e71797/"},{name:"v-d8f4ec52",path:"/pages/856738/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-d8f4ec52").then(t)}},{path:"/pages/856738/index.html",redirect:"/pages/856738/"},{path:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.JavaScript/01.%E5%8F%98%E9%87%8F/01.%E5%8F%98%E9%87%8F.html",redirect:"/pages/856738/"},{name:"v-4e5c5b42",path:"/pages/fb73c5/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-4e5c5b42").then(t)}},{path:"/pages/fb73c5/index.html",redirect:"/pages/fb73c5/"},{path:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.JavaScript/02.%E6%95%B0%E7%BB%84/01.%E6%95%B0%E7%BB%84.html",redirect:"/pages/fb73c5/"},{name:"v-8f833ce6",path:"/pages/62d559/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-8f833ce6").then(t)}},{path:"/pages/62d559/index.html",redirect:"/pages/62d559/"},{path:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.JavaScript/03.%E5%AD%97%E7%AC%A6%E4%B8%B2/01.%E5%AD%97%E7%AC%A6%E4%B8%B2.html",redirect:"/pages/62d559/"},{name:"v-4752b513",path:"/pages/73d51c/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-4752b513").then(t)}},{path:"/pages/73d51c/index.html",redirect:"/pages/73d51c/"},{path:"/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.html",redirect:"/pages/73d51c/"},{name:"v-7dbeb206",path:"/pages/cc0ee9/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-7dbeb206").then(t)}},{path:"/pages/cc0ee9/index.html",redirect:"/pages/cc0ee9/"},{path:"/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/02.%E4%BB%8E%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%E4%B8%AD%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.html",redirect:"/pages/cc0ee9/"},{name:"v-07bf9581",path:"/pages/3bb416/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-07bf9581").then(t)}},{path:"/pages/3bb416/index.html",redirect:"/pages/3bb416/"},{path:"/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/03.%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.html",redirect:"/pages/3bb416/"},{name:"v-3d3237bb",path:"/pages/eca41b/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-3d3237bb").then(t)}},{path:"/pages/eca41b/index.html",redirect:"/pages/eca41b/"},{path:"/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/04.%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html",redirect:"/pages/eca41b/"},{name:"v-3ccab19a",path:"/pages/3d68de/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-3ccab19a").then(t)}},{path:"/pages/3d68de/index.html",redirect:"/pages/3d68de/"},{path:"/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/05.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.html",redirect:"/pages/3d68de/"},{name:"v-1b2b24b9",path:"/pages/cf9f2b/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-1b2b24b9").then(t)}},{path:"/pages/cf9f2b/index.html",redirect:"/pages/cf9f2b/"},{path:"/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/06.%E5%B0%86%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E8%B0%83%E6%95%B4%E5%B9%B3%E8%A1%A1.html",redirect:"/pages/cf9f2b/"},{name:"v-5cdadc98",path:"/pages/927005/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-5cdadc98").then(t)}},{path:"/pages/927005/index.html",redirect:"/pages/927005/"},{path:"/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/07.AVL%E6%A0%91.html",redirect:"/pages/927005/"},{name:"v-622dd6e2",path:"/pages/e812d0/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-622dd6e2").then(t)}},{path:"/pages/e812d0/index.html",redirect:"/pages/e812d0/"},{path:"/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/08.%E5%85%A8%E6%8E%92%E5%88%97.html",redirect:"/pages/e812d0/"},{name:"v-4b50a00a",path:"/pages/a056bd/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-4b50a00a").then(t)}},{path:"/pages/a056bd/index.html",redirect:"/pages/a056bd/"},{path:"/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/09.%E5%AD%90%E9%9B%86%E7%94%9F%E6%88%90.html",redirect:"/pages/a056bd/"},{name:"v-03e359ac",path:"/pages/4e8b73/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-03e359ac").then(t)}},{path:"/pages/4e8b73/index.html",redirect:"/pages/4e8b73/"},{path:"/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/01.%E7%BC%93%E5%AD%98/01.CPU%E7%BC%93%E5%AD%98%E7%9A%84%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84.html",redirect:"/pages/4e8b73/"},{name:"v-8b35246c",path:"/pages/856225/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-8b35246c").then(t)}},{path:"/pages/856225/index.html",redirect:"/pages/856225/"},{path:"/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/01.%E7%BC%93%E5%AD%98/02.CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0.html",redirect:"/pages/856225/"},{name:"v-b2e55526",path:"/pages/35e881/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-b2e55526").then(t)}},{path:"/pages/35e881/index.html",redirect:"/pages/35e881/"},{path:"/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/01.%E7%BC%93%E5%AD%98/03.CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%E4%B9%8BMSI.html",redirect:"/pages/35e881/"},{name:"v-66d7ae3e",path:"/pages/5709ee/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-66d7ae3e").then(t)}},{path:"/pages/5709ee/index.html",redirect:"/pages/5709ee/"},{path:"/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/01.%E7%BC%93%E5%AD%98/04.CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%E4%B9%8BMESI.html",redirect:"/pages/5709ee/"},{name:"v-0f156278",path:"/pages/b770ae/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-0f156278").then(t)}},{path:"/pages/b770ae/index.html",redirect:"/pages/b770ae/"},{path:"/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/01.%E7%BC%93%E5%AD%98/05.CPU%E4%B8%AD%E7%9A%84StoreBuffers.html",redirect:"/pages/b770ae/"},{name:"v-3353134e",path:"/pages/1f274f/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-3353134e").then(t)}},{path:"/pages/1f274f/index.html",redirect:"/pages/1f274f/"},{path:"/04.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/02.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/01.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%A6%82%E8%BF%B0.html",redirect:"/pages/1f274f/"},{name:"v-373d1524",path:"/pages/548a38/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-373d1524").then(t)}},{path:"/pages/548a38/index.html",redirect:"/pages/548a38/"},{path:"/04.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/03.%E7%BD%91%E7%BB%9C%E5%B1%82/01.%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0.html",redirect:"/pages/548a38/"},{name:"v-0f580052",path:"/pages/81b034/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-0f580052").then(t)}},{path:"/pages/81b034/index.html",redirect:"/pages/81b034/"},{path:"/04.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/04.%E4%BC%A0%E8%BE%93%E5%B1%82/01.UDP%E6%A6%82%E8%BF%B0.html",redirect:"/pages/81b034/"},{name:"v-562e8b1e",path:"/collections/websites/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-562e8b1e").then(t)}},{path:"/collections/websites/index.html",redirect:"/collections/websites/"},{path:"/102.%E6%94%B6%E8%97%8F%E5%A4%B9/01.%E7%BD%91%E7%AB%99.html",redirect:"/collections/websites/"},{name:"v-2cb7c104",path:"/collections/books/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-2cb7c104").then(t)}},{path:"/collections/books/index.html",redirect:"/collections/books/"},{path:"/102.%E6%94%B6%E8%97%8F%E5%A4%B9/02.%E4%B9%A6%E7%B1%8D.html",redirect:"/collections/books/"},{name:"v-35f7b9be",path:"/pages/0c4c2e/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-35f7b9be").then(t)}},{path:"/pages/0c4c2e/index.html",redirect:"/pages/0c4c2e/"},{path:"/22.%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/01.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/01.Spring%20Framework/02.AOP/01.AOP%E5%9F%BA%E7%A1%80.html",redirect:"/pages/0c4c2e/"},{name:"v-44cd0617",path:"/pages/f167d9/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-44cd0617").then(t)}},{path:"/pages/f167d9/index.html",redirect:"/pages/f167d9/"},{path:"/22.%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/01.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/01.Spring%20Framework/03.Web/01.%E6%B3%A8%E5%86%8CDispatcherServlet.html",redirect:"/pages/f167d9/"},{name:"v-ea5e1dca",path:"/pages/668c92/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-ea5e1dca").then(t)}},{path:"/pages/668c92/index.html",redirect:"/pages/668c92/"},{path:"/22.%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/01.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/01.Spring%20Framework/03.Web/02.Xml%E9%85%8D%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8.html",redirect:"/pages/668c92/"},{name:"v-f2f938b2",path:"/pages/f2c795/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-f2f938b2").then(t)}},{path:"/pages/f2c795/index.html",redirect:"/pages/f2c795/"},{path:"/22.%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/01.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/01.Spring%20Framework/03.Web/03.%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BHandlerMapping.html",redirect:"/pages/f2c795/"},{name:"v-edfc93ba",path:"/pages/b2649d/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-edfc93ba").then(t)}},{path:"/pages/b2649d/index.html",redirect:"/pages/b2649d/"},{path:"/22.%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/01.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/01.Spring%20Framework/03.Web/04.%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BHandlerAdapter.html",redirect:"/pages/b2649d/"},{name:"v-7efc302c",path:"/pages/cd47ce/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-7efc302c").then(t)}},{path:"/pages/cd47ce/index.html",redirect:"/pages/cd47ce/"},{path:"/22.%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/01.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/01.Spring%20Framework/03.Web/05.%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html",redirect:"/pages/cd47ce/"},{name:"v-0ec4a241",path:"/pages/84c97b/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-0ec4a241").then(t)}},{path:"/pages/84c97b/index.html",redirect:"/pages/84c97b/"},{path:"/22.%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/01.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/02.Spring%20Boot/01.%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86.html",redirect:"/pages/84c97b/"},{name:"v-4494dd70",path:"/pages/f79e9e/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-4494dd70").then(t)}},{path:"/pages/f79e9e/index.html",redirect:"/pages/f79e9e/"},{path:"/22.%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/01.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/02.Spring%20Boot/21.SpringBoot%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html",redirect:"/pages/f79e9e/"},{name:"v-6d65ba6a",path:"/pages/e0358f/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-6d65ba6a").then(t)}},{path:"/pages/e0358f/index.html",redirect:"/pages/e0358f/"},{path:"/22.%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/01.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/02.Spring%20Boot/22.SpringBoot%E4%B8%ADFilter%E7%9A%84%E6%B3%A8%E5%86%8C.html",redirect:"/pages/e0358f/"},{name:"v-7a35187e",path:"/pages/65a539/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-7a35187e").then(t)}},{path:"/pages/65a539/index.html",redirect:"/pages/65a539/"},{path:"/99.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/01.maven/01.%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86.html",redirect:"/pages/65a539/"},{name:"v-85b99504",path:"/pages/a4afbf/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-85b99504").then(t)}},{path:"/pages/a4afbf/index.html",redirect:"/pages/a4afbf/"},{path:"/99.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/01.maven/02.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8F%92%E4%BB%B6.html",redirect:"/pages/a4afbf/"},{name:"v-17f5e21f",path:"/archives/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-17f5e21f").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-172dff02",path:"/categories/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-172dff02").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-7a7efcc2",path:"/tags/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-7a7efcc2").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-6a44bbb8",path:"/",component:tl,beforeEnter:function(n,e,t){Vi("Layout","v-6a44bbb8").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:tl}],al={title:"harrison's blog",description:"后端技术博客,简洁至上,专注Java学习与总结。Java, Spring, SpringBoot, SpringCloud, MyBatis, Netty, RabbitMQ, Kafka, Dubbo, Linux, Linux Kernel等技术文章。",base:"/",headTags:[["link",{rel:"icon",href:"/img/favicon.ico"}],["meta",{name:"keywords",content:"后端技术博客"}],["meta",{name:"baidu-site-verification",content:"7F55weZDDc"}],["meta",{name:"theme-color",content:"#11a8cd"}],["meta",{name:"viewport",content:"width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no"}]],pages:[{title:"Java中String的存储",frontmatter:{title:"Java中String的存储",categories:["编程语言"],tags:["Java"],date:"2020-06-27T00:00:00.000Z",permalink:"/pages/aaba75/"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/01.%E5%9F%BA%E7%A1%80/02.Java%E4%B8%ADString%E7%9A%84%E5%AD%98%E5%82%A8.html",relativePath:"01.编程语言/01.Java/01.基础/02.Java中String的存储.md",key:"v-45248497",path:"/pages/aaba75/",headers:[{level:2,title:"有哪些常量池",slug:"有哪些常量池",normalizedTitle:"有哪些常量池",charIndex:85},{level:3,title:"class常量池（Class Constant Pool）",slug:"class常量池（class-constant-pool）",normalizedTitle:"class常量池（class constant pool）",charIndex:94},{level:3,title:"运行时常量池（Runtime Constant Pool）",slug:"运行时常量池（runtime-constant-pool）",normalizedTitle:"运行时常量池（runtime constant pool）",charIndex:278},{level:3,title:"字符串常量池",slug:"字符串常量池",normalizedTitle:"字符串常量池",charIndex:479},{level:2,title:"字符串字面量什么时候进入字符串常量池",slug:"字符串字面量什么时候进入字符串常量池",normalizedTitle:"字符串字面量什么时候进入字符串常量池",charIndex:958},{level:2,title:"String的定义方式",slug:"string的定义方式",normalizedTitle:"string的定义方式",charIndex:1451},{level:3,title:"第一种方式",slug:"第一种方式",normalizedTitle:"第一种方式",charIndex:1515},{level:3,title:"第二种方式",slug:"第二种方式",normalizedTitle:"第二种方式",charIndex:1555},{level:2,title:"字符串的拼接",slug:"字符串的拼接",normalizedTitle:"字符串的拼接",charIndex:2069},{level:3,title:"concat()拼接",slug:"concat-拼接",normalizedTitle:"concat()拼接",charIndex:2117},{level:3,title:"运算符拼接",slug:"运算符拼接",normalizedTitle:"运算符拼接",charIndex:2292},{level:2,title:"intern()方法",slug:"intern-方法",normalizedTitle:"intern()方法",charIndex:3977},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1441}],excerpt:"<p>String的存储可能不是那么地直观，有些机制可能会违背我们的直觉。但是，这一问题又是面试的高频问题，同时理解好String的存储更有利于我们在写代码时更有底气。</p>\n",lastUpdated:"2021-01-22",headersStr:"有哪些常量池 class常量池（Class Constant Pool） 运行时常量池（Runtime Constant Pool） 字符串常量池 字符串字面量什么时候进入字符串常量池 String的定义方式 第一种方式 第二种方式 字符串的拼接 concat()拼接 运算符拼接 intern()方法 参考",content:'String的存储可能不是那么地直观，有些机制可能会违背我们的直觉。但是，这一问题又是面试的高频问题，同时理解好String的存储更有利于我们在写代码时更有底气。\n\n# 有哪些常量池\n# class常量池（Class Constant Pool）\nJava的class文件中有一部分称作为常量池，包含字面量（literal）和符号引用（Symbolic Reference）。对于class文件可以使用javap命令查看class常量池的具体细节。可以发现，CONSTANT_Utf8_info类型的常量可以表示文件中所有的标识符、字符串字面量等。\n\n# 运行时常量池（Runtime Constant Pool）\n在类加载后，class常量池中的内容将被加载到运行时常量池。方法区是JVM所要求的运行时数据区的一部分，但是不同的虚拟机对此有不同的实现，比如HotSpot早期（JDK8以前）就利用了**永久代（Permanent Generation）**来实现方法区。但由于种种原因，Hotsport于JDK6开始就逐步废弃永久代；到了JDK7时，已经把字符串常量池，静态变量等移除了；到了JDK8，把永久代的剩余内容转移到了元空间(Metaspace）中。运行时常量池属于方法区，但是JVM并没有要求方法区位于内存的哪一部分。Hotspot在废弃永久代后，采用本地内存（native memory）来实现方法区（即Metaspace所处的位置）。\n\n# 字符串常量池\n因为Java中String类型的值都是不会变化的，采用字符串常量池可以提高性能和减少内存开销，因为当多个String引用指向的String值相等时，只需要保存一份值即可，让其他引用都指向这个值。当需要修改时，然后再拷贝一份进行修改（有点像CopyOnWrite的感觉），同样修改后的字符串也是不可更改的，同样存在字符串常量池中供其他String引用所指向。\n\nJDK7之后，HotSpot就把字符串常量池从方法区中移出到了堆中，是一个哈希表结构，用于快速判断字符串对象是否已在常量池中。另外需要搞清楚，字符串常量池中存放的是java.lang.String对象的引用，而非对象本身，在Java中所有的对象本身以及数组对象都保存在堆中。\n\n# 字符串字面量什么时候进入字符串常量池\nJava中的class文件中的常量池中有两类常量：CONSTANT_Utf8_info和CONSTANT_String_info。前者存储真正的字符串内容，后者表示一个java.lang.String对象，存储的是前者类型的索引。\n\n就HotSpot的实现来说，在类加载时，class中的常量池的内容进入了内存形成了运行时常量池。这些CONSTANT_Utf8_info只是简单地存储到运行时常量池中，但是不会在堆中创建对象（注意对象和简单地字符串值还是有区别的，对象除了包括值，还有其他相关属性），也不会保存到全局的字符串常量池中，这被称为类加载阶段的懒解析。\n\nJVM中的ldc指令用于将int，float或String型常量值从常量池中推送至栈顶。前面讲到懒解析，ldc指令就是触发这个解析操作的。首先，通过CONSTANT_String_info中保存的CONSTANT_Utf8_info类型常量的索引找到对应的项，如果该项没有解析则进行解析，解析时涉及对象的创建，具体创建几个对象与String对象的定义方式有关，请参考下一节。\n\n# String的定义方式\nJava程序员都知道如下两种字符串的定义方式：\n\nString s1 = "harrison"; // 第一种方式\nString s2 = new String("lee"); // 第二种方式\nString s3 = new String("harrison");\n\n\n1\n2\n3\n# 第一种方式\n使用第一种方式时，JVM会去字符串常量池中找有没有值和当前字符串字面量相等的对象的引用。如果存在，则直接返回（创建0个对象）；如果不存在，则创建新对象，并把新对象的引用保存到字符串常量池中并返回（创建1个对象）。如下图所示：\n\n\n\n# 第二种方式\n使用第二种方式时，JVM同样会去找字符串常量池中有没有和当前字符串字面量相等的对象的引用。如果存在，则只管创建当前的对象（创建1个对象）；如果不存在，则会创建两个对象，其中1个对象的引用被保存到字符串常量池中，另一个对象的引用返回给变量。如下图所示：\n\n\n\n警告\n\n对于下列代码：\n\nString s1 = new String("harrison") + new String("lee")\n\n\n1\n下面讲字符串拼接时会看到，s1其实也是通过new创建的。但是注意只有“harrison”和“lee”这种字面量保存到了常量池中，“harrisonlee”没有被保存到常量池中，也就是说表达式右边的两个new分别创建了两个对象，但是对于s1，只创建了一个。\n\n# 字符串的拼接\n字符串的拼接可以使用运算符+，也可以调用字符串对象的方法concat()。\n\n# concat()拼接\n如果参数的长度为0，那么将会返回调用者本身。如：\n\nString s1 = "harrisonlee";\nString s2 = s1.concat("");\nSystem.out.println(s1 == s2); // true\n\n\n1\n2\n3\n如果长度不为0，则通过new的方式创建对象（具体创建几个要看情况）。\n\n# 运算符拼接\n这部分，在JDK8和JDK11下测试结果不一致^1。\n\n如下列代码：\n\nString s1 = "harrison";\nString s2 = "lee";\nString s3 = s1 + s2;\nString s4 = "harrisonlee";\nString s5 = "harrison" + s2;\nString s6 = "harrison" + "lee";\n\n\n1\n2\n3\n4\n5\n6\n在JDK8环境下，反编译后的结果如下：\n\nString s1 = "harrison";\nString s2 = "lee";\nString s3 = (new StringBuilder()).append(s1).append(s2).toString();\nString s4 = "harrisonlee";\nString s5 = (new StringBuilder()).append("harrison").append(s2).toString();\nString s6 = "harrisonlee";\n\n\n1\n2\n3\n4\n5\n6\n可见，如果拼接成分中全是字面量，那么编译器直接优化成拼接后的最后结果（如s6），在class常量池中也不存在单个字面量常量（除非在其他地方定义了），节省了字符串常量池的空间。如果拼接成分至少存在一个字符串对象的引用，那么编译器会优化为StringBuilder的方式，并调用append()方法实现拼接，最后的toString()方法内部是通过new方式创建的String对象。\n\n在JDK11下，好像使用了与concat()相关的方法来处理。\n\n  public void test01();\n    descriptor: ()V\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack=2, locals=7, args_size=1\n         0: ldc           #2                  // String harrison\n         2: astore_1\n         3: ldc           #3                  // String lee\n         5: astore_2\n         6: aload_1\n         7: aload_2\n         8: invokedynamic #4,  0              // InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;\n        13: astore_3\n        14: ldc           #5                  // String harrisonlee\n        16: astore        4\n        18: aload_2\n        19: invokedynamic #6,  0              // InvokeDynamic #1:makeConcatWithConstants:(Ljava/lang/String;)Ljava/lang/String;\n        24: astore        5\n        26: ldc           #5                  // String harrisonlee\n        28: astore        6\n        30: return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n上面第8行和第19行，分别调用了invokedynamic指令。\n\n# intern()方法\nintern()方法的作用是返回字符串常量池中保存的和当前字符串对象值相等的对象应用。如果存在，则直接返回；如果不存在，在JDK6前后的处理不一样。\n\n对于下列代码（假设之前常量池中不存在字符串“harrison”）：\n\nString s1 = new String("harrison") + new String("lee");\nString s2 = s1.intern();\nSystem.out.println(s1 == s2);\n\n\n1\n2\n3\n如果是在JDK6及其之前，虚拟机的行为是另外新建一个对象，并把该对象的引用保存到字符串常量池中。所以输出false。\n\n而如果是在JDK6之后，虚拟机会直接把该对象的引用保存到字符串常量池。所以输出true。JDK6以后intern()的行为明显避免了对象的创建，从而节省了空间。\n\n总之一句话就是，intern()方法返回该常量池中与该String对象值相等的被收纳进入常量池中的对象引用。\n\n# 参考\n * The SCJP Tip Line -- Strings, Literally\n   \n   \n * 知乎问答：参考用户木女孩的回答以及评论区中R大的留言\n   \n   \n * 《深入理解Java虚拟机（第3版）》',normalizedContent:'string的存储可能不是那么地直观，有些机制可能会违背我们的直觉。但是，这一问题又是面试的高频问题，同时理解好string的存储更有利于我们在写代码时更有底气。\n\n# 有哪些常量池\n# class常量池（class constant pool）\njava的class文件中有一部分称作为常量池，包含字面量（literal）和符号引用（symbolic reference）。对于class文件可以使用javap命令查看class常量池的具体细节。可以发现，constant_utf8_info类型的常量可以表示文件中所有的标识符、字符串字面量等。\n\n# 运行时常量池（runtime constant pool）\n在类加载后，class常量池中的内容将被加载到运行时常量池。方法区是jvm所要求的运行时数据区的一部分，但是不同的虚拟机对此有不同的实现，比如hotspot早期（jdk8以前）就利用了**永久代（permanent generation）**来实现方法区。但由于种种原因，hotsport于jdk6开始就逐步废弃永久代；到了jdk7时，已经把字符串常量池，静态变量等移除了；到了jdk8，把永久代的剩余内容转移到了元空间(metaspace）中。运行时常量池属于方法区，但是jvm并没有要求方法区位于内存的哪一部分。hotspot在废弃永久代后，采用本地内存（native memory）来实现方法区（即metaspace所处的位置）。\n\n# 字符串常量池\n因为java中string类型的值都是不会变化的，采用字符串常量池可以提高性能和减少内存开销，因为当多个string引用指向的string值相等时，只需要保存一份值即可，让其他引用都指向这个值。当需要修改时，然后再拷贝一份进行修改（有点像copyonwrite的感觉），同样修改后的字符串也是不可更改的，同样存在字符串常量池中供其他string引用所指向。\n\njdk7之后，hotspot就把字符串常量池从方法区中移出到了堆中，是一个哈希表结构，用于快速判断字符串对象是否已在常量池中。另外需要搞清楚，字符串常量池中存放的是java.lang.string对象的引用，而非对象本身，在java中所有的对象本身以及数组对象都保存在堆中。\n\n# 字符串字面量什么时候进入字符串常量池\njava中的class文件中的常量池中有两类常量：constant_utf8_info和constant_string_info。前者存储真正的字符串内容，后者表示一个java.lang.string对象，存储的是前者类型的索引。\n\n就hotspot的实现来说，在类加载时，class中的常量池的内容进入了内存形成了运行时常量池。这些constant_utf8_info只是简单地存储到运行时常量池中，但是不会在堆中创建对象（注意对象和简单地字符串值还是有区别的，对象除了包括值，还有其他相关属性），也不会保存到全局的字符串常量池中，这被称为类加载阶段的懒解析。\n\njvm中的ldc指令用于将int，float或string型常量值从常量池中推送至栈顶。前面讲到懒解析，ldc指令就是触发这个解析操作的。首先，通过constant_string_info中保存的constant_utf8_info类型常量的索引找到对应的项，如果该项没有解析则进行解析，解析时涉及对象的创建，具体创建几个对象与string对象的定义方式有关，请参考下一节。\n\n# string的定义方式\njava程序员都知道如下两种字符串的定义方式：\n\nstring s1 = "harrison"; // 第一种方式\nstring s2 = new string("lee"); // 第二种方式\nstring s3 = new string("harrison");\n\n\n1\n2\n3\n# 第一种方式\n使用第一种方式时，jvm会去字符串常量池中找有没有值和当前字符串字面量相等的对象的引用。如果存在，则直接返回（创建0个对象）；如果不存在，则创建新对象，并把新对象的引用保存到字符串常量池中并返回（创建1个对象）。如下图所示：\n\n\n\n# 第二种方式\n使用第二种方式时，jvm同样会去找字符串常量池中有没有和当前字符串字面量相等的对象的引用。如果存在，则只管创建当前的对象（创建1个对象）；如果不存在，则会创建两个对象，其中1个对象的引用被保存到字符串常量池中，另一个对象的引用返回给变量。如下图所示：\n\n\n\n警告\n\n对于下列代码：\n\nstring s1 = new string("harrison") + new string("lee")\n\n\n1\n下面讲字符串拼接时会看到，s1其实也是通过new创建的。但是注意只有“harrison”和“lee”这种字面量保存到了常量池中，“harrisonlee”没有被保存到常量池中，也就是说表达式右边的两个new分别创建了两个对象，但是对于s1，只创建了一个。\n\n# 字符串的拼接\n字符串的拼接可以使用运算符+，也可以调用字符串对象的方法concat()。\n\n# concat()拼接\n如果参数的长度为0，那么将会返回调用者本身。如：\n\nstring s1 = "harrisonlee";\nstring s2 = s1.concat("");\nsystem.out.println(s1 == s2); // true\n\n\n1\n2\n3\n如果长度不为0，则通过new的方式创建对象（具体创建几个要看情况）。\n\n# 运算符拼接\n这部分，在jdk8和jdk11下测试结果不一致^1。\n\n如下列代码：\n\nstring s1 = "harrison";\nstring s2 = "lee";\nstring s3 = s1 + s2;\nstring s4 = "harrisonlee";\nstring s5 = "harrison" + s2;\nstring s6 = "harrison" + "lee";\n\n\n1\n2\n3\n4\n5\n6\n在jdk8环境下，反编译后的结果如下：\n\nstring s1 = "harrison";\nstring s2 = "lee";\nstring s3 = (new stringbuilder()).append(s1).append(s2).tostring();\nstring s4 = "harrisonlee";\nstring s5 = (new stringbuilder()).append("harrison").append(s2).tostring();\nstring s6 = "harrisonlee";\n\n\n1\n2\n3\n4\n5\n6\n可见，如果拼接成分中全是字面量，那么编译器直接优化成拼接后的最后结果（如s6），在class常量池中也不存在单个字面量常量（除非在其他地方定义了），节省了字符串常量池的空间。如果拼接成分至少存在一个字符串对象的引用，那么编译器会优化为stringbuilder的方式，并调用append()方法实现拼接，最后的tostring()方法内部是通过new方式创建的string对象。\n\n在jdk11下，好像使用了与concat()相关的方法来处理。\n\n  public void test01();\n    descriptor: ()v\n    flags: (0x0001) acc_public\n    code:\n      stack=2, locals=7, args_size=1\n         0: ldc           #2                  // string harrison\n         2: astore_1\n         3: ldc           #3                  // string lee\n         5: astore_2\n         6: aload_1\n         7: aload_2\n         8: invokedynamic #4,  0              // invokedynamic #0:makeconcatwithconstants:(ljava/lang/string;ljava/lang/string;)ljava/lang/string;\n        13: astore_3\n        14: ldc           #5                  // string harrisonlee\n        16: astore        4\n        18: aload_2\n        19: invokedynamic #6,  0              // invokedynamic #1:makeconcatwithconstants:(ljava/lang/string;)ljava/lang/string;\n        24: astore        5\n        26: ldc           #5                  // string harrisonlee\n        28: astore        6\n        30: return\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n上面第8行和第19行，分别调用了invokedynamic指令。\n\n# intern()方法\nintern()方法的作用是返回字符串常量池中保存的和当前字符串对象值相等的对象应用。如果存在，则直接返回；如果不存在，在jdk6前后的处理不一样。\n\n对于下列代码（假设之前常量池中不存在字符串“harrison”）：\n\nstring s1 = new string("harrison") + new string("lee");\nstring s2 = s1.intern();\nsystem.out.println(s1 == s2);\n\n\n1\n2\n3\n如果是在jdk6及其之前，虚拟机的行为是另外新建一个对象，并把该对象的引用保存到字符串常量池中。所以输出false。\n\n而如果是在jdk6之后，虚拟机会直接把该对象的引用保存到字符串常量池。所以输出true。jdk6以后intern()的行为明显避免了对象的创建，从而节省了空间。\n\n总之一句话就是，intern()方法返回该常量池中与该string对象值相等的被收纳进入常量池中的对象引用。\n\n# 参考\n * the scjp tip line -- strings, literally\n   \n   \n * 知乎问答：参考用户木女孩的回答以及评论区中r大的留言\n   \n   \n * 《深入理解java虚拟机（第3版）》',charsets:{cjk:!0}},{title:"Java中的内部类",frontmatter:{title:"Java中的内部类",categories:["编程语言"],tags:["Java"],date:"2020-06-24T00:00:00.000Z",permalink:"/pages/39d636/"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/01.%E5%9F%BA%E7%A1%80/03.Java%E4%B8%AD%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB.html",relativePath:"01.编程语言/01.Java/01.基础/03.Java中的内部类.md",key:"v-18fbc6ff",path:"/pages/39d636/",headers:[{level:2,title:"什么是内部类及其分类",slug:"什么是内部类及其分类",normalizedTitle:"什么是内部类及其分类",charIndex:2},{level:2,title:"内部类的定义",slug:"内部类的定义",normalizedTitle:"内部类的定义",charIndex:296},{level:3,title:"静态内部类",slug:"静态内部类",normalizedTitle:"静态内部类",charIndex:68},{level:3,title:"成员内部类",slug:"成员内部类",normalizedTitle:"成员内部类",charIndex:77},{level:3,title:"局部内部类",slug:"局部内部类",normalizedTitle:"局部内部类",charIndex:86},{level:3,title:"匿名内部类",slug:"匿名内部类",normalizedTitle:"匿名内部类",charIndex:95},{level:2,title:"使用内部类的一些问题",slug:"使用内部类的一些问题",normalizedTitle:"使用内部类的一些问题",charIndex:1677},{level:3,title:"内部类与static",slug:"内部类与static",normalizedTitle:"内部类与static",charIndex:1690},{level:3,title:"内部类访问外围类的私有属性和方法",slug:"内部类访问外围类的私有属性和方法",normalizedTitle:"内部类访问外围类的私有属性和方法",charIndex:1913},{level:3,title:"外围类访问内部类的私有属性和方法",slug:"外围类访问内部类的私有属性和方法",normalizedTitle:"外围类访问内部类的私有属性和方法",charIndex:2544},{level:3,title:"局部内部类和匿名内部类访问局部变量",slug:"局部内部类和匿名内部类访问局部变量",normalizedTitle:"局部内部类和匿名内部类访问局部变量",charIndex:2664},{level:3,title:"如何选择内部类",slug:"如何选择内部类",normalizedTitle:"如何选择内部类",charIndex:3650},{level:2,title:"利用匿名内部类在静态方法中获取当前类",slug:"利用匿名内部类在静态方法中获取当前类",normalizedTitle:"利用匿名内部类在静态方法中获取当前类",charIndex:3841},{level:2,title:"内部类与顶级类",slug:"内部类与顶级类",normalizedTitle:"内部类与顶级类",charIndex:3957},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:111}],excerpt:'<h2 id="什么是内部类及其分类"><a class="header-anchor" href="#什么是内部类及其分类">#</a> 什么是内部类及其分类</h2>\n<p>顾名思义，定义在某个类内部的其他类，叫做这个类的内部类。</p>\n<p>根据类所处位置以及修饰符可分为以下四类：</p>\n<ul>\n<li>静态内部类</li>\n<li>成员内部类</li>\n<li>局部内部类</li>\n<li>匿名内部类</li>\n</ul>\n',lastUpdated:"2020-12-22",headersStr:"什么是内部类及其分类 内部类的定义 静态内部类 成员内部类 局部内部类 匿名内部类 使用内部类的一些问题 内部类与static 内部类访问外围类的私有属性和方法 外围类访问内部类的私有属性和方法 局部内部类和匿名内部类访问局部变量 如何选择内部类 利用匿名内部类在静态方法中获取当前类 内部类与顶级类 参考",content:'# 什么是内部类及其分类\n顾名思义，定义在某个类内部的其他类，叫做这个类的内部类。\n\n根据类所处位置以及修饰符可分为以下四类：\n\n * 静态内部类\n * 成员内部类\n * 局部内部类\n * 匿名内部类\n\n关于以上名称，不同参考资料中有不同的说法，上面的说法符合《Java核心技术（卷一）（第11版）》（本文继续沿用此种命名），在《Effective Java（第三版）》中，则将所有的内部类称为嵌套类，以及依次命名为：\n\n * 静态成员类\n * 非静态成员类\n * 局部类\n * 匿名类\n\n其中，把除了第一种以外的其他三种类称为内部类。\n\n希望读者在阅读到不同的资料时，能够加以区分。\n\n# 内部类的定义\n# 静态内部类\n具体定义及使用如下代码所示：\n\npublic class Outter {\n  static class Inner {\n      // ... \n  }\n  public static void main(String[] args) {\n    Inner inner = new Outter.Inner();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 成员内部类\n具体定义及使用如下代码所示：\n\npublic class Outter {\n    class Inner {\n        // ... \n    }\n    public static void main(String[] args) {\n        // 必须通过外围类的实例来创建成员内部类的实例\n        Inner inner = new Outter().new Inner();\n    }\n    \n    public void doSomething() {\n        Inner inner = this.new Inner();\n    }\n    \n    public void doSomething(Outter outter) {\n        Inner inner = outter.new Inner();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# 局部内部类\n具体定义及使用如下代码所示：\n\npublic class Outter {\n    public void doSomething() {\n        class Inner {\n           // ... \n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n注意，方法内部类的类声明不能有任何的访问修饰符，因为局部内部类的作用域仅限于其所声明的块中，其作用域与访问修饰符语义不符，所以干脆禁止使用访问修饰符。但是在局部内部类内部，属性和方法是可以加访问修饰符的，但是并不起作用，比如就算声明为private，在块中该类以外的其他位置，也可以直接访问到该属性或方法。\n\n# 匿名内部类\n具体定义及使用如下伪代码所示：\n\npublic class Outter {\n    public void doSomething() {\n        new ClassType(构造器参数)\n        {\n            匿名内部类的属性和方法\n        };\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n可能这语法看起来很陌生，特别是在java8以后，更多的使用lambda表达式。如果去掉“{...}”，那么就和创建普通类实例没有什么区别。\n\n如果ClassType为接口，那么该匿名内部类实现了该接口，如果ClassType为类，那么该匿名内部类继承了该类。注意，构造器参数是提供给父类（如果是接口，保留为空即可）的构造器的。另外，匿名内部类不能有构造器，因为不具有类名称（这也属于Java的设计问题，没必要纠结），但是可以具有初始化块，有一个称作为“双括号初始化”的技巧就是利用的这个原理。\n\n# 使用内部类的一些问题\n# 内部类与static\n在上面四种内部类中，只有静态内部类可以声明静态的属性和方法。严格地说，其他三种内部类，可以声明静态常量（final static），注意必须是常量，同时不能声明静态方法。关于Java为什么会有这样的设计，根据《Java核心技术（第11版 卷一）》提到，这是一种降低复杂性的设计，即没有什么绝对的不可以，完全可以让内部类拥有静态方法，只是设计者认为没必要实现这样的功能。关于更多可以思考一下静态方法和内部类的使用场景。\n\n# 内部类访问外围类的私有属性和方法\n如下列代码所示：\n\npublic class Outter {\n    private static int x;\n    private static void doSomething() {\n        //...\n    }\n    static class Inner {\n        public void doOtherThing() {\n\t\t\tSystem.out.println(x);\n            doSomething();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n上面代码是可以正确执行的，但会发现内部类竟然可以直接访问外围类的私有属性和方法，这是怎么实现的呢？这里我使用了多种反编译器，也使用了《Java核心技术》作者提供的ReflectionTest.java工具类，都未能复现书中所示的类似access$0的方法^1，这里直接引用书中的结论。编译器会在外围类生成一个名称类似为access$0的方法^2，如果访问的属性为实例属性，那么该方法有一个外围类类型的参数，对于静态属性，书中没有给出例子，但是可以猜想是在方法内部直接返回类的静态属性，类似getter方法。这类自动生成的access方法具有包可见性，在一定程度上破坏了类的安全性，因为虽然不能直接在Java代码中调用该方法，但是可以通过修改字节码的形式来实现。\n\n# 外围类访问内部类的私有属性和方法\n有了上一部分的铺垫，可能这一部分就很容易理解。确实，原理都和内部类访问外围类私有属性一致，编译器的实现方式也是在内部类添加类似的access方法。具体可以参看附录中的知乎问答，里面有R大的详细解答。\n\n# 局部内部类和匿名内部类访问局部变量\n由于局部内部类和匿名内部类在这部分的特性一致，所以下面介绍以局部内部类为例。\n\n局部内部类中可以引用块中的局部变量，但这些变量必须是事实最终变量（effectively final），即常量。但请注意，这有一个问题，设想在Inner类中有方法访问了外部的局部变量，但在块中被调用后却推迟执行了（比如使用定时器），那么该方法还能访问到所要访问的变量吗？按照常规逻辑，类中的方法会在退出块后执行，按理说局部变量已不复存在（退栈），事实确实如此，为了程序正常运行，就必须采取相应手段。在Java中，编译器会为局部内部类缓存变量，比如，对于下面的局部内部类定义：\n\npublic void doSomething(Integer x) {\n    class Inner {\n        public void doOtherThing() {\n            System.out.println(x);\n        }\n    }\n    final var inner = new Inner();\n    inner.doOtherThing();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n对生成的内部类文件进行反射，可以发现编译器生成了如下内容:\n\nTest02$1Inner(Outter, Integer);\nfinal java.lang.Integer val$x;\nfinal com.color.harrison.innerclazz.Outter this$0;\n\n\n1\n2\n3\n可见，在创建局部内部类时，就已将外部变量绑定到对象的属性中。\n\n既然缓存变量解决了局部变量与内部类对象的生命周期差异的问题，但所要访问的局部变量为什么还必须都是常量呢？\n\n关于这一点，网上很多博客给出的理由是内部类对象的生命周期差异，但个人认为是为了避免产生行为不一致的问题，如果在内部类内部修改了外部局部变量，但是并不会反映到外部变量上，因为已经复制了。或者是先创建了一个局部内部类对象，然后更改了局部变量的值，再创建一个对象，那么这两个对象访问到的局部变量值就不一致, 在方法中访问同一个局部变量，导致的行为却不一致，而方法的行为不一致，应该体现在方法的参数上（可能这样更优雅）。这属于Java的设计问题了。\n\n# 如何选择内部类\n这一部分主要解释静态内部类和成员内部类在某些使用场合下的区别。《Effective Java（第3版）》第24条中明确指出，如果内部类不需要访问外围类的实例属性或方法，那么就应该采用静态内部类而不应使用成员内部类。如果使用成员内部类，那么每个内部类实例都将拥有一个外围类实例的引用，会导致外围对象在可以被垃圾回收时迟迟不能被回收，可能导致内存泄漏且不易发现。\n\n# 利用匿名内部类在静态方法中获取当前类\n在静态方法中，不能使用this.getClass，那么可以通过匿名内部类来实现。例如：\n\nnew Object(){}.getClass().getEnclosingClass()\n\n\n1\n# 内部类与顶级类\n《Effective Java(第三版)》第25条指出，限制源文件为单个顶级类，如果是在要将多个类放在同一个文件中，建议将其中一个类作为另一个类的静态内部类。因为，在单个源文件内放入多个顶级类，可能因为编译的问题导致程序产生结果的不一致性。下面举一个例子说明该问题：\n\n假设在文件A.java中定义了两个类，如下代码所示:\n\nclass A {\n    static String s= "A";\n}\nclass B {\n    static String s= "B";\n}\n\n\n1\n2\n3\n4\n5\n6\n在同一个包下，创建一个测试类:\n\npublic class Test {\n    public static void main(String[]args) {\n        System.out.println(A.s + B.s);\n    }\n}\n\n\n1\n2\n3\n4\n5\n毫无疑问，结果会输出字符串“AB”。但是在另一个文件B.java中也定义了类A和类B：\n\nclass A {\n    static String s= "A";\n}\nclass B {\n    static String s= "B";\n}\n\n\n1\n2\n3\n4\n5\n6\n使用下列命令编译：\n\njavac Test.java B.java\n\n\n1\n那么编译器会报错，提示定义了多个类A和类B。原因是编译器在编译Test.java时，就先找到了A.java并编译了，然后再编译B，发现类A和类B已经存在了。如果采用下列命令编译：\n\njavac B.java Test.java\n\n\n1\n那么编译成功，运行将会输出字符串“AB”。这就出现了程序的行为将会受源文件的的编译顺序影响，这就是所谓的不确定性。为了避免这种不确定性，所以避免在单个源文件内定义多个顶级类。\n\n# 参考\n * 《Java核心技术（第11版 卷一）》\n * 《Effective Java（第3版）》\n * 知乎问答：为什么内部类的private变量可被外部类直接访问？',normalizedContent:'# 什么是内部类及其分类\n顾名思义，定义在某个类内部的其他类，叫做这个类的内部类。\n\n根据类所处位置以及修饰符可分为以下四类：\n\n * 静态内部类\n * 成员内部类\n * 局部内部类\n * 匿名内部类\n\n关于以上名称，不同参考资料中有不同的说法，上面的说法符合《java核心技术（卷一）（第11版）》（本文继续沿用此种命名），在《effective java（第三版）》中，则将所有的内部类称为嵌套类，以及依次命名为：\n\n * 静态成员类\n * 非静态成员类\n * 局部类\n * 匿名类\n\n其中，把除了第一种以外的其他三种类称为内部类。\n\n希望读者在阅读到不同的资料时，能够加以区分。\n\n# 内部类的定义\n# 静态内部类\n具体定义及使用如下代码所示：\n\npublic class outter {\n  static class inner {\n      // ... \n  }\n  public static void main(string[] args) {\n    inner inner = new outter.inner();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 成员内部类\n具体定义及使用如下代码所示：\n\npublic class outter {\n    class inner {\n        // ... \n    }\n    public static void main(string[] args) {\n        // 必须通过外围类的实例来创建成员内部类的实例\n        inner inner = new outter().new inner();\n    }\n    \n    public void dosomething() {\n        inner inner = this.new inner();\n    }\n    \n    public void dosomething(outter outter) {\n        inner inner = outter.new inner();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# 局部内部类\n具体定义及使用如下代码所示：\n\npublic class outter {\n    public void dosomething() {\n        class inner {\n           // ... \n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n注意，方法内部类的类声明不能有任何的访问修饰符，因为局部内部类的作用域仅限于其所声明的块中，其作用域与访问修饰符语义不符，所以干脆禁止使用访问修饰符。但是在局部内部类内部，属性和方法是可以加访问修饰符的，但是并不起作用，比如就算声明为private，在块中该类以外的其他位置，也可以直接访问到该属性或方法。\n\n# 匿名内部类\n具体定义及使用如下伪代码所示：\n\npublic class outter {\n    public void dosomething() {\n        new classtype(构造器参数)\n        {\n            匿名内部类的属性和方法\n        };\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n可能这语法看起来很陌生，特别是在java8以后，更多的使用lambda表达式。如果去掉“{...}”，那么就和创建普通类实例没有什么区别。\n\n如果classtype为接口，那么该匿名内部类实现了该接口，如果classtype为类，那么该匿名内部类继承了该类。注意，构造器参数是提供给父类（如果是接口，保留为空即可）的构造器的。另外，匿名内部类不能有构造器，因为不具有类名称（这也属于java的设计问题，没必要纠结），但是可以具有初始化块，有一个称作为“双括号初始化”的技巧就是利用的这个原理。\n\n# 使用内部类的一些问题\n# 内部类与static\n在上面四种内部类中，只有静态内部类可以声明静态的属性和方法。严格地说，其他三种内部类，可以声明静态常量（final static），注意必须是常量，同时不能声明静态方法。关于java为什么会有这样的设计，根据《java核心技术（第11版 卷一）》提到，这是一种降低复杂性的设计，即没有什么绝对的不可以，完全可以让内部类拥有静态方法，只是设计者认为没必要实现这样的功能。关于更多可以思考一下静态方法和内部类的使用场景。\n\n# 内部类访问外围类的私有属性和方法\n如下列代码所示：\n\npublic class outter {\n    private static int x;\n    private static void dosomething() {\n        //...\n    }\n    static class inner {\n        public void dootherthing() {\n\t\t\tsystem.out.println(x);\n            dosomething();\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n上面代码是可以正确执行的，但会发现内部类竟然可以直接访问外围类的私有属性和方法，这是怎么实现的呢？这里我使用了多种反编译器，也使用了《java核心技术》作者提供的reflectiontest.java工具类，都未能复现书中所示的类似access$0的方法^1，这里直接引用书中的结论。编译器会在外围类生成一个名称类似为access$0的方法^2，如果访问的属性为实例属性，那么该方法有一个外围类类型的参数，对于静态属性，书中没有给出例子，但是可以猜想是在方法内部直接返回类的静态属性，类似getter方法。这类自动生成的access方法具有包可见性，在一定程度上破坏了类的安全性，因为虽然不能直接在java代码中调用该方法，但是可以通过修改字节码的形式来实现。\n\n# 外围类访问内部类的私有属性和方法\n有了上一部分的铺垫，可能这一部分就很容易理解。确实，原理都和内部类访问外围类私有属性一致，编译器的实现方式也是在内部类添加类似的access方法。具体可以参看附录中的知乎问答，里面有r大的详细解答。\n\n# 局部内部类和匿名内部类访问局部变量\n由于局部内部类和匿名内部类在这部分的特性一致，所以下面介绍以局部内部类为例。\n\n局部内部类中可以引用块中的局部变量，但这些变量必须是事实最终变量（effectively final），即常量。但请注意，这有一个问题，设想在inner类中有方法访问了外部的局部变量，但在块中被调用后却推迟执行了（比如使用定时器），那么该方法还能访问到所要访问的变量吗？按照常规逻辑，类中的方法会在退出块后执行，按理说局部变量已不复存在（退栈），事实确实如此，为了程序正常运行，就必须采取相应手段。在java中，编译器会为局部内部类缓存变量，比如，对于下面的局部内部类定义：\n\npublic void dosomething(integer x) {\n    class inner {\n        public void dootherthing() {\n            system.out.println(x);\n        }\n    }\n    final var inner = new inner();\n    inner.dootherthing();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n对生成的内部类文件进行反射，可以发现编译器生成了如下内容:\n\ntest02$1inner(outter, integer);\nfinal java.lang.integer val$x;\nfinal com.color.harrison.innerclazz.outter this$0;\n\n\n1\n2\n3\n可见，在创建局部内部类时，就已将外部变量绑定到对象的属性中。\n\n既然缓存变量解决了局部变量与内部类对象的生命周期差异的问题，但所要访问的局部变量为什么还必须都是常量呢？\n\n关于这一点，网上很多博客给出的理由是内部类对象的生命周期差异，但个人认为是为了避免产生行为不一致的问题，如果在内部类内部修改了外部局部变量，但是并不会反映到外部变量上，因为已经复制了。或者是先创建了一个局部内部类对象，然后更改了局部变量的值，再创建一个对象，那么这两个对象访问到的局部变量值就不一致, 在方法中访问同一个局部变量，导致的行为却不一致，而方法的行为不一致，应该体现在方法的参数上（可能这样更优雅）。这属于java的设计问题了。\n\n# 如何选择内部类\n这一部分主要解释静态内部类和成员内部类在某些使用场合下的区别。《effective java（第3版）》第24条中明确指出，如果内部类不需要访问外围类的实例属性或方法，那么就应该采用静态内部类而不应使用成员内部类。如果使用成员内部类，那么每个内部类实例都将拥有一个外围类实例的引用，会导致外围对象在可以被垃圾回收时迟迟不能被回收，可能导致内存泄漏且不易发现。\n\n# 利用匿名内部类在静态方法中获取当前类\n在静态方法中，不能使用this.getclass，那么可以通过匿名内部类来实现。例如：\n\nnew object(){}.getclass().getenclosingclass()\n\n\n1\n# 内部类与顶级类\n《effective java(第三版)》第25条指出，限制源文件为单个顶级类，如果是在要将多个类放在同一个文件中，建议将其中一个类作为另一个类的静态内部类。因为，在单个源文件内放入多个顶级类，可能因为编译的问题导致程序产生结果的不一致性。下面举一个例子说明该问题：\n\n假设在文件a.java中定义了两个类，如下代码所示:\n\nclass a {\n    static string s= "a";\n}\nclass b {\n    static string s= "b";\n}\n\n\n1\n2\n3\n4\n5\n6\n在同一个包下，创建一个测试类:\n\npublic class test {\n    public static void main(string[]args) {\n        system.out.println(a.s + b.s);\n    }\n}\n\n\n1\n2\n3\n4\n5\n毫无疑问，结果会输出字符串“ab”。但是在另一个文件b.java中也定义了类a和类b：\n\nclass a {\n    static string s= "a";\n}\nclass b {\n    static string s= "b";\n}\n\n\n1\n2\n3\n4\n5\n6\n使用下列命令编译：\n\njavac test.java b.java\n\n\n1\n那么编译器会报错，提示定义了多个类a和类b。原因是编译器在编译test.java时，就先找到了a.java并编译了，然后再编译b，发现类a和类b已经存在了。如果采用下列命令编译：\n\njavac b.java test.java\n\n\n1\n那么编译成功，运行将会输出字符串“ab”。这就出现了程序的行为将会受源文件的的编译顺序影响，这就是所谓的不确定性。为了避免这种不确定性，所以避免在单个源文件内定义多个顶级类。\n\n# 参考\n * 《java核心技术（第11版 卷一）》\n * 《effective java（第3版）》\n * 知乎问答：为什么内部类的private变量可被外部类直接访问？',charsets:{cjk:!0}},{title:"Java中的代理",frontmatter:{title:"Java中的代理",categories:["编程语言"],tags:["Java"],date:"2020-12-22T13:07:29.000Z",permalink:"/pages/6cec3e/"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/01.%E5%9F%BA%E7%A1%80/04.Java%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%90%86.html",relativePath:"01.编程语言/01.Java/01.基础/04.Java中的代理.md",key:"v-0d3e36b3",path:"/pages/6cec3e/",headers:[{level:2,title:"静态代理",slug:"静态代理",normalizedTitle:"静态代理",charIndex:86},{level:2,title:"JDK动态代理",slug:"jdk动态代理",normalizedTitle:"jdk动态代理",charIndex:91},{level:2,title:"CGLIB动态代理",slug:"cglib动态代理",normalizedTitle:"cglib动态代理",charIndex:5472},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:6646}],excerpt:"<p>代理是一种设计模式，旨在控制对目标对象的访问。在某些无法直接访问目标对象，或者是对目标对象进行功能扩展的时候，就可以使用代理模式。代理模式的实现有很多中，在Java中，包括静态代理，JDK动态代理和CGLIB代理。</p>\n",lastUpdated:"2021-01-11",headersStr:"静态代理 JDK动态代理 CGLIB动态代理 总结",content:'代理是一种设计模式，旨在控制对目标对象的访问。在某些无法直接访问目标对象，或者是对目标对象进行功能扩展的时候，就可以使用代理模式。代理模式的实现有很多中，在Java中，包括静态代理，JDK动态代理和CGLIB代理。\n\n# 静态代理\n静态代理是通过在代理类中单向关联目标类来实现的。下面通过一个例子来演示。\n\n先定义一个名为HotelServe的接口，表示酒店服务，然后定义一个名为Waiter的实现类。\n\npublic interface HotelServe {\n  void serve();\n}\n\npublic class Waiter implements HotelServe{\n  @Override\n  public void serve() {\n    System.out.println("服务客人...");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n平时，服务员的工作就是在酒店服务客人，但是现在有一位重要客人，需要到机场去接送客人，现在定义一个服务员的代理类，来完成该工作。\n\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\n\n@Data\n@AllArgsConstructor\npublic class WaiterStaticProxy implements HotelServe{\n  private Waiter waiter;\n\n  @Override\n  public void serve() {\n    System.out.println("到机场接送客人");\n    waiter.serve();\n    System.out.println("送客人到机场");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n这样就实现了对Waiter对象的静态代理，在代理类中有一个目标类的属性，通过这种单向依赖关系来实现代理。\n\n上面这个例子很简单，主要说明了怎么实现静态代理。代理类实现简单，但是仅适用于目标类确定的情况下；而且当目标类增多时，代理类也会增多，接口添加方法时，实现类也需要更改。\n\n# JDK动态代理\n将上面的例子改为使用JDK动态代理的方式，代码如下：\n\n@AllArgsConstructor\npublic class WaiterJdkDynamicProxy implements InvocationHandler {\n\n    private final Object target;\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println("到机场接送客人");\n        Object obj = method.invoke(target, args);\n        System.out.println("送客人到机场");\n        return obj;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n测试代码：\n\npublic static void main(String[] args) {\n    final WaiterJdkDynamicProxy handler = new WaiterJdkDynamicProxy(new Waiter());\n    final HotelServe waiterProxy =(HotelServe)Proxy.newProxyInstance(Waiter.class.getClassLoader(),\n                                                                     Waiter.class.getInterfaces(), handler);\n    waiterProxy.serve();\n}\n\n\n1\n2\n3\n4\n5\n6\n上面代码演示的是使用JDK动态代理的基本过程，即创建一个实现了java.lang.reflect.InvocationHandler的类来充当目标类的方法调用处理器，通过java.lang.reflect.Proxy的静态方法newProxyInstance来创建代理对象，需要传入类加载器，所要实现的接口，以及前面所说的方法调用处理器。\n\n可能对上述过程不是很好理解，其实上述代码的入口就是Proxy.newProxyInstance，该方法内部经过一系列的处理，最终为我们创建代理类，然后再创建并返回代理类对象。通过设置虚拟机参数-Djdk.proxy.ProxyGenerator.saveGeneratedFiles=true就可以保存创建的代理类的class文件。\n\n//\n// Source code recreated from a .class file by IntelliJ IDEA\n// (powered by FernFlower decompiler)\n//\n\npackage com.sun.proxy;\n\nimport com.color.se.proxy.HotelServe;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\nimport java.lang.reflect.UndeclaredThrowableException;\n\npublic final class $Proxy0 extends Proxy implements HotelServe {\n    private static Method m1;\n    private static Method m3;\n    private static Method m2;\n    private static Method m0;\n\n    public $Proxy0(InvocationHandler var1) throws  {\n        super(var1);\n    }\n\n    public final boolean equals(Object var1) throws  {\n        try {\n            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});\n        } catch (RuntimeException | Error var3) {\n            throw var3;\n        } catch (Throwable var4) {\n            throw new UndeclaredThrowableException(var4);\n        }\n    }\n\n    public final void serve() throws  {\n        try {\n            super.h.invoke(this, m3, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    public final String toString() throws  {\n        try {\n            return (String)super.h.invoke(this, m2, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    public final int hashCode() throws  {\n        try {\n            return (Integer)super.h.invoke(this, m0, (Object[])null);\n        } catch (RuntimeException | Error var2) {\n            throw var2;\n        } catch (Throwable var3) {\n            throw new UndeclaredThrowableException(var3);\n        }\n    }\n\n    static {\n        try {\n            m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object"));\n            m3 = Class.forName("com.color.se.proxy.HotelServe").getMethod("serve");\n            m2 = Class.forName("java.lang.Object").getMethod("toString");\n            m0 = Class.forName("java.lang.Object").getMethod("hashCode");\n        } catch (NoSuchMethodException var2) {\n            throw new NoSuchMethodError(var2.getMessage());\n        } catch (ClassNotFoundException var3) {\n            throw new NoClassDefFoundError(var3.getMessage());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n可以发现，代理类的类名为$ProxyXXX，其中XXX为代理类的编号。另外，代理类继承了Proxy类，实现了我们所传入的接口，并对该接口中的方法进行代理（另外还包括Object类中的几个方法）。在这些方法中，主要搞清楚super.h是什么。super.h是父类Proxy中定义的InvocationHandler类型的实例属性， 而当前代理类又是 Proxy类的实例，也就是说每一个代理类都关联了一个方法调用处理器，而该类中的每一个方法，都会通过该方法调用处理器来进行调用，所以我们创建代理类对象时需要传入一个handler，该参数在创建代理类对象时会被设置为该对象中super.h所指代的属性。\n\nInvocationHandler中有一个invoke方法，该方法就是控制目标类的方法调用，如上例中，对目标类的方法进行了前后增强。该方法有三个参数，第一个是代理类对象，一般很少使用；第二个就是通过代理类调用的方法，利用反射，调用目标类中的方法；第三个参数就是方法调用的实参。invoke方法就像是中间层，隔绝代理类和目标类，而代理类与中间层的关系是由JVM来实现的，而中间层与目标类的关系是由开发者来实现的。\n\nJDK动态代理避免了使用静态代理所需要的代理类的手动创建，从而带来的好处时，当接口中的方法增加时，我们不用修改代理类。但是，很明显，JDK动态代理只能实现接口方式的代理，而不能实现继承方式的代理，原因是所生成的代理类中已经继承了Proxy类了，而Java不允许多继承。\n\n注意\n\n代理类与目标类在类层次上面并无关系，千万不能用目标类型去接收代理类对象，否则会出现ClassCastException。\n\n# CGLIB动态代理\n为了解决JDK动态代理存在的问题，可以使用CGLIB动态代理，该方法采用底层字节码技术，可以为一个类创建子类，在子类中拦截所有父类方法的调用。\n\n同样地，使用cglib来实现上面的例子（首先要引入cglib的包，这一步省略）：\n\npublic class WaiterCglibProxy implements MethodInterceptor {\n\n    private final Enhancer enhancer = new Enhancer();\n\n    public Object getProxy(Class<?> clazz) {\n        enhancer.setSuperclass(clazz); // 设置代理类的父类\n        enhancer.setCallback(this); \n        return enhancer.create(); // 创建代理类实例\n    }\n\n    @Override\n    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n        System.out.println("cglib: 到机场接送客人");\n        final Object result = methodProxy.invokeSuper(o, objects);\n        System.out.println("cglib: 送客人到机场");\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n测试代码：\n\npublic static void main(String[] args) {\n    final WaiterCglibProxy waiterCglibProxy = new WaiterCglibProxy();\n    final Waiter proxy = (Waiter) waiterCglibProxy.getProxy(Waiter.class);\n    proxy.serve();\n}\n\n\n1\n2\n3\n4\n5\n通过Enhancer类设置所要生成的代理类的一些信息，然后创建代理类的实例，由于代理类继承了目标类，所以可以用目标类类型来接收代理类实例。MethodInterceptor类似中间层，通过实现该接口，重写intercept来实现方法代理。代理类实例中的方法会被intercept拦截，从而实现方法的代理。\n\n# 总结\n不管是JDK动态代理还是CGLIB动态代理，都存在下面几点缺陷：\n\n * 对所有方法进行了代理，大多数时候我们只希望对部分方法进行代理。\n * 只能在目标类业务方法的开始和结束织入代码。\n * 代理类与单个目标类相关联，所编写的代理逻辑无法做到通用。',normalizedContent:'代理是一种设计模式，旨在控制对目标对象的访问。在某些无法直接访问目标对象，或者是对目标对象进行功能扩展的时候，就可以使用代理模式。代理模式的实现有很多中，在java中，包括静态代理，jdk动态代理和cglib代理。\n\n# 静态代理\n静态代理是通过在代理类中单向关联目标类来实现的。下面通过一个例子来演示。\n\n先定义一个名为hotelserve的接口，表示酒店服务，然后定义一个名为waiter的实现类。\n\npublic interface hotelserve {\n  void serve();\n}\n\npublic class waiter implements hotelserve{\n  @override\n  public void serve() {\n    system.out.println("服务客人...");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n平时，服务员的工作就是在酒店服务客人，但是现在有一位重要客人，需要到机场去接送客人，现在定义一个服务员的代理类，来完成该工作。\n\nimport lombok.allargsconstructor;\nimport lombok.data;\n\n@data\n@allargsconstructor\npublic class waiterstaticproxy implements hotelserve{\n  private waiter waiter;\n\n  @override\n  public void serve() {\n    system.out.println("到机场接送客人");\n    waiter.serve();\n    system.out.println("送客人到机场");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n这样就实现了对waiter对象的静态代理，在代理类中有一个目标类的属性，通过这种单向依赖关系来实现代理。\n\n上面这个例子很简单，主要说明了怎么实现静态代理。代理类实现简单，但是仅适用于目标类确定的情况下；而且当目标类增多时，代理类也会增多，接口添加方法时，实现类也需要更改。\n\n# jdk动态代理\n将上面的例子改为使用jdk动态代理的方式，代码如下：\n\n@allargsconstructor\npublic class waiterjdkdynamicproxy implements invocationhandler {\n\n    private final object target;\n\n    @override\n    public object invoke(object proxy, method method, object[] args) throws throwable {\n        system.out.println("到机场接送客人");\n        object obj = method.invoke(target, args);\n        system.out.println("送客人到机场");\n        return obj;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n测试代码：\n\npublic static void main(string[] args) {\n    final waiterjdkdynamicproxy handler = new waiterjdkdynamicproxy(new waiter());\n    final hotelserve waiterproxy =(hotelserve)proxy.newproxyinstance(waiter.class.getclassloader(),\n                                                                     waiter.class.getinterfaces(), handler);\n    waiterproxy.serve();\n}\n\n\n1\n2\n3\n4\n5\n6\n上面代码演示的是使用jdk动态代理的基本过程，即创建一个实现了java.lang.reflect.invocationhandler的类来充当目标类的方法调用处理器，通过java.lang.reflect.proxy的静态方法newproxyinstance来创建代理对象，需要传入类加载器，所要实现的接口，以及前面所说的方法调用处理器。\n\n可能对上述过程不是很好理解，其实上述代码的入口就是proxy.newproxyinstance，该方法内部经过一系列的处理，最终为我们创建代理类，然后再创建并返回代理类对象。通过设置虚拟机参数-djdk.proxy.proxygenerator.savegeneratedfiles=true就可以保存创建的代理类的class文件。\n\n//\n// source code recreated from a .class file by intellij idea\n// (powered by fernflower decompiler)\n//\n\npackage com.sun.proxy;\n\nimport com.color.se.proxy.hotelserve;\nimport java.lang.reflect.invocationhandler;\nimport java.lang.reflect.method;\nimport java.lang.reflect.proxy;\nimport java.lang.reflect.undeclaredthrowableexception;\n\npublic final class $proxy0 extends proxy implements hotelserve {\n    private static method m1;\n    private static method m3;\n    private static method m2;\n    private static method m0;\n\n    public $proxy0(invocationhandler var1) throws  {\n        super(var1);\n    }\n\n    public final boolean equals(object var1) throws  {\n        try {\n            return (boolean)super.h.invoke(this, m1, new object[]{var1});\n        } catch (runtimeexception | error var3) {\n            throw var3;\n        } catch (throwable var4) {\n            throw new undeclaredthrowableexception(var4);\n        }\n    }\n\n    public final void serve() throws  {\n        try {\n            super.h.invoke(this, m3, (object[])null);\n        } catch (runtimeexception | error var2) {\n            throw var2;\n        } catch (throwable var3) {\n            throw new undeclaredthrowableexception(var3);\n        }\n    }\n\n    public final string tostring() throws  {\n        try {\n            return (string)super.h.invoke(this, m2, (object[])null);\n        } catch (runtimeexception | error var2) {\n            throw var2;\n        } catch (throwable var3) {\n            throw new undeclaredthrowableexception(var3);\n        }\n    }\n\n    public final int hashcode() throws  {\n        try {\n            return (integer)super.h.invoke(this, m0, (object[])null);\n        } catch (runtimeexception | error var2) {\n            throw var2;\n        } catch (throwable var3) {\n            throw new undeclaredthrowableexception(var3);\n        }\n    }\n\n    static {\n        try {\n            m1 = class.forname("java.lang.object").getmethod("equals", class.forname("java.lang.object"));\n            m3 = class.forname("com.color.se.proxy.hotelserve").getmethod("serve");\n            m2 = class.forname("java.lang.object").getmethod("tostring");\n            m0 = class.forname("java.lang.object").getmethod("hashcode");\n        } catch (nosuchmethodexception var2) {\n            throw new nosuchmethoderror(var2.getmessage());\n        } catch (classnotfoundexception var3) {\n            throw new noclassdeffounderror(var3.getmessage());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n可以发现，代理类的类名为$proxyxxx，其中xxx为代理类的编号。另外，代理类继承了proxy类，实现了我们所传入的接口，并对该接口中的方法进行代理（另外还包括object类中的几个方法）。在这些方法中，主要搞清楚super.h是什么。super.h是父类proxy中定义的invocationhandler类型的实例属性， 而当前代理类又是 proxy类的实例，也就是说每一个代理类都关联了一个方法调用处理器，而该类中的每一个方法，都会通过该方法调用处理器来进行调用，所以我们创建代理类对象时需要传入一个handler，该参数在创建代理类对象时会被设置为该对象中super.h所指代的属性。\n\ninvocationhandler中有一个invoke方法，该方法就是控制目标类的方法调用，如上例中，对目标类的方法进行了前后增强。该方法有三个参数，第一个是代理类对象，一般很少使用；第二个就是通过代理类调用的方法，利用反射，调用目标类中的方法；第三个参数就是方法调用的实参。invoke方法就像是中间层，隔绝代理类和目标类，而代理类与中间层的关系是由jvm来实现的，而中间层与目标类的关系是由开发者来实现的。\n\njdk动态代理避免了使用静态代理所需要的代理类的手动创建，从而带来的好处时，当接口中的方法增加时，我们不用修改代理类。但是，很明显，jdk动态代理只能实现接口方式的代理，而不能实现继承方式的代理，原因是所生成的代理类中已经继承了proxy类了，而java不允许多继承。\n\n注意\n\n代理类与目标类在类层次上面并无关系，千万不能用目标类型去接收代理类对象，否则会出现classcastexception。\n\n# cglib动态代理\n为了解决jdk动态代理存在的问题，可以使用cglib动态代理，该方法采用底层字节码技术，可以为一个类创建子类，在子类中拦截所有父类方法的调用。\n\n同样地，使用cglib来实现上面的例子（首先要引入cglib的包，这一步省略）：\n\npublic class waitercglibproxy implements methodinterceptor {\n\n    private final enhancer enhancer = new enhancer();\n\n    public object getproxy(class<?> clazz) {\n        enhancer.setsuperclass(clazz); // 设置代理类的父类\n        enhancer.setcallback(this); \n        return enhancer.create(); // 创建代理类实例\n    }\n\n    @override\n    public object intercept(object o, method method, object[] objects, methodproxy methodproxy) throws throwable {\n        system.out.println("cglib: 到机场接送客人");\n        final object result = methodproxy.invokesuper(o, objects);\n        system.out.println("cglib: 送客人到机场");\n        return result;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n测试代码：\n\npublic static void main(string[] args) {\n    final waitercglibproxy waitercglibproxy = new waitercglibproxy();\n    final waiter proxy = (waiter) waitercglibproxy.getproxy(waiter.class);\n    proxy.serve();\n}\n\n\n1\n2\n3\n4\n5\n通过enhancer类设置所要生成的代理类的一些信息，然后创建代理类的实例，由于代理类继承了目标类，所以可以用目标类类型来接收代理类实例。methodinterceptor类似中间层，通过实现该接口，重写intercept来实现方法代理。代理类实例中的方法会被intercept拦截，从而实现方法的代理。\n\n# 总结\n不管是jdk动态代理还是cglib动态代理，都存在下面几点缺陷：\n\n * 对所有方法进行了代理，大多数时候我们只希望对部分方法进行代理。\n * 只能在目标类业务方法的开始和结束织入代码。\n * 代理类与单个目标类相关联，所编写的代理逻辑无法做到通用。',charsets:{cjk:!0}},{title:"Java中的日志体系概述",frontmatter:{title:"Java中的日志体系概述",categories:["编程语言"],tags:["Java"],date:"2021-01-11T15:36:25.000Z",permalink:"/pages/95a02e/"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/01.%E5%9F%BA%E7%A1%80/05.Java%E4%B8%AD%E7%9A%84%E6%97%A5%E5%BF%97%E4%BD%93%E7%B3%BB.html",relativePath:"01.编程语言/01.Java/01.基础/05.Java中的日志体系.md",key:"v-19c72b85",path:"/pages/95a02e/",excerpt:"<p>日志在项目的运行中的重要性不言而喻，但是Java中的日志框架众多，比如Log4j，Logback，JUL等，不同的应用框架和工具包也可能使用不同的日志框架，如果使用不当，很可能导致日志模块十分凌乱，所以很有必要搞清楚Java中的日志体系。</p>\n",lastUpdated:"2021-01-11",headersStr:null,content:"日志在项目的运行中的重要性不言而喻，但是Java中的日志框架众多，比如Log4j，Logback，JUL等，不同的应用框架和工具包也可能使用不同的日志框架，如果使用不当，很可能导致日志模块十分凌乱，所以很有必要搞清楚Java中的日志体系。\n\nJava中的日志体系分为两部分，日志接口和日志实现，前者提供了统一的日志操作规范，后者提供了具体的日志输出实现。目前日志接口有两大阵营，Commons Logging和Slf4J。Commons Logging出自Apache，之前叫Jakarta Commons Logging（简称JCL）。\n\n日志接口需要结合具体的日志实现框架使用，如果项目中使用JCL作为日志接口，则需要在项目的classpath下新增一个commons-logging.properties文件，通过该文件指定具体的日志实现，比如：\n\norg.apache.commons.logging.Log=org.apache.commons.logging.impl.Jdk14Logger\n\n\n1\n如果需要改变日志实现，只需要改变上述文件中的配置。\n\n具体的日志实现有下面几种：\n\n * Log4J\n * Log4J2：Apache推出的Log4J的升级版。\n * JUL（Java Util Logging）：JDK1.4以后提供的日志实现。\n * Logback：属于Slf4J阵营，SpringBoot 2.0以后默认使用该日志实现框架。\n\nLogback完全实现了Slf4J接口，相比其他框架具有性能更优，功能更丰富的特点。\n\n另外关于slf4j，有许多相关的日志适配器和桥接器：\n\n * Slf4J适配器实现了Slf4J的接口，然后调用其他框架来输出日志，比如slf4j-log4j12就是针对Log4J的适配器，slf4j-jdk14是针对JCL的的适配器。\n   \n   \n * Slf4J桥接器是指将对没有实现Slf4J接口的日志框架（如log4j）的调用转换为对实现了slf4j的日志框架（如Logback）的调用。对于已存在使用了其他日志框架的项目，如果底层想使用实现了slf4j的日志框架又不想修改代码，那么就可以利用桥接器。常见的桥接器jar包名称有：jcl-over-slf4j，log4j-over-slf4j。\n   \n   \n\n适配器和桥接器的区别就是，适配器是将代码中的slf4j转换为非slf4j实现，桥接器是将代码中的已有的非slf4j转换为slf4j实现，两者的作用刚好相反。另外必须注意不能同时使用桥接器和适配器，否则会出现死循环，因为两者的功能刚好相反，会导致互相转换。\n\n关于slf4j以及各种日志实现，适配器和桥接器的关系如下图所示：\n\n\n\n目前使用较多的是slf4j+logback组合，具体使用细节请参考各自的官网。\n\n * SLF4J\n * Logback",normalizedContent:"日志在项目的运行中的重要性不言而喻，但是java中的日志框架众多，比如log4j，logback，jul等，不同的应用框架和工具包也可能使用不同的日志框架，如果使用不当，很可能导致日志模块十分凌乱，所以很有必要搞清楚java中的日志体系。\n\njava中的日志体系分为两部分，日志接口和日志实现，前者提供了统一的日志操作规范，后者提供了具体的日志输出实现。目前日志接口有两大阵营，commons logging和slf4j。commons logging出自apache，之前叫jakarta commons logging（简称jcl）。\n\n日志接口需要结合具体的日志实现框架使用，如果项目中使用jcl作为日志接口，则需要在项目的classpath下新增一个commons-logging.properties文件，通过该文件指定具体的日志实现，比如：\n\norg.apache.commons.logging.log=org.apache.commons.logging.impl.jdk14logger\n\n\n1\n如果需要改变日志实现，只需要改变上述文件中的配置。\n\n具体的日志实现有下面几种：\n\n * log4j\n * log4j2：apache推出的log4j的升级版。\n * jul（java util logging）：jdk1.4以后提供的日志实现。\n * logback：属于slf4j阵营，springboot 2.0以后默认使用该日志实现框架。\n\nlogback完全实现了slf4j接口，相比其他框架具有性能更优，功能更丰富的特点。\n\n另外关于slf4j，有许多相关的日志适配器和桥接器：\n\n * slf4j适配器实现了slf4j的接口，然后调用其他框架来输出日志，比如slf4j-log4j12就是针对log4j的适配器，slf4j-jdk14是针对jcl的的适配器。\n   \n   \n * slf4j桥接器是指将对没有实现slf4j接口的日志框架（如log4j）的调用转换为对实现了slf4j的日志框架（如logback）的调用。对于已存在使用了其他日志框架的项目，如果底层想使用实现了slf4j的日志框架又不想修改代码，那么就可以利用桥接器。常见的桥接器jar包名称有：jcl-over-slf4j，log4j-over-slf4j。\n   \n   \n\n适配器和桥接器的区别就是，适配器是将代码中的slf4j转换为非slf4j实现，桥接器是将代码中的已有的非slf4j转换为slf4j实现，两者的作用刚好相反。另外必须注意不能同时使用桥接器和适配器，否则会出现死循环，因为两者的功能刚好相反，会导致互相转换。\n\n关于slf4j以及各种日志实现，适配器和桥接器的关系如下图所示：\n\n\n\n目前使用较多的是slf4j+logback组合，具体使用细节请参考各自的官网。\n\n * slf4j\n * logback",charsets:{cjk:!0}},{title:"Java8新日期API",frontmatter:{title:"Java8新日期API",categories:["编程语言"],tags:["Java"],date:"2021-01-17T17:32:02.000Z",permalink:"/pages/b725c0/"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/01.%E5%9F%BA%E7%A1%80/06.Java8%E6%96%B0%E6%97%A5%E6%9C%9FAPI.html",relativePath:"01.编程语言/01.Java/01.基础/06.Java8新日期API.md",key:"v-6b4adb51",path:"/pages/b725c0/",headers:[{level:2,title:"java.time包结构",slug:"java-time包结构",normalizedTitle:"java.time包结构",charIndex:256},{level:2,title:"日期/时间类",slug:"日期-时间类",normalizedTitle:"日期/时间类",charIndex:795},{level:3,title:"LocalDate",slug:"localdate",normalizedTitle:"localdate",charIndex:308},{level:3,title:"LocalTime",slug:"localtime",normalizedTitle:"localtime",charIndex:319},{level:2,title:"时间点和时间间隔",slug:"时间点和时间间隔",normalizedTitle:"时间点和时间间隔",charIndex:2721},{level:3,title:"Instant",slug:"instant",normalizedTitle:"instant",charIndex:345},{level:3,title:"Duration",slug:"duration",normalizedTitle:"duration",charIndex:354},{level:3,title:"Period",slug:"period",normalizedTitle:"period",charIndex:363},{level:2,title:"操纵日期/时间对象",slug:"操纵日期-时间对象",normalizedTitle:"操纵日期/时间对象",charIndex:3821},{level:2,title:"格式化和解析",slug:"格式化和解析",normalizedTitle:"格式化和解析",charIndex:4821},{level:2,title:"时区和历法",slug:"时区和历法",normalizedTitle:"时区和历法",charIndex:6074}],excerpt:"<p>在Java 1.0中，Java只提供了java.util.Date类来处理日期和时间，但是该类只能以毫秒的精度表示时间。更糟糕的是其易用性，比如年份的起始为1900年，月份的起始从0开始。在Java 1.1中，Date类中很多方法被废弃了，取而代之的是java.util.Calendar类，但是该类仍然有类似的问题和设计缺陷。关于Date和Calendar类，到底该使用哪一个？而有些特性又只在一个类中存在，比如DateFormat方法就只在Date类里有，同时DateFormat也有线程安全的问题。</p>\n",lastUpdated:"2021-01-17",headersStr:"java.time包结构 日期/时间类 LocalDate LocalTime 时间点和时间间隔 Instant Duration Period 操纵日期/时间对象 格式化和解析 时区和历法",content:'在Java 1.0中，Java只提供了java.util.Date类来处理日期和时间，但是该类只能以毫秒的精度表示时间。更糟糕的是其易用性，比如年份的起始为1900年，月份的起始从0开始。在Java 1.1中，Date类中很多方法被废弃了，取而代之的是java.util.Calendar类，但是该类仍然有类似的问题和设计缺陷。关于Date和Calendar类，到底该使用哪一个？而有些特性又只在一个类中存在，比如DateFormat方法就只在Date类里有，同时DateFormat也有线程安全的问题。\n\n# java.time包结构\n为了解决上述问题，Java 8引入了java.time包，包含了很多新的类，如LocalDate, LocalTime, LocalDateTime, Instant, Duration和Period等，除此之外，还有几个子包，分别是：\n\n * java.time.chrono：此包提供历法相关的接口与实现。Java中默认使用的历法是ISO 8086日历系统，也就是我们常说的公历。此外还提供了几种其他历法，泰国佛教历，民国历，日本历和伊斯兰历。每种历法API分为三部分：XXXEra，XXXChronology和XXXDate。\n * java.time.format：此包提供了日期格式化的方法。format包中定义了时区名称，日期解析和格式化的各种枚举。此包中的类都是final的，都提供了线程安全的访问。\n * java.time.temporal：此包中定义了整个日期时间框架的基础，各种时间单位，时间调节器等。Java 8中日期时间类都是实现了temporal包中的事件单位（Temporal），时间调节器（TemporalAdjuster）和各种属性的接口。\n * java.time.zone：此包定义了时区转换的规则和方法。\n\n# 日期/时间类\nLocalDate表示日期，LocalTime表示时间，LocalDateTime表示使日期和时间的合体。LocalDateTime中大部分关于日期的操作都与LocalDate类似，关于时间的操作都与LocalTime类似。\n\n# LocalDate\n# 获取LocalDate实例\n可以通过静态工厂方法of()来创建一个LocalDate实例。\n\n/* 注意，如果各项参数无效的话，会抛出异常 */\nLocalDate day = LocalDate.of(2016, 9, 9); // 参数是int型的\n\n\n1\n2\n也可以通过方法now()来创建一个表示当前日期的LocalDate实例。\n\nLocalDate now = LocalDate.now();\n// 此外，还有几个与时区有关的实现\n\n\n1\n2\n由于LocalDate实例是不可变化的，所以对LocalDate实例的修改会产生一个新的实例。\n\n# 获取LocalDate实例属性\nLocalDate day = LocalDate.of(2016, 9, 9);\n\nfinal int year = day.getYear();\n\nfinal Month month = day.getMonth();\nfinal int monthValue = day.getMonthValue(); // 当前月中的第几天\n\nfinal int dayOfMonth = day.getDayOfMonth(); // 当前月中的第几天\nfinal DayOfWeek dayOfWeek = day.getDayOfWeek(); // 当前周中的第几天，从1开始，返回类型为DayOfWeek枚举\nfinal int dayOfYear = day.getDayOfYear(); // 当前年份内的第几天，从1到365或366（闰年）\n\nfinal int lengthOfYear = day.lengthOfYear();\nfinal int lengthOfMonth = day.lengthOfMonth();\n\nfinal boolean leapYear = day.isLeapYear(); // 是否是闰年\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 其他操作\n可以在LocalDate实例的基础上得到LocalDateTime实例：\n\nLocalDateTime localDateTime =  LocalDate.now().atTime(19, 12, 11, 1000092);\n\n\n1\n关于LocalDate的常用操作就是这些。\n\n# LocalTime\n# 获取LocalTime实例\n可以通过of()工厂方法来获取表示指定时间的LocalTime实例：\n\n/*\n下来三个属性依次表示时（0~23），分（0~59），秒（0~59），括号里面表示有效值\n如果参数不合法，将会产生DateTimeException\n*/\nLocalTime time = LocalTime.of(23, 59, 59);\n\n\n1\n2\n3\n4\n5\n也可以通过now()方法来获取一个表示当前时间的LocalTime实例：\n\nLocalTime now = LocalTime.now();\n\n\n1\n由于LocalTime实例是不可变化的，所以修改其实例会产生一个新的实例。\n\n# 获取LocalTime属性\nfinal int hour = time.getHour();\nfinal int minute = time.getMinute();\nfinal int second = time.getSecond();\nfinal int nano = time.getNano(); // 返回纳秒\n\n\n1\n2\n3\n4\n笔记\n\n这里补充一下秒的单位及其换算关系：\n\n111秒 = 10310^3103毫秒（millisecond） = 10610^6106微秒（microsecond） = 10910^9109纳秒 （nanosecond）= 101210^{12}1012皮秒（picosecond） = 101510^{15}1015飞秒（femtosecond）\n\n# 其他操作\n可以将LocalTime实例的基础上得到LocalDateTime实例：\n\nLocalDateTime localDateTime = LocalTime.now().atDate(LocalDate.now());\n\n\n1\n# 时间点和时间间隔\n时间点是时间线上的一个点，表示一个时间戳。时间间隔表示两个时间点之间的间隔。Instant表示时间点，Duration和Period表示时间间隔。\n\n# Instant\nInstant表示一个时间点，或时间戳，可以精确到纳秒。\n\n# 获取Instant实例\n可以通过工厂方法now()来获取时间点对象：\n\nInstant now = Instant.now();\n\n\n1\n所有对Instant实例的修改都不会修改源对象，而是返回一个新的对象。\n\n可以对Instant实例执行plusXXX，minusXXX操作：\n\nplusSeconds(); minusSeconds();\nplusMillis(); minusMillis();\nplusNanos(); minusNanos();\n\n\n1\n2\n3\n也可以直接使用plus()或者是minus()方法：\n\n/* TemporalUnit保存了单位，如果指定了其他不支持的单位的话，会抛出UnsupportedTemporalTypeException异常。*/\nplus(long amountToAdd, TemporalUnit unit);\nInstant minus(long amountToSubtract, TemporalUnit unit);\n\n\n1\n2\n3\n# Duration\nDuration表示时间间隔，可以从两个时间点对象获取到时间间隔。可以通过工厂方法between()来获取Duration实例：\n\n// Duration between(Temporal startInclusive, Temporal endExclusive);\nfinal LocalDateTime now = LocalDateTime.now();\nfinal LocalDateTime past = now.minus(2, ChronoUnit.YEARS);\nDuraton duration = Duration.between(past,now);\n\n\n1\n2\n3\n4\n另外还可以通过of()来创建，该方法接受一个时间段长度和一个时间单位作为参数：\n\nDuration duration = Duration.of(100, ChronoUnit.DAYS);\n\n\n1\n# Period\nPeriod和Duration类似，但Period包含年份，月份和日期，而Duration只包含秒，毫秒，纳秒。Period和Duraton的很多方法都很类似，这里就不再赘述了，更多细节请参考官方DOC。\n\n# 操纵日期/时间对象\n可以通过withXXX，plusXXX，minusXXX方法修改日期/时间对象的某些属性，也可以采用通用的with()，plus()，minus()方法来获取源对象经过修改后的对象。这些通用方法需要指定一个单位来取代XXX，对于plus()和minus()，该单位的类型是TemporalUnit，该接口有一个枚举实现：ChronoUnit，可以很方便地指定单位。对于with()，需要指定一个TemporalField类型的参数，可以使用接口的枚举实现ChronoField。\n\n笔记\n\nChronoUnit实现TemporalUnit，而ChronoField实现TemporalField。XXXUnit表示时间单位，如年月日时分秒等；而XXXField表示某个具体的时间的属性，如MONTH_OF_YEAR。前者仅仅是单位而已，而可以通过后者表示的属性从时间中取出属性值。\n\n上述操纵方式都是比较简单和直接的，对于复杂操作可以使用调节器（TemporalAdjuster），工具类TemporalAdjusters中定义了很多调节器。这个调节器类似比较器一样，是策略模式的体系。\n\nwith方法接受一个调节器，如获取下一个工作日的日期：\n\nfinal LocalDate now = LocalDate.of(2021, 1,16); // Friday\nfinal TemporalAdjuster adjuster = TemporalAdjusters.ofDateAdjuster((temporal) -> {\n    int addDays = 1;\n    if (now.getDayOfWeek() == DayOfWeek.FRIDAY) addDays = 3;\n    else if (now.getDayOfWeek() == DayOfWeek.SATURDAY) addDays = 2;\n    return temporal.plus(addDays, ChronoUnit.DAYS);\n});\nfinal LocalDate nextWorkDay = now.with(adjuster);\nSystem.out.println(nextWorkDay); // 2020-01-18\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 格式化和解析\nDateTimeFormatter类中以及预定了很多格式的格式化器：\n\n * BASIC_ISO_DATE：20210107\n * ISO_DATE_TIME：2021-01-17T15:33:33.5644861\n * ISO_DATE：2021-01-17\n * ...\n\n也可以通过ofPattern()工厂方法创建一个格式化器：\n\nfinal LocalDateTime now = LocalDateTime.now();\nfinal DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");\nSystem.out.println(formatter.format(now)); // 2021/01/17 15:37:38\n\n\n1\n2\n3\n以及通过DataTimeFormatterBuilder来构建格式化器：\n\nfinal LocalDateTime now = LocalDateTime.now();\nfinal DateTimeFormatter formatter = new DateTimeFormatterBuilder()\n    .appendText(ChronoField.YEAR)\n    .appendLiteral("-")\n    .appendText(ChronoField.MONTH_OF_YEAR)\n    .appendLiteral("-")\n    .appendText(ChronoField.DAY_OF_MONTH)\n    .appendLiteral(\' \')\n    .appendText(ChronoField.HOUR_OF_DAY)\n    .appendLiteral("/")\n    .appendText(ChronoField.MINUTE_OF_HOUR)\n    .appendLiteral("/")\n    .appendText(ChronoField.SECOND_OF_MINUTE).toFormatter();\nSystem.out.println(formatter.format(now)); // 2021-January-17 15/52/24\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n解析日期同样需要格式化器，默认使用ISO_LOCAL_DATE：\n\nString dateStr = "2021$01$01";\nfinal LocalDate localDate = LocalDate.parse(dateStr, DateTimeFormatter.ofPattern("yyyy$MM$dd"));\nSystem.out.println(localDate.getDayOfMonth()); // 1\n\n\n1\n2\n3\n# 时区和历法\n先来了解一下几个关于时区的相关概念。\n\n * GMT（Greenwich Mean Time）：英国格林威治标准时间。\n * UTC（Universal Time Coordinated）：世界协调时，在时刻上接近于GMT时间。\n\n世界各国都以UTC时间为基准，本地时间=UTC + 时区差。\n\n时区表示方式包括固定时间偏移量和地理区域：\n\n * 地理区域：格式为"{洲}/{城市}"，如"Asia/Shanghai"。\n * 固定时间偏移量：一般使用\'+\'或者\'-\'然后加上四位数字，如"+0800"表示东八区，"-0500"表示西五区，则UTC+0800表示东八区的时间。\n\n计算机中的时间戳表示的是GMT时间1970年1月1日 00:00:00 000到具体时间的毫秒数，与时区没有干系，也就是说北京的电脑和纽约的电脑同一时刻获得的时间戳是一致的。只有把时间戳解释为时间才会考虑时区。\n\nZoneId表示时区的ID，其有两个子类，ZoneOffset和ZoneRegion分别表示时间偏移量格式和地理区域格式。除了上面所说的表示两种方式的基本格式外，Java还支持其他格式，具体请参考DOC。\n\nZonedDateTime表示含有时区信息的日期时间，可以利用该类来表示一个具有时区信息的日期时间对象。\n\nfinal LocalDateTime shanghai = LocalDateTime.now(ZoneId.of("+0800"));\n/* \n注意这里仅仅是将shanghai中的时间贴上"-0500"时区的信息，不是将"+0800"的时间转换为此时对应的"-0500"时间。\n*/\nfinal ZonedDateTime newyork = ZonedDateTime.of(shanghai, ZoneId.of("-0500"));\nSystem.out.println(shanghai); // 2021-01-17T17:16:26.941673 没有时区信息\nSystem.out.println(newyork); // 2021-01-17T17:16:26.941673-05:00 含有时区信息\n\n/* 仍然只是更改了时区信息而已，时间信息没有变化 */\nZonedDateTime zonedShanghai = shanghai.atZone(ZonedId.of("-0500")); // 2021-01-17T17:16:26.941673-05:00\n\nnewyork = ZonedDateTime.now(ZoneId.of("-0500"));\n// 获取当前时刻其他时区的时间信息\nSystem.out.println(newyork); // 2021-01-17T04:38:37.863443600-05:00\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n如果要获取当前时刻其他时区的时间信息，还可以利用OffsetDateTime类。\n\nfinal OffsetDateTime shanghai = OffsetDateTime.now(ZoneId.of("+0800"));\nfinal OffsetDateTime newyork = OffsetDateTime.now(ZoneId.of("-0500"));\nSystem.out.println(shanghai); // 2021-01-17T17:28:38.358266200+08:00\nSystem.out.println(newyork); // 2021-01-17T04:28:38.360259100-05:00\n\n\n1\n2\n3\n4\n如果要将A时区的某个时间转化为对应那个时刻的B时区的时间，即时间的时区转换，需要使用ZonedDateTime的withZoneSameInstant()方法。\n\n/* 整个转换过程可以简化为 ldtA->zdtA->zdtB->ldtB */\nfinal LocalDateTime shanghai = LocalDateTime.now(ZoneId.of("+0800"));\nfinal ZonedDateTime zonedShanghai = ZonedDateTime.of(shanghai, ZoneId.of("+0800"));\nfinal ZonedDateTime zonedNewYork = zonedShanghai.withZoneSameInstant(ZoneId.of("-0500"));\nfinal LocalDateTime newYork = zonedNewYork.toLocalDateTime();\nSystem.out.println(shanghai); // 2021-01-17T17:48:27.590701600\nSystem.out.println(newYork); // 2021-01-17T04:48:27.590701600\n\n\n1\n2\n3\n4\n5\n6\n7',normalizedContent:'在java 1.0中，java只提供了java.util.date类来处理日期和时间，但是该类只能以毫秒的精度表示时间。更糟糕的是其易用性，比如年份的起始为1900年，月份的起始从0开始。在java 1.1中，date类中很多方法被废弃了，取而代之的是java.util.calendar类，但是该类仍然有类似的问题和设计缺陷。关于date和calendar类，到底该使用哪一个？而有些特性又只在一个类中存在，比如dateformat方法就只在date类里有，同时dateformat也有线程安全的问题。\n\n# java.time包结构\n为了解决上述问题，java 8引入了java.time包，包含了很多新的类，如localdate, localtime, localdatetime, instant, duration和period等，除此之外，还有几个子包，分别是：\n\n * java.time.chrono：此包提供历法相关的接口与实现。java中默认使用的历法是iso 8086日历系统，也就是我们常说的公历。此外还提供了几种其他历法，泰国佛教历，民国历，日本历和伊斯兰历。每种历法api分为三部分：xxxera，xxxchronology和xxxdate。\n * java.time.format：此包提供了日期格式化的方法。format包中定义了时区名称，日期解析和格式化的各种枚举。此包中的类都是final的，都提供了线程安全的访问。\n * java.time.temporal：此包中定义了整个日期时间框架的基础，各种时间单位，时间调节器等。java 8中日期时间类都是实现了temporal包中的事件单位（temporal），时间调节器（temporaladjuster）和各种属性的接口。\n * java.time.zone：此包定义了时区转换的规则和方法。\n\n# 日期/时间类\nlocaldate表示日期，localtime表示时间，localdatetime表示使日期和时间的合体。localdatetime中大部分关于日期的操作都与localdate类似，关于时间的操作都与localtime类似。\n\n# localdate\n# 获取localdate实例\n可以通过静态工厂方法of()来创建一个localdate实例。\n\n/* 注意，如果各项参数无效的话，会抛出异常 */\nlocaldate day = localdate.of(2016, 9, 9); // 参数是int型的\n\n\n1\n2\n也可以通过方法now()来创建一个表示当前日期的localdate实例。\n\nlocaldate now = localdate.now();\n// 此外，还有几个与时区有关的实现\n\n\n1\n2\n由于localdate实例是不可变化的，所以对localdate实例的修改会产生一个新的实例。\n\n# 获取localdate实例属性\nlocaldate day = localdate.of(2016, 9, 9);\n\nfinal int year = day.getyear();\n\nfinal month month = day.getmonth();\nfinal int monthvalue = day.getmonthvalue(); // 当前月中的第几天\n\nfinal int dayofmonth = day.getdayofmonth(); // 当前月中的第几天\nfinal dayofweek dayofweek = day.getdayofweek(); // 当前周中的第几天，从1开始，返回类型为dayofweek枚举\nfinal int dayofyear = day.getdayofyear(); // 当前年份内的第几天，从1到365或366（闰年）\n\nfinal int lengthofyear = day.lengthofyear();\nfinal int lengthofmonth = day.lengthofmonth();\n\nfinal boolean leapyear = day.isleapyear(); // 是否是闰年\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 其他操作\n可以在localdate实例的基础上得到localdatetime实例：\n\nlocaldatetime localdatetime =  localdate.now().attime(19, 12, 11, 1000092);\n\n\n1\n关于localdate的常用操作就是这些。\n\n# localtime\n# 获取localtime实例\n可以通过of()工厂方法来获取表示指定时间的localtime实例：\n\n/*\n下来三个属性依次表示时（0~23），分（0~59），秒（0~59），括号里面表示有效值\n如果参数不合法，将会产生datetimeexception\n*/\nlocaltime time = localtime.of(23, 59, 59);\n\n\n1\n2\n3\n4\n5\n也可以通过now()方法来获取一个表示当前时间的localtime实例：\n\nlocaltime now = localtime.now();\n\n\n1\n由于localtime实例是不可变化的，所以修改其实例会产生一个新的实例。\n\n# 获取localtime属性\nfinal int hour = time.gethour();\nfinal int minute = time.getminute();\nfinal int second = time.getsecond();\nfinal int nano = time.getnano(); // 返回纳秒\n\n\n1\n2\n3\n4\n笔记\n\n这里补充一下秒的单位及其换算关系：\n\n111秒 = 10310^3103毫秒（millisecond） = 10610^6106微秒（microsecond） = 10910^9109纳秒 （nanosecond）= 101210^{12}1012皮秒（picosecond） = 101510^{15}1015飞秒（femtosecond）\n\n# 其他操作\n可以将localtime实例的基础上得到localdatetime实例：\n\nlocaldatetime localdatetime = localtime.now().atdate(localdate.now());\n\n\n1\n# 时间点和时间间隔\n时间点是时间线上的一个点，表示一个时间戳。时间间隔表示两个时间点之间的间隔。instant表示时间点，duration和period表示时间间隔。\n\n# instant\ninstant表示一个时间点，或时间戳，可以精确到纳秒。\n\n# 获取instant实例\n可以通过工厂方法now()来获取时间点对象：\n\ninstant now = instant.now();\n\n\n1\n所有对instant实例的修改都不会修改源对象，而是返回一个新的对象。\n\n可以对instant实例执行plusxxx，minusxxx操作：\n\nplusseconds(); minusseconds();\nplusmillis(); minusmillis();\nplusnanos(); minusnanos();\n\n\n1\n2\n3\n也可以直接使用plus()或者是minus()方法：\n\n/* temporalunit保存了单位，如果指定了其他不支持的单位的话，会抛出unsupportedtemporaltypeexception异常。*/\nplus(long amounttoadd, temporalunit unit);\ninstant minus(long amounttosubtract, temporalunit unit);\n\n\n1\n2\n3\n# duration\nduration表示时间间隔，可以从两个时间点对象获取到时间间隔。可以通过工厂方法between()来获取duration实例：\n\n// duration between(temporal startinclusive, temporal endexclusive);\nfinal localdatetime now = localdatetime.now();\nfinal localdatetime past = now.minus(2, chronounit.years);\nduraton duration = duration.between(past,now);\n\n\n1\n2\n3\n4\n另外还可以通过of()来创建，该方法接受一个时间段长度和一个时间单位作为参数：\n\nduration duration = duration.of(100, chronounit.days);\n\n\n1\n# period\nperiod和duration类似，但period包含年份，月份和日期，而duration只包含秒，毫秒，纳秒。period和duraton的很多方法都很类似，这里就不再赘述了，更多细节请参考官方doc。\n\n# 操纵日期/时间对象\n可以通过withxxx，plusxxx，minusxxx方法修改日期/时间对象的某些属性，也可以采用通用的with()，plus()，minus()方法来获取源对象经过修改后的对象。这些通用方法需要指定一个单位来取代xxx，对于plus()和minus()，该单位的类型是temporalunit，该接口有一个枚举实现：chronounit，可以很方便地指定单位。对于with()，需要指定一个temporalfield类型的参数，可以使用接口的枚举实现chronofield。\n\n笔记\n\nchronounit实现temporalunit，而chronofield实现temporalfield。xxxunit表示时间单位，如年月日时分秒等；而xxxfield表示某个具体的时间的属性，如month_of_year。前者仅仅是单位而已，而可以通过后者表示的属性从时间中取出属性值。\n\n上述操纵方式都是比较简单和直接的，对于复杂操作可以使用调节器（temporaladjuster），工具类temporaladjusters中定义了很多调节器。这个调节器类似比较器一样，是策略模式的体系。\n\nwith方法接受一个调节器，如获取下一个工作日的日期：\n\nfinal localdate now = localdate.of(2021, 1,16); // friday\nfinal temporaladjuster adjuster = temporaladjusters.ofdateadjuster((temporal) -> {\n    int adddays = 1;\n    if (now.getdayofweek() == dayofweek.friday) adddays = 3;\n    else if (now.getdayofweek() == dayofweek.saturday) adddays = 2;\n    return temporal.plus(adddays, chronounit.days);\n});\nfinal localdate nextworkday = now.with(adjuster);\nsystem.out.println(nextworkday); // 2020-01-18\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 格式化和解析\ndatetimeformatter类中以及预定了很多格式的格式化器：\n\n * basic_iso_date：20210107\n * iso_date_time：2021-01-17t15:33:33.5644861\n * iso_date：2021-01-17\n * ...\n\n也可以通过ofpattern()工厂方法创建一个格式化器：\n\nfinal localdatetime now = localdatetime.now();\nfinal datetimeformatter formatter = datetimeformatter.ofpattern("yyyy/mm/dd hh:mm:ss");\nsystem.out.println(formatter.format(now)); // 2021/01/17 15:37:38\n\n\n1\n2\n3\n以及通过datatimeformatterbuilder来构建格式化器：\n\nfinal localdatetime now = localdatetime.now();\nfinal datetimeformatter formatter = new datetimeformatterbuilder()\n    .appendtext(chronofield.year)\n    .appendliteral("-")\n    .appendtext(chronofield.month_of_year)\n    .appendliteral("-")\n    .appendtext(chronofield.day_of_month)\n    .appendliteral(\' \')\n    .appendtext(chronofield.hour_of_day)\n    .appendliteral("/")\n    .appendtext(chronofield.minute_of_hour)\n    .appendliteral("/")\n    .appendtext(chronofield.second_of_minute).toformatter();\nsystem.out.println(formatter.format(now)); // 2021-january-17 15/52/24\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n解析日期同样需要格式化器，默认使用iso_local_date：\n\nstring datestr = "2021$01$01";\nfinal localdate localdate = localdate.parse(datestr, datetimeformatter.ofpattern("yyyy$mm$dd"));\nsystem.out.println(localdate.getdayofmonth()); // 1\n\n\n1\n2\n3\n# 时区和历法\n先来了解一下几个关于时区的相关概念。\n\n * gmt（greenwich mean time）：英国格林威治标准时间。\n * utc（universal time coordinated）：世界协调时，在时刻上接近于gmt时间。\n\n世界各国都以utc时间为基准，本地时间=utc + 时区差。\n\n时区表示方式包括固定时间偏移量和地理区域：\n\n * 地理区域：格式为"{洲}/{城市}"，如"asia/shanghai"。\n * 固定时间偏移量：一般使用\'+\'或者\'-\'然后加上四位数字，如"+0800"表示东八区，"-0500"表示西五区，则utc+0800表示东八区的时间。\n\n计算机中的时间戳表示的是gmt时间1970年1月1日 00:00:00 000到具体时间的毫秒数，与时区没有干系，也就是说北京的电脑和纽约的电脑同一时刻获得的时间戳是一致的。只有把时间戳解释为时间才会考虑时区。\n\nzoneid表示时区的id，其有两个子类，zoneoffset和zoneregion分别表示时间偏移量格式和地理区域格式。除了上面所说的表示两种方式的基本格式外，java还支持其他格式，具体请参考doc。\n\nzoneddatetime表示含有时区信息的日期时间，可以利用该类来表示一个具有时区信息的日期时间对象。\n\nfinal localdatetime shanghai = localdatetime.now(zoneid.of("+0800"));\n/* \n注意这里仅仅是将shanghai中的时间贴上"-0500"时区的信息，不是将"+0800"的时间转换为此时对应的"-0500"时间。\n*/\nfinal zoneddatetime newyork = zoneddatetime.of(shanghai, zoneid.of("-0500"));\nsystem.out.println(shanghai); // 2021-01-17t17:16:26.941673 没有时区信息\nsystem.out.println(newyork); // 2021-01-17t17:16:26.941673-05:00 含有时区信息\n\n/* 仍然只是更改了时区信息而已，时间信息没有变化 */\nzoneddatetime zonedshanghai = shanghai.atzone(zonedid.of("-0500")); // 2021-01-17t17:16:26.941673-05:00\n\nnewyork = zoneddatetime.now(zoneid.of("-0500"));\n// 获取当前时刻其他时区的时间信息\nsystem.out.println(newyork); // 2021-01-17t04:38:37.863443600-05:00\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n如果要获取当前时刻其他时区的时间信息，还可以利用offsetdatetime类。\n\nfinal offsetdatetime shanghai = offsetdatetime.now(zoneid.of("+0800"));\nfinal offsetdatetime newyork = offsetdatetime.now(zoneid.of("-0500"));\nsystem.out.println(shanghai); // 2021-01-17t17:28:38.358266200+08:00\nsystem.out.println(newyork); // 2021-01-17t04:28:38.360259100-05:00\n\n\n1\n2\n3\n4\n如果要将a时区的某个时间转化为对应那个时刻的b时区的时间，即时间的时区转换，需要使用zoneddatetime的withzonesameinstant()方法。\n\n/* 整个转换过程可以简化为 ldta->zdta->zdtb->ldtb */\nfinal localdatetime shanghai = localdatetime.now(zoneid.of("+0800"));\nfinal zoneddatetime zonedshanghai = zoneddatetime.of(shanghai, zoneid.of("+0800"));\nfinal zoneddatetime zonednewyork = zonedshanghai.withzonesameinstant(zoneid.of("-0500"));\nfinal localdatetime newyork = zonednewyork.tolocaldatetime();\nsystem.out.println(shanghai); // 2021-01-17t17:48:27.590701600\nsystem.out.println(newyork); // 2021-01-17t04:48:27.590701600\n\n\n1\n2\n3\n4\n5\n6\n7',charsets:{cjk:!0}},{title:"Java中的枚举",frontmatter:{title:"Java中的枚举",categories:["编程语言"],tags:["Java"],date:"2021-01-22T19:50:26.000Z",permalink:"/pages/405394/"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/01.%E5%9F%BA%E7%A1%80/07.Java%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE.html",relativePath:"01.编程语言/01.Java/01.基础/07.Java中的枚举.md",key:"v-0402a1bd",path:"/pages/405394/",headers:[{level:2,title:"枚举的简单使用",slug:"枚举的简单使用",normalizedTitle:"枚举的简单使用",charIndex:79},{level:2,title:"枚举的实现原理",slug:"枚举的实现原理",normalizedTitle:"枚举的实现原理",charIndex:849},{level:2,title:"枚举的进阶用法",slug:"枚举的进阶用法",normalizedTitle:"枚举的进阶用法",charIndex:2630},{level:3,title:"自定义构造函数和添加方法",slug:"自定义构造函数和添加方法",normalizedTitle:"自定义构造函数和添加方法",charIndex:2640},{level:3,title:"枚举与switch",slug:"枚举与switch",normalizedTitle:"枚举与switch",charIndex:3351},{level:3,title:"枚举实现接口和定义抽象方法",slug:"枚举实现接口和定义抽象方法",normalizedTitle:"枚举实现接口和定义抽象方法",charIndex:4067}],excerpt:"<p>枚举类型是Java1.5新增的特性之一，但是可能平时很少使用，所以对枚举不是很熟悉。但是枚举在某些场景中很适用，所以本文就来分析一下Java中的枚举。</p>\n",lastUpdated:"2021-01-22",headersStr:"枚举的简单使用 枚举的实现原理 枚举的进阶用法 自定义构造函数和添加方法 枚举与switch 枚举实现接口和定义抽象方法",content:'枚举类型是Java1.5新增的特性之一，但是可能平时很少使用，所以对枚举不是很熟悉。但是枚举在某些场景中很适用，所以本文就来分析一下Java中的枚举。\n\n# 枚举的简单使用\npublic enum Mode{\n  DAY_MODE, DARK_MODE\n}\n\n\n1\n2\n3\n这样就定义好了一个枚举，其中enum关键字，这里Mode只是枚举的名称，和类名差不多。然后{}内部是枚举的值，一般用大写字母表示，多个值之间用逗号分割。\n\n使用枚举也很简单，下面是一个简单的枚举使用案例：\n\npublic class ENUMTest {\n  private final static int DAY_BEGIN_HOUR = 7;\n  private final static int DAY_END_HOUR = 19;\n  public static void main(String[] args) {\n    Mode mode = (LocalTime.now().getHour() >= DAY_BEGIN_HOUR && LocalTime.now().getHour() < DAY_END_HOUR) ? Mode.DAY_MODE : Mode.DARK_MODE;\n    System.out.println(getModeName(mode));\n  }\n\n  public static String getModeName(Mode mode) {\n    if (mode == Mode.DAY_MODE) {\n      return "白天模式";\n    } else {\n      return "夜间模式";\n    }\n  }\n}\n\n// 另一个文件中\npublic enum Mode {\n  DAY_MODE, DARK_MODE\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 枚举的实现原理\n上面的代码编译后，会生成一个字节码文件：Mode.class，感觉和类太像了。我们使用jad将其反编译一下，内容如下所示：\n\npublic final class Mode extends Enum\n{\n\n    public static Mode[] values()\n    {\n        return (Mode[])$VALUES.clone();\n    }\n\n    public static Mode valueOf(String name)\n    {\n        return (Mode)Enum.valueOf(com/color/se/enumeration/Mode, name);\n    }\n\n    private Mode(String s, int i)\n    {\n        super(s, i);\n    }\n\n    public static final Mode DAY_MODE;\n    public static final Mode DARK_MODE;\n    private static final Mode $VALUES[];\n\n    static \n    {\n        DAY_MODE = new Mode("DAY_MODE", 0);\n        DARK_MODE = new Mode("DARK_MODE", 1);\n        $VALUES = (new Mode[] {\n            DAY_MODE, DARK_MODE\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n可以发现，和普通的类定义没有什么区别。其实Enum是所有枚举类型的公共基类，这是一个java.lang包下面的抽象类，而且具有泛型形参，不过上述反编译结果中并没有体现这一点。但是请注意，我们不能直接继承Enum类，否则无法编译。\n\n另外，编译器还生成了values()和valueOf()方法以及构造器，但该构造器是私有的。\n\n * values()方法返回$VALUES字段的值，可以通过该方法返回所有的枚举常量。\n   \n   for (Mode value : Mode.values()) {\n     System.out.println(value);\n   }\n   /*\n   DAY_MODE\n   DARK_MODE\n   */\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   由于父类并没有该方法，但是在Class<?>类中定义了一个getEnumConstants()，可以调用该方法来获取所有的元素。对于非枚举类型，调用该方法会返回null，所以可以通过isEnum()方法判断当前class对象是否代表枚举类型。\n   \n   System.out.println(Mode.class.isEnum()); // true\n   for (Mode value : Mode.class.getEnumConstants()) {\n     System.out.println(value);\n   }\n   /*\n   DAY_MODE\n   DARK_MODE\n   */\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n * valueOf()，此方法调用了父类的同名不同参方法。根据常量名称来获取常量实例。注意调用该方法时传入的参数必须存在对应的枚举常量，否则会抛出IlleageArgumentException: No enum constant XXX。\n   \n   Mode dark_mode = Mode.valueOf("DARK_MODE");\n   System.out.println(dark_mode == Mode.DARK_MODE); // true\n   \n   \n   1\n   2\n   \n\n# 枚举的进阶用法\n# 自定义构造函数和添加方法\n我们修改一下上面简单使用的那个例子，当直接输出枚举常量就可以输出对应的中文含义：\n\npublic enum Mode {\n  // 在枚举常量声明前不能声明方法\n  DAY_MODE("白天模式"), DARK_MODE("夜晚模式"); // 注意分号\n\n  private final String description;\n\n  private Mode(String description) {\n    this.description = description;\n  }\n\n  public String toString() {\n    return this.description;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n然后再测试：\n\nMode mode = (LocalTime.now().getHour() >= DAY_BEGIN_HOUR && LocalTime.now().getHour() < DAY_END_HOUR) ? Mode.DAY_MODE : Mode.DARK_MODE;\n    System.out.println(mode); // 夜晚模式\n\n\n1\n2\n上面因为我是晚上测试的，所以直接输出夜晚模式。\n\n注意，枚举类型定义的构造方法只能是private的，定义为public的话编译报错。在枚举常量前不能声明方法，在枚举常量后面有声明的话，必须在最后一个枚举常量后面添加;。上面重写了toString()方法，其实父类也之允许重写这一个方法，其他方法在Enum中都是final的。\n\n# 枚举与switch\nswitch表达式支持枚举类型，下面来看一个使用例子：\n\nMode mode = (LocalTime.now().getHour() >= DAY_BEGIN_HOUR && LocalTime.now().getHour() < DAY_END_HOUR) ? Mode.DAY_MODE : Mode.DARK_MODE;\nswitch (mode) {\n  case DAY_MODE:\n    System.out.println("白天模式");break;\n  case DARK_MODE:\n    System.out.println("夜间模式");break;\n  default:\n    System.out.println("The mode is invalid.");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n注意，在case后面没有指明枚举名，这是允许的。JVM会根据switch语句中传入的类型来自动推断。\n\n笔记\n\nswitch除了支持枚举类型以外，还支持char，byte，short，int型，从1.7开始也支持String类型。case后面跟的是事实最终常量（effective constant），如果参数一旦与某个case后面的常量匹配，那么将会一直执行直到break的出现；当没有任何case匹配时，可以定义一组默认操作。\n\n在使用switch ... case...语句时，特别注意是否添加break，否则会造成意想不到的效果。可以加上编译选项-Xlint:fallthrough来检查是否每个case分支后面都加了break，如果没有会抛出警告。\n\n# 枚举实现接口和定义抽象方法\n由于枚举生成的类中已经继承了Enum类，所以不能再继承了（Java的单继承限制），但是可以实现接口。笔者确实未能想出这种用法的案例，所以就不举例了，但是枚举确实能够实现接口的。\n\n另外，枚举中也可以定义抽象方法，不过每个枚举常量必须实现这样该方法。\n\npublic enum Mode {\n  DAY_MODE("白天模式") {\n    @Override\n    int getStartHour() {\n      return 7;\n    }\n    @Override\n    int getEndHour() {\n      return 19;\n    }\n  }, \n  DARK_MODE("夜晚模式"){\n    @Override\n    int getStartHour() {\n      return 19;\n    }\n    @Override\n    int getEndHour() {\n      return 7;\n    }\n  };\n\n  private final String description;\n  private Mode(String description) {\n    this.description = description;\n  }\n  \n  abstract int getStartHour();\n  abstract int getEndHour();\n  \n  public String toString() {\n    return this.description;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n上面定义了两个抽象方法，让不同的常量实现不同的行为（听起来有点像多态）。但是枚举常量不能作为类型使用，如下面的代码将会产生编译错误。\n\npublic void XXX(Mode.DAY_MODE day_mode) // compile error\n\n\n1\nJava世界中还存在更多的枚举使用案例，后面有时间再补充。',normalizedContent:'枚举类型是java1.5新增的特性之一，但是可能平时很少使用，所以对枚举不是很熟悉。但是枚举在某些场景中很适用，所以本文就来分析一下java中的枚举。\n\n# 枚举的简单使用\npublic enum mode{\n  day_mode, dark_mode\n}\n\n\n1\n2\n3\n这样就定义好了一个枚举，其中enum关键字，这里mode只是枚举的名称，和类名差不多。然后{}内部是枚举的值，一般用大写字母表示，多个值之间用逗号分割。\n\n使用枚举也很简单，下面是一个简单的枚举使用案例：\n\npublic class enumtest {\n  private final static int day_begin_hour = 7;\n  private final static int day_end_hour = 19;\n  public static void main(string[] args) {\n    mode mode = (localtime.now().gethour() >= day_begin_hour && localtime.now().gethour() < day_end_hour) ? mode.day_mode : mode.dark_mode;\n    system.out.println(getmodename(mode));\n  }\n\n  public static string getmodename(mode mode) {\n    if (mode == mode.day_mode) {\n      return "白天模式";\n    } else {\n      return "夜间模式";\n    }\n  }\n}\n\n// 另一个文件中\npublic enum mode {\n  day_mode, dark_mode\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 枚举的实现原理\n上面的代码编译后，会生成一个字节码文件：mode.class，感觉和类太像了。我们使用jad将其反编译一下，内容如下所示：\n\npublic final class mode extends enum\n{\n\n    public static mode[] values()\n    {\n        return (mode[])$values.clone();\n    }\n\n    public static mode valueof(string name)\n    {\n        return (mode)enum.valueof(com/color/se/enumeration/mode, name);\n    }\n\n    private mode(string s, int i)\n    {\n        super(s, i);\n    }\n\n    public static final mode day_mode;\n    public static final mode dark_mode;\n    private static final mode $values[];\n\n    static \n    {\n        day_mode = new mode("day_mode", 0);\n        dark_mode = new mode("dark_mode", 1);\n        $values = (new mode[] {\n            day_mode, dark_mode\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n可以发现，和普通的类定义没有什么区别。其实enum是所有枚举类型的公共基类，这是一个java.lang包下面的抽象类，而且具有泛型形参，不过上述反编译结果中并没有体现这一点。但是请注意，我们不能直接继承enum类，否则无法编译。\n\n另外，编译器还生成了values()和valueof()方法以及构造器，但该构造器是私有的。\n\n * values()方法返回$values字段的值，可以通过该方法返回所有的枚举常量。\n   \n   for (mode value : mode.values()) {\n     system.out.println(value);\n   }\n   /*\n   day_mode\n   dark_mode\n   */\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   由于父类并没有该方法，但是在class<?>类中定义了一个getenumconstants()，可以调用该方法来获取所有的元素。对于非枚举类型，调用该方法会返回null，所以可以通过isenum()方法判断当前class对象是否代表枚举类型。\n   \n   system.out.println(mode.class.isenum()); // true\n   for (mode value : mode.class.getenumconstants()) {\n     system.out.println(value);\n   }\n   /*\n   day_mode\n   dark_mode\n   */\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n * valueof()，此方法调用了父类的同名不同参方法。根据常量名称来获取常量实例。注意调用该方法时传入的参数必须存在对应的枚举常量，否则会抛出illeageargumentexception: no enum constant xxx。\n   \n   mode dark_mode = mode.valueof("dark_mode");\n   system.out.println(dark_mode == mode.dark_mode); // true\n   \n   \n   1\n   2\n   \n\n# 枚举的进阶用法\n# 自定义构造函数和添加方法\n我们修改一下上面简单使用的那个例子，当直接输出枚举常量就可以输出对应的中文含义：\n\npublic enum mode {\n  // 在枚举常量声明前不能声明方法\n  day_mode("白天模式"), dark_mode("夜晚模式"); // 注意分号\n\n  private final string description;\n\n  private mode(string description) {\n    this.description = description;\n  }\n\n  public string tostring() {\n    return this.description;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n然后再测试：\n\nmode mode = (localtime.now().gethour() >= day_begin_hour && localtime.now().gethour() < day_end_hour) ? mode.day_mode : mode.dark_mode;\n    system.out.println(mode); // 夜晚模式\n\n\n1\n2\n上面因为我是晚上测试的，所以直接输出夜晚模式。\n\n注意，枚举类型定义的构造方法只能是private的，定义为public的话编译报错。在枚举常量前不能声明方法，在枚举常量后面有声明的话，必须在最后一个枚举常量后面添加;。上面重写了tostring()方法，其实父类也之允许重写这一个方法，其他方法在enum中都是final的。\n\n# 枚举与switch\nswitch表达式支持枚举类型，下面来看一个使用例子：\n\nmode mode = (localtime.now().gethour() >= day_begin_hour && localtime.now().gethour() < day_end_hour) ? mode.day_mode : mode.dark_mode;\nswitch (mode) {\n  case day_mode:\n    system.out.println("白天模式");break;\n  case dark_mode:\n    system.out.println("夜间模式");break;\n  default:\n    system.out.println("the mode is invalid.");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n注意，在case后面没有指明枚举名，这是允许的。jvm会根据switch语句中传入的类型来自动推断。\n\n笔记\n\nswitch除了支持枚举类型以外，还支持char，byte，short，int型，从1.7开始也支持string类型。case后面跟的是事实最终常量（effective constant），如果参数一旦与某个case后面的常量匹配，那么将会一直执行直到break的出现；当没有任何case匹配时，可以定义一组默认操作。\n\n在使用switch ... case...语句时，特别注意是否添加break，否则会造成意想不到的效果。可以加上编译选项-xlint:fallthrough来检查是否每个case分支后面都加了break，如果没有会抛出警告。\n\n# 枚举实现接口和定义抽象方法\n由于枚举生成的类中已经继承了enum类，所以不能再继承了（java的单继承限制），但是可以实现接口。笔者确实未能想出这种用法的案例，所以就不举例了，但是枚举确实能够实现接口的。\n\n另外，枚举中也可以定义抽象方法，不过每个枚举常量必须实现这样该方法。\n\npublic enum mode {\n  day_mode("白天模式") {\n    @override\n    int getstarthour() {\n      return 7;\n    }\n    @override\n    int getendhour() {\n      return 19;\n    }\n  }, \n  dark_mode("夜晚模式"){\n    @override\n    int getstarthour() {\n      return 19;\n    }\n    @override\n    int getendhour() {\n      return 7;\n    }\n  };\n\n  private final string description;\n  private mode(string description) {\n    this.description = description;\n  }\n  \n  abstract int getstarthour();\n  abstract int getendhour();\n  \n  public string tostring() {\n    return this.description;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n上面定义了两个抽象方法，让不同的常量实现不同的行为（听起来有点像多态）。但是枚举常量不能作为类型使用，如下面的代码将会产生编译错误。\n\npublic void xxx(mode.day_mode day_mode) // compile error\n\n\n1\njava世界中还存在更多的枚举使用案例，后面有时间再补充。',charsets:{cjk:!0}},{title:"Java中的Lambda表达式及原理",frontmatter:{title:"Java中的Lambda表达式及原理",categories:["编程语言"],tags:["Java"],date:"2021-01-29T09:48:20.000Z",permalink:"/pages/226a87/"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/01.%E5%9F%BA%E7%A1%80/08.Java%E4%B8%AD%E7%9A%84Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html",relativePath:"01.编程语言/01.Java/01.基础/08.Java中的Lambda表达式及实现原理.md",key:"v-4f8b20a7",path:"/pages/226a87/",headers:[{level:2,title:"语法总结",slug:"语法总结",normalizedTitle:"语法总结",charIndex:186},{level:2,title:"实现原理",slug:"实现原理",normalizedTitle:"实现原理",charIndex:2024}],excerpt:"<p>Lambda表达式是Java 8引入的特性，极大程度上简化了某些匿名内部类的写法。Java中的lambda表达式更像是C/C++中的函数指针，但在Java 8之前，Java是做不到传递方法的，必须封装为一个对象来进行传递，而匿名内部类就是为了这样的目的。但是匿名内部类格式繁琐，而今天广泛被使用的lambda表达式格式更简洁，并且其底层实现和匿名内部类也存在差异。</p>\n",lastUpdated:"2021-01-29",headersStr:"语法总结 实现原理",content:'Lambda表达式是Java 8引入的特性，极大程度上简化了某些匿名内部类的写法。Java中的lambda表达式更像是C/C++中的函数指针，但在Java 8之前，Java是做不到传递方法的，必须封装为一个对象来进行传递，而匿名内部类就是为了这样的目的。但是匿名内部类格式繁琐，而今天广泛被使用的lambda表达式格式更简洁，并且其底层实现和匿名内部类也存在差异。\n\n# 语法总结\n在Java中，lambda表达式的基本格式如下伪代码所示：\n\n(args...) -> { method body }\n\n\n1\n在继续讨论lambda表达式之前，先来认识一下函数式接口。\n\n函数式接口是指接口中仅有一个抽象方法的接口，一般被@FunctionalInterface所修饰。函数式接口与lambda表达式密切相关，当方法需要接收一个lambda表达式时，可以将形参类型指定为某种函数式接口，Java以及预定义了很多中函数式接口了，在java.util.Function包下。\n\n当书写lambda表达式时，有很多简写形式。\n\n * 省略参数类型：Java可以根据上下文（一般是泛型参数）中自动推断出参数类型。下面定义了一个关于String的比较器：\n   \n   BiFunction<String, String, Integer>cmp = (s1, s2) -> { \n       return s1.length() - s2.length(); \n   };\n   \n   \n   1\n   2\n   3\n   \n * 省略参数小括号：如果只有一个参数，则可以省略掉小括号。如果无参，小括号不能被省略。\n   \n   Consumer<String> consumer = x -> {\n       System.out.println(x);\n   };\n   \n   \n   1\n   2\n   3\n   \n * 省略掉方法体大括号：如果方法体只有一条语句，则可以直接写这条语句。如果没有方法体，大括号不能被省略。\n   \n   Consumer<String> consumer = x -> System.out.println(x);\n   \n   \n   1\n   \n * 省略return关键字：如果方法体只有一条return语句，则可以直接写return后面的表达式。注释掉的语句为非简写形式，可以对比一下，简写前方法体中是一条语句；而简写后方法体中是一句表达式。\n   \n   // Predicate<Integer> predicate = x -> {return x % 2 == 0;};\n   Predicate<Integer> predicate = x -> x % 2 == 0;\n   \n   \n   1\n   2\n   \n\n另外，与lambda相关的还有一个概念叫做方法引用，指一些现存的已定义的方法。有时候某些已存函数已经能够满足我们的需求了，就可以直接将该方法传递过去，而不用再实现一遍。目前有4种形式的方法引用：\n\n * object::instanceMethod\n   \n   Consumer<String> consumer1 = x -> System.out.println(x);\n   Consumer<String> consumer2 = System.out::println; // 方法引用\n   \n   \n   1\n   2\n   \n * Class::instanceMethod：这种情况比较少见。\n   \n   BiFunction<String, String, Integer>cmp1 = (x, y) -> x.compareToIgnoreCase(y);\n   BiFunction<String, String, Integer>cmp2 = String::compareToIgnoreCase; // 方法引用\n   \n   \n   1\n   2\n   \n * Class::staticMethod\n   \n   BiFunction<Integer, Integer, Double> pow1 = (x, y) -> Math.pow(x, y);\n   BiFunction<Integer, Integer, Double> pow2 = Math::pow; // 方法引用\n   \n   \n   1\n   2\n   \n * Class::new：构造器引用\n   \n   Supplier<String>supplier1 = () -> new String();\n   Supplier<String>supplier2 = String::new; // 方法引用\n   \n   \n   1\n   2\n   \n\n# 实现原理\nLambda表达式确实为我们带来了便利，但是Java到底是怎么实现它的呢？和匿名内部类有什么区别呢？让我们一探究竟。\n\n对于下列代码：\n\npublic static void main(String[] args) {\n    Runnable r = () -> {\n      System.out.println("hello");\n    };\n    r.run();\n}\n\n\n1\n2\n3\n4\n5\n6\n编译后采用javap工具查看字节码信息：\n\nConstant pool:\n   ...\n   #2 = InvokeDynamic      #0:#34         // #0:run:()Ljava/lang/Runnable;\n   ...\n   #34 = NameAndType        #47:#48        // run:()Ljava/lang/Runnable;\n   ...\n   #47 = Utf8               run\n   #48 = Utf8               ()Ljava/lang/Runnable;\n   ...\n\npublic static void main(java.lang.String[]);\ndescriptor: ([Ljava/lang/String;)V\nflags: (0x0009) ACC_PUBLIC, ACC_STATIC\nCode:\n  stack=1, locals=2, args_size=1\n\t 0: invokedynamic #2,  0              // InvokeDynamic #0:run:()Ljava/lang/Runnable;\n\t 5: astore_1\n\t 6: aload_1\n\t 7: invokeinterface #3,  1            // InterfaceMethod java/lang/Runnable.run:()V\n\t12: return\n  LineNumberTable:\n\tline 16: 0\n\tline 19: 6\n\tline 20: 12\n  LocalVariableTable:\n\tStart  Length  Slot  Name   Signature\n\t\t0      13     0  args   [Ljava/lang/String;\n\t\t6       7     1     r   Ljava/lang/Runnable;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n可见，invokedynamic指令的参数为第2号常量，该常量的类型为CONSTANT_Dynamic_info，第2号常量后面的"#0"表示引导方法在bootstrap_methods[]数组内的索引。BootStrapMethods是类文件属性表集合中的一项属性，用于保存该类中所有的引导方法。\n\n在javap分析后输出的内容中也有关于引导方法的信息：\n\nBootstrapMethods:\n  0: #34 REF_invokeStatic java/lang/invoke/LambdaMetafactory.metafactory:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodType;Ljava/lang/invoke/MethodHandle;Ljava/lang/invoke/MethodType;)Ljava/lang/invoke/CallSite;\n    Method arguments:\n      #35 ()V\n      #36 REF_invokeStatic com/color/se/reflect/HandleTest.lambda$main$0:()V\n      #35 ()V\n\n\n1\n2\n3\n4\n5\n6\n该引导方法调用了LambdaMetafactory.metafactory()方法，返回一个java.lang.invoke.CallSite类型的对象。\n\n/**\n* caller：JVM提供的查找上下文\n* invokedName：需要调用的方法名\n* samMethodType：表示函数式接口定义的方法签名\n* implMethod：表示编译时生成的lambda表达式对应的static方法\n* instantiatedMethodType：一般和samMethodType一样\n*/\npublic static CallSite metafactory(MethodHandles.Lookup caller,\n                                   String invokedName,\n                                   MethodType invokedType,\n                                   MethodType samMethodType,\n                                   MethodHandle implMethod,\n                                   MethodType instantiatedMethodType)\n    throws LambdaConversionException {\n    AbstractValidatingLambdaMetafactory mf;\n    mf = new InnerClassLambdaMetafactory(caller, invokedType,\n                                         invokedName, samMethodType,\n                                         implMethod, instantiatedMethodType,\n                                         false, EMPTY_CLASS_ARRAY, EMPTY_MT_ARRAY);\n    mf.validateMetafactoryArgs();\n    return mf.buildCallSite();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n在InnerClassLambdaMetafactory类中，可以发现其在生成内部类：\n\npublic InnerClassLambdaMetafactory(MethodHandles.Lookup caller,\n                                   MethodType invokedType,\n                                   String samMethodName,\n                                   MethodType samMethodType,\n                                   MethodHandle implMethod,\n                                   MethodType instantiatedMethodType,\n                                   boolean isSerializable,\n                                   Class<?>[] markerInterfaces,\n                                   MethodType[] additionalBridges)\n    throws LambdaConversionException {\n    ...\n    /* \n    生成的内部类类名规则：宿主类的名称$$Lambda$n\n    */\n    lambdaClassName = targetClass.getName().replace(\'.\', \'/\') + "$$Lambda$" + counter.incrementAndGet();\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n设置虚拟机参数-Djdk.internal.lambda.dumpProxyClasses就可以输出生成的类文件：\n\nimport java.lang.invoke.LambdaForm.Hidden;\n\n// $FF: synthetic class\nfinal class HandleTest$$Lambda$14 implements Runnable {\n  private HandleTest$$Lambda$14() {\n  }\n\n  @Hidden\n  public void run() {\n    HandleTest.lambda$main$0();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n可见生成的内部类自动实现了函数式接口，并在方法中调用了类中自动生成的静态方法，这里是lambda$main$0()。\n\n关于lambda表达式的原理总结如下：\n\n * Lambda表达式声明的地方会生成一个invokedynamic指令，同时编译器会生成一个对应的引导方法。\n * 第一次执行invokedynamic指令时，会调用对应的引导方法，该引导方法会调用LambdaMetafactory.metafactory()生成内部类。\n * 引导方法会返回一个动态调用CallSite对象，这个对象最终会调用内部类中实现的接口方法。\n * Lambda表达式中的内容会被编译成静态方法，自动生成的内部类中会直接调用静态方法。\n * 真正执行lambda调用的还是通过invokeinterface指令。\n\nLambda表达式的实现方式并不是一成不变的，未来的实现可能会有变化。',normalizedContent:'lambda表达式是java 8引入的特性，极大程度上简化了某些匿名内部类的写法。java中的lambda表达式更像是c/c++中的函数指针，但在java 8之前，java是做不到传递方法的，必须封装为一个对象来进行传递，而匿名内部类就是为了这样的目的。但是匿名内部类格式繁琐，而今天广泛被使用的lambda表达式格式更简洁，并且其底层实现和匿名内部类也存在差异。\n\n# 语法总结\n在java中，lambda表达式的基本格式如下伪代码所示：\n\n(args...) -> { method body }\n\n\n1\n在继续讨论lambda表达式之前，先来认识一下函数式接口。\n\n函数式接口是指接口中仅有一个抽象方法的接口，一般被@functionalinterface所修饰。函数式接口与lambda表达式密切相关，当方法需要接收一个lambda表达式时，可以将形参类型指定为某种函数式接口，java以及预定义了很多中函数式接口了，在java.util.function包下。\n\n当书写lambda表达式时，有很多简写形式。\n\n * 省略参数类型：java可以根据上下文（一般是泛型参数）中自动推断出参数类型。下面定义了一个关于string的比较器：\n   \n   bifunction<string, string, integer>cmp = (s1, s2) -> { \n       return s1.length() - s2.length(); \n   };\n   \n   \n   1\n   2\n   3\n   \n * 省略参数小括号：如果只有一个参数，则可以省略掉小括号。如果无参，小括号不能被省略。\n   \n   consumer<string> consumer = x -> {\n       system.out.println(x);\n   };\n   \n   \n   1\n   2\n   3\n   \n * 省略掉方法体大括号：如果方法体只有一条语句，则可以直接写这条语句。如果没有方法体，大括号不能被省略。\n   \n   consumer<string> consumer = x -> system.out.println(x);\n   \n   \n   1\n   \n * 省略return关键字：如果方法体只有一条return语句，则可以直接写return后面的表达式。注释掉的语句为非简写形式，可以对比一下，简写前方法体中是一条语句；而简写后方法体中是一句表达式。\n   \n   // predicate<integer> predicate = x -> {return x % 2 == 0;};\n   predicate<integer> predicate = x -> x % 2 == 0;\n   \n   \n   1\n   2\n   \n\n另外，与lambda相关的还有一个概念叫做方法引用，指一些现存的已定义的方法。有时候某些已存函数已经能够满足我们的需求了，就可以直接将该方法传递过去，而不用再实现一遍。目前有4种形式的方法引用：\n\n * object::instancemethod\n   \n   consumer<string> consumer1 = x -> system.out.println(x);\n   consumer<string> consumer2 = system.out::println; // 方法引用\n   \n   \n   1\n   2\n   \n * class::instancemethod：这种情况比较少见。\n   \n   bifunction<string, string, integer>cmp1 = (x, y) -> x.comparetoignorecase(y);\n   bifunction<string, string, integer>cmp2 = string::comparetoignorecase; // 方法引用\n   \n   \n   1\n   2\n   \n * class::staticmethod\n   \n   bifunction<integer, integer, double> pow1 = (x, y) -> math.pow(x, y);\n   bifunction<integer, integer, double> pow2 = math::pow; // 方法引用\n   \n   \n   1\n   2\n   \n * class::new：构造器引用\n   \n   supplier<string>supplier1 = () -> new string();\n   supplier<string>supplier2 = string::new; // 方法引用\n   \n   \n   1\n   2\n   \n\n# 实现原理\nlambda表达式确实为我们带来了便利，但是java到底是怎么实现它的呢？和匿名内部类有什么区别呢？让我们一探究竟。\n\n对于下列代码：\n\npublic static void main(string[] args) {\n    runnable r = () -> {\n      system.out.println("hello");\n    };\n    r.run();\n}\n\n\n1\n2\n3\n4\n5\n6\n编译后采用javap工具查看字节码信息：\n\nconstant pool:\n   ...\n   #2 = invokedynamic      #0:#34         // #0:run:()ljava/lang/runnable;\n   ...\n   #34 = nameandtype        #47:#48        // run:()ljava/lang/runnable;\n   ...\n   #47 = utf8               run\n   #48 = utf8               ()ljava/lang/runnable;\n   ...\n\npublic static void main(java.lang.string[]);\ndescriptor: ([ljava/lang/string;)v\nflags: (0x0009) acc_public, acc_static\ncode:\n  stack=1, locals=2, args_size=1\n\t 0: invokedynamic #2,  0              // invokedynamic #0:run:()ljava/lang/runnable;\n\t 5: astore_1\n\t 6: aload_1\n\t 7: invokeinterface #3,  1            // interfacemethod java/lang/runnable.run:()v\n\t12: return\n  linenumbertable:\n\tline 16: 0\n\tline 19: 6\n\tline 20: 12\n  localvariabletable:\n\tstart  length  slot  name   signature\n\t\t0      13     0  args   [ljava/lang/string;\n\t\t6       7     1     r   ljava/lang/runnable;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n可见，invokedynamic指令的参数为第2号常量，该常量的类型为constant_dynamic_info，第2号常量后面的"#0"表示引导方法在bootstrap_methods[]数组内的索引。bootstrapmethods是类文件属性表集合中的一项属性，用于保存该类中所有的引导方法。\n\n在javap分析后输出的内容中也有关于引导方法的信息：\n\nbootstrapmethods:\n  0: #34 ref_invokestatic java/lang/invoke/lambdametafactory.metafactory:(ljava/lang/invoke/methodhandles$lookup;ljava/lang/string;ljava/lang/invoke/methodtype;ljava/lang/invoke/methodtype;ljava/lang/invoke/methodhandle;ljava/lang/invoke/methodtype;)ljava/lang/invoke/callsite;\n    method arguments:\n      #35 ()v\n      #36 ref_invokestatic com/color/se/reflect/handletest.lambda$main$0:()v\n      #35 ()v\n\n\n1\n2\n3\n4\n5\n6\n该引导方法调用了lambdametafactory.metafactory()方法，返回一个java.lang.invoke.callsite类型的对象。\n\n/**\n* caller：jvm提供的查找上下文\n* invokedname：需要调用的方法名\n* sammethodtype：表示函数式接口定义的方法签名\n* implmethod：表示编译时生成的lambda表达式对应的static方法\n* instantiatedmethodtype：一般和sammethodtype一样\n*/\npublic static callsite metafactory(methodhandles.lookup caller,\n                                   string invokedname,\n                                   methodtype invokedtype,\n                                   methodtype sammethodtype,\n                                   methodhandle implmethod,\n                                   methodtype instantiatedmethodtype)\n    throws lambdaconversionexception {\n    abstractvalidatinglambdametafactory mf;\n    mf = new innerclasslambdametafactory(caller, invokedtype,\n                                         invokedname, sammethodtype,\n                                         implmethod, instantiatedmethodtype,\n                                         false, empty_class_array, empty_mt_array);\n    mf.validatemetafactoryargs();\n    return mf.buildcallsite();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n在innerclasslambdametafactory类中，可以发现其在生成内部类：\n\npublic innerclasslambdametafactory(methodhandles.lookup caller,\n                                   methodtype invokedtype,\n                                   string sammethodname,\n                                   methodtype sammethodtype,\n                                   methodhandle implmethod,\n                                   methodtype instantiatedmethodtype,\n                                   boolean isserializable,\n                                   class<?>[] markerinterfaces,\n                                   methodtype[] additionalbridges)\n    throws lambdaconversionexception {\n    ...\n    /* \n    生成的内部类类名规则：宿主类的名称$$lambda$n\n    */\n    lambdaclassname = targetclass.getname().replace(\'.\', \'/\') + "$$lambda$" + counter.incrementandget();\n    ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n设置虚拟机参数-djdk.internal.lambda.dumpproxyclasses就可以输出生成的类文件：\n\nimport java.lang.invoke.lambdaform.hidden;\n\n// $ff: synthetic class\nfinal class handletest$$lambda$14 implements runnable {\n  private handletest$$lambda$14() {\n  }\n\n  @hidden\n  public void run() {\n    handletest.lambda$main$0();\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n可见生成的内部类自动实现了函数式接口，并在方法中调用了类中自动生成的静态方法，这里是lambda$main$0()。\n\n关于lambda表达式的原理总结如下：\n\n * lambda表达式声明的地方会生成一个invokedynamic指令，同时编译器会生成一个对应的引导方法。\n * 第一次执行invokedynamic指令时，会调用对应的引导方法，该引导方法会调用lambdametafactory.metafactory()生成内部类。\n * 引导方法会返回一个动态调用callsite对象，这个对象最终会调用内部类中实现的接口方法。\n * lambda表达式中的内容会被编译成静态方法，自动生成的内部类中会直接调用静态方法。\n * 真正执行lambda调用的还是通过invokeinterface指令。\n\nlambda表达式的实现方式并不是一成不变的，未来的实现可能会有变化。',charsets:{cjk:!0}},{title:"Java中的强软弱虚引用",frontmatter:{title:"Java中的强软弱虚引用",categories:["编程语言"],tags:["Java"],date:"2020-11-26T00:00:00.000Z",permalink:"/pages/72f0d2/"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/01.%E5%9F%BA%E7%A1%80/100.Java%E4%B8%AD%E7%9A%84%E5%BC%BA%E8%BD%AF%E5%BC%B1%E8%99%9A%E5%BC%95%E7%94%A8.html",relativePath:"01.编程语言/01.Java/01.基础/100.Java中的强软弱虚引用.md",key:"v-7eb01deb",path:"/pages/72f0d2/",headers:[{level:2,title:"引用类型",slug:"引用类型",normalizedTitle:"引用类型",charIndex:5},{level:3,title:"强引用",slug:"强引用",normalizedTitle:"强引用",charIndex:34},{level:3,title:"软引用",slug:"软引用",normalizedTitle:"软引用",charIndex:61},{level:3,title:"弱引用",slug:"弱引用",normalizedTitle:"弱引用",charIndex:83},{level:3,title:"虚引用",slug:"虚引用",normalizedTitle:"虚引用",charIndex:105},{level:2,title:"ReferenceQueue",slug:"referencequeue",normalizedTitle:"referencequeue",charIndex:1807}],excerpt:"<p>Java中引用类型又分为四种类别（引用关系强度依次减弱）：</p>\n<ul>\n<li>强引用（Strongly Reference）</li>\n<li>软引用（SoftReference）</li>\n<li>弱引用（WeakReference）</li>\n<li>虚引用（PhantomReference）</li>\n</ul>\n<p>后面三种在Java中都存在具体的类，都实现了<code>java.lang.ref</code>包下的<code>Reference</code>抽象类。</p>\n",lastUpdated:"2021-01-17",headersStr:"引用类型 强引用 软引用 弱引用 虚引用 ReferenceQueue",content:'Java中引用类型又分为四种类别（引用关系强度依次减弱）：\n\n * 强引用（Strongly Reference）\n * 软引用（SoftReference）\n * 弱引用（WeakReference）\n * 虚引用（PhantomReference）\n\n后面三种在Java中都存在具体的类，都实现了java.lang.ref包下的Reference抽象类。\n\n# 引用类型\n# 强引用\n强引用是传统的引用定义，大多数时候说的引用也是指的强应用。\n\nObject obj = new Object();\n\n\n1\n如上代码，引用obj就是强引用。只要强引用关系存在，就算内存不足（发生OOM），垃圾收集器也不会回收掉被引用的对象。\n\n# 软引用\n当内存不足时，就会把软引用关联的对象回收掉。如果要使用软引用，需要使用SoftReference类来实现。\n\nimport java.lang.ref.SoftReference;\n\npublic class TestSoftReference {\n  public static void main(String[] args) {\n    SoftReference<byte[]> reference = new SoftReference<>(new byte[1024 * 1024 * 10]);\n    System.out.println(reference.get());\n    System.gc(); // 执行垃圾回收\n    System.out.println(reference.get());\n\n    byte[] array = new byte[10 * 1024 * 1024];\n\n    System.out.println(reference.get());\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n把上面程序的堆内存大小上限设置为20M（-Xmx20M），执行程序，控制台打印结果为：\n\n[B@3b6eb2ec\n[B@3b6eb2ec\nnull\n\n\n1\n2\n3\n可以看到，对于软引用，在内存充足的时候执行GC，该引用执行的对象依然可以存活下来，但是内存不足时，会被回收掉，从而可以避免OOM。基于此特点，可以让软引用执行缓存空间，在内存充足时，可以正常访问缓存；如果不足时，则自动被回收掉。\n\n# 弱引用\n弱引用的特点是，尽管在内存充足的情况下，如果执行了GC，那么所关联的对象也会被回收掉，也可以看出来比软引用强度更低。如果要使用弱引用，需要使用WeakReference类来实现。\n\npublic class TestWeakReference {\n  static class Book {\n    @Override\n    protected void finalize() throws Throwable {\n      System.out.println("对象被回收");\n    }\n    @Override\n    public String toString() {\n      return "对象还存在";\n    }\n  }\n\n  public static void main(String[] args) {\n    WeakReference<Book> reference = new WeakReference<>(new Book());\n    System.out.println(reference.get());\n    System.gc();\n    System.out.println(reference.get());\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n执行上述代码，控制台输出：\n\n对象还存在\nnull\n对象被回收\n\n\n1\n2\n3\n可见，对象确实被回收了。另外，还可以看出，GC是异步执行的。\n\nThreadLocal，原子操作等都涉及到了弱引用。\n\n# 虚引用\n虚引用是四种引用中引用强度最弱的，如果要使用虚引用，需要使用PhantomReference这个类。当一个对象被回收时，虚拟机检测该对象是否持有虚引用，如果有，则将其加入ReferenceQueue中。另外，该类的get方法直接返回null，即对于虚引用，无法获取到虚引用所关联的对象的真实引用。\n\n# ReferenceQueue\nReferenceQueue可以和Reference抽象类的具体实现类结合使用。当引用对象所指向的内存空间被 GC 回收后，该引用对象则被追加到引用队列的末尾。',normalizedContent:'java中引用类型又分为四种类别（引用关系强度依次减弱）：\n\n * 强引用（strongly reference）\n * 软引用（softreference）\n * 弱引用（weakreference）\n * 虚引用（phantomreference）\n\n后面三种在java中都存在具体的类，都实现了java.lang.ref包下的reference抽象类。\n\n# 引用类型\n# 强引用\n强引用是传统的引用定义，大多数时候说的引用也是指的强应用。\n\nobject obj = new object();\n\n\n1\n如上代码，引用obj就是强引用。只要强引用关系存在，就算内存不足（发生oom），垃圾收集器也不会回收掉被引用的对象。\n\n# 软引用\n当内存不足时，就会把软引用关联的对象回收掉。如果要使用软引用，需要使用softreference类来实现。\n\nimport java.lang.ref.softreference;\n\npublic class testsoftreference {\n  public static void main(string[] args) {\n    softreference<byte[]> reference = new softreference<>(new byte[1024 * 1024 * 10]);\n    system.out.println(reference.get());\n    system.gc(); // 执行垃圾回收\n    system.out.println(reference.get());\n\n    byte[] array = new byte[10 * 1024 * 1024];\n\n    system.out.println(reference.get());\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n把上面程序的堆内存大小上限设置为20m（-xmx20m），执行程序，控制台打印结果为：\n\n[b@3b6eb2ec\n[b@3b6eb2ec\nnull\n\n\n1\n2\n3\n可以看到，对于软引用，在内存充足的时候执行gc，该引用执行的对象依然可以存活下来，但是内存不足时，会被回收掉，从而可以避免oom。基于此特点，可以让软引用执行缓存空间，在内存充足时，可以正常访问缓存；如果不足时，则自动被回收掉。\n\n# 弱引用\n弱引用的特点是，尽管在内存充足的情况下，如果执行了gc，那么所关联的对象也会被回收掉，也可以看出来比软引用强度更低。如果要使用弱引用，需要使用weakreference类来实现。\n\npublic class testweakreference {\n  static class book {\n    @override\n    protected void finalize() throws throwable {\n      system.out.println("对象被回收");\n    }\n    @override\n    public string tostring() {\n      return "对象还存在";\n    }\n  }\n\n  public static void main(string[] args) {\n    weakreference<book> reference = new weakreference<>(new book());\n    system.out.println(reference.get());\n    system.gc();\n    system.out.println(reference.get());\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n执行上述代码，控制台输出：\n\n对象还存在\nnull\n对象被回收\n\n\n1\n2\n3\n可见，对象确实被回收了。另外，还可以看出，gc是异步执行的。\n\nthreadlocal，原子操作等都涉及到了弱引用。\n\n# 虚引用\n虚引用是四种引用中引用强度最弱的，如果要使用虚引用，需要使用phantomreference这个类。当一个对象被回收时，虚拟机检测该对象是否持有虚引用，如果有，则将其加入referencequeue中。另外，该类的get方法直接返回null，即对于虚引用，无法获取到虚引用所关联的对象的真实引用。\n\n# referencequeue\nreferencequeue可以和reference抽象类的具体实现类结合使用。当引用对象所指向的内存空间被 gc 回收后，该引用对象则被追加到引用队列的末尾。',charsets:{cjk:!0}},{title:"Java中的方法句柄",frontmatter:{title:"Java中的方法句柄",categories:["编程语言"],tags:["Java"],date:"2021-01-28T19:50:56.000Z",permalink:"/pages/6ff86f/"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/01.%E5%9F%BA%E7%A1%80/21.Java%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E5%8F%A5%E6%9F%84.html",relativePath:"01.编程语言/01.Java/01.基础/21.Java中的方法句柄.md",key:"v-00ad09c8",path:"/pages/6ff86f/",headers:[{level:2,title:"相关概念",slug:"相关概念",normalizedTitle:"相关概念",charIndex:155},{level:2,title:"API使用",slug:"api使用",normalizedTitle:"api使用",charIndex:294},{level:3,title:"创建Lookup",slug:"创建lookup",normalizedTitle:"创建lookup",charIndex:302},{level:3,title:"创建MethodType",slug:"创建methodtype",normalizedTitle:"创建methodtype",charIndex:857},{level:3,title:"创建MethodHandle",slug:"创建methodhandle",normalizedTitle:"创建methodhandle",charIndex:244},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:4690}],excerpt:"<p>方法句柄是Java7中引入的，其作用与反射类似，可以在运行时访问类型信息。方法句柄是一个强类型的，能够被直接执行的引用。该引用可以指向静态方法，实例方法，也可以指向构造方法或者字段。当指向字段时，方法句柄实际上是指向包含字段访问字节码的虚构方法，语义上等价于目标字段的getter或者setter方法。</p>\n",lastUpdated:"2021-02-01",headersStr:"相关概念 API使用 创建Lookup 创建MethodType 创建MethodHandle 总结",content:'方法句柄是Java7中引入的，其作用与反射类似，可以在运行时访问类型信息。方法句柄是一个强类型的，能够被直接执行的引用。该引用可以指向静态方法，实例方法，也可以指向构造方法或者字段。当指向字段时，方法句柄实际上是指向包含字段访问字节码的虚构方法，语义上等价于目标字段的getter或者setter方法。\n\n# 相关概念\n首先来看一下与方法句柄相关的概念。\n\n * MethodHandle：方法句柄，通过它我们就可以动态访问类型信息了。\n * Lookup：方法句柄的创建工程，通过它可以创建MethodHandle实例。\n * MethodType：表示方法的参数和返回值类型。\n\n# API使用\n# 创建Lookup\nLookup是工具类MethodHandles的一个内部类，其没有public的构造方法，只能通过MethodHandles的工厂方法来创建。\n\nMethodHandles.Lookup lookup = MethodHandles.lookup();\nMethodHandles.Lookup publicLookup = MethodHandles.publicLookup();\nMethodHandles.Lookup privateLookupIn = MethodHandles.privateLookupIn(Reflect.class, lookup);\n\n\n1\n2\n3\n上面创建了三种不同类型的Lookup实例，MethodHandles.publicLookup()创建只能用于访问public字段或方法的Lookup实例；MethodHandles.lookup()创建的实例很强大，但是只对调用者内部具有私有访问权；MethodHandles.privateLookupIn()创建的实例最强大，对所有目标类都具有私有访问权。经过测试，就算是MethodHandles.privateLookupIn()也不能访问native方法（当然这访问也没有什么意义）。\n\n# 创建MethodType\n可以通过MethodType的静态方法methodType()来创建该类型的实例，该方法有很多重载版本。一般根据方法的返回值类型和参数类型列表来创建该类型的实例，其中将返回值类型作为该方法的第一个参数，后面紧接着的是参数类型列表。\n\nMethodType methodType = MethodType.methodType(boolean.class, boolean.class);\n\n\n1\n上面这个例子创建了一个能够表示返回值为boolean，且具有一个boolean参数的MethodType实例。\n\n# 创建MethodHandle\n根据MethodHandle表示的目标的不同，内部具有很多findXXX方法。\n\n * 构造器：通过Lookup实例的findConstructor()方法可以创建构造器的方法句柄，并可以调用该句柄的invoke()方法来获取实例对象（和new操作的效果一样）。\n   \n   MethodHandles.Lookup lookup = MethodHandles.lookup();\n   MethodType methodType = MethodType.methodType(void.class);\n   MethodHandle constructor = lookup.findConstructor(HandleTest.class, methodType);\n   Object o = constructor.invoke();\n   System.out.println(o.getClass().getSimpleName()); // HandleTest\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n * 实例方法：通过Lookup实例的findVirtual()方法可以创建实例方法的句柄，需要为该方法指定目标方法所在类，目标方法的名称，目标方法的类型信息（即MethodType类型的实例）。\n   \n   public class HandleTest {\n       private void hello(String msg) {\n           System.out.println(msg);\n       }\n   \n       /* 执行方法输出：Hello MethodHandle */\n       public static void main(String[] args) {\n           try {\n               MethodHandles.Lookup lookup = MethodHandles.lookup();\n               MethodType methodType = MethodType.methodType(void.class, String.class);\n               MethodHandle methodHandle = lookup.findVirtual(HandleTest.class,"hello",  methodType);\n               methodHandle.invoke(new HandleTest(), "Hello MethodHandle");\n           } catch (Throwable e) {\n               e.printStackTrace();\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   另外，还可以通过bindTo()方法将实例方法句柄绑定到某个实例上，在调用时就不用指定调用目标了。下面的关于字段的方法句柄是类似的。\n   \n   private void hello(String msg) {\n       System.out.println(msg);\n   }\n   public static void main(String[] args) {\n       try {\n           MethodHandles.Lookup lookup = MethodHandles.lookup();\n           MethodType methodType = MethodType.methodType(void.class, String.class);\n           HandleTest handleTest = new HandleTest();\n           MethodHandle methodHandle = lookup.findVirtual(HandleTest.class, "hello", methodType).bindTo(handleTest);\n           methodHandle.invoke("hello world!"); // 不用指定调用目标对象了。\n       } catch (Throwable e) {\n           e.printStackTrace();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   如果既没有绑定调用目标，又没有指定的话，那么调用句柄时会抛出WrongMethodTypeException。\n   \n   \n * 静态方法：通过Lookup的findStatic()方法来获取静态方法句柄，注意，可以获取到main方法，但是注意产生死循环，下面是一个错误用例：\n   \n   public static void main(String[] args) {\n       try {\n           MethodHandles.Lookup lookup = MethodHandles.lookup();\n           MethodType methodType = MethodType.methodType(void.class, String[].class);\n           MethodHandle methodHandle = lookup.findStatic(HandleTest.class,"main",  methodType);\n           String[] sarr = {};\n           methodHandle.invoke(sarr); // 产生死循环\n       } catch (Throwable e) {\n           e.printStackTrace();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n * 字段：可以通过调用Lookup的findSetter()和findGetter()来获取字段的setter和getter方法。下面只演示了实例字段，类字段是相似的。\n   \n   private Object o;\n   \n   public static void main(String[] args) {\n       try {\n           final MethodHandles.Lookup lookup = MethodHandles.lookup();\n           final MethodHandle setter = lookup.findSetter(HandleTest.class, "o", Object.class);\n           final HandleTest handleTest = new HandleTest();\n           setter.invoke(handleTest, "hello world!");\n           final MethodHandle getter = lookup.findGetter(HandleTest.class,"o",  Object.class);\n           System.out.println(getter.invoke(handleTest)); // hello world!\n       } catch (Throwable e) {\n           e.printStackTrace();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n\n# 总结\n方法句柄和反射等技术一样，离普通业务开发人员比较远，很少用得到。但是还是那句话，可以不用，但是必须要会。',normalizedContent:'方法句柄是java7中引入的，其作用与反射类似，可以在运行时访问类型信息。方法句柄是一个强类型的，能够被直接执行的引用。该引用可以指向静态方法，实例方法，也可以指向构造方法或者字段。当指向字段时，方法句柄实际上是指向包含字段访问字节码的虚构方法，语义上等价于目标字段的getter或者setter方法。\n\n# 相关概念\n首先来看一下与方法句柄相关的概念。\n\n * methodhandle：方法句柄，通过它我们就可以动态访问类型信息了。\n * lookup：方法句柄的创建工程，通过它可以创建methodhandle实例。\n * methodtype：表示方法的参数和返回值类型。\n\n# api使用\n# 创建lookup\nlookup是工具类methodhandles的一个内部类，其没有public的构造方法，只能通过methodhandles的工厂方法来创建。\n\nmethodhandles.lookup lookup = methodhandles.lookup();\nmethodhandles.lookup publiclookup = methodhandles.publiclookup();\nmethodhandles.lookup privatelookupin = methodhandles.privatelookupin(reflect.class, lookup);\n\n\n1\n2\n3\n上面创建了三种不同类型的lookup实例，methodhandles.publiclookup()创建只能用于访问public字段或方法的lookup实例；methodhandles.lookup()创建的实例很强大，但是只对调用者内部具有私有访问权；methodhandles.privatelookupin()创建的实例最强大，对所有目标类都具有私有访问权。经过测试，就算是methodhandles.privatelookupin()也不能访问native方法（当然这访问也没有什么意义）。\n\n# 创建methodtype\n可以通过methodtype的静态方法methodtype()来创建该类型的实例，该方法有很多重载版本。一般根据方法的返回值类型和参数类型列表来创建该类型的实例，其中将返回值类型作为该方法的第一个参数，后面紧接着的是参数类型列表。\n\nmethodtype methodtype = methodtype.methodtype(boolean.class, boolean.class);\n\n\n1\n上面这个例子创建了一个能够表示返回值为boolean，且具有一个boolean参数的methodtype实例。\n\n# 创建methodhandle\n根据methodhandle表示的目标的不同，内部具有很多findxxx方法。\n\n * 构造器：通过lookup实例的findconstructor()方法可以创建构造器的方法句柄，并可以调用该句柄的invoke()方法来获取实例对象（和new操作的效果一样）。\n   \n   methodhandles.lookup lookup = methodhandles.lookup();\n   methodtype methodtype = methodtype.methodtype(void.class);\n   methodhandle constructor = lookup.findconstructor(handletest.class, methodtype);\n   object o = constructor.invoke();\n   system.out.println(o.getclass().getsimplename()); // handletest\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n * 实例方法：通过lookup实例的findvirtual()方法可以创建实例方法的句柄，需要为该方法指定目标方法所在类，目标方法的名称，目标方法的类型信息（即methodtype类型的实例）。\n   \n   public class handletest {\n       private void hello(string msg) {\n           system.out.println(msg);\n       }\n   \n       /* 执行方法输出：hello methodhandle */\n       public static void main(string[] args) {\n           try {\n               methodhandles.lookup lookup = methodhandles.lookup();\n               methodtype methodtype = methodtype.methodtype(void.class, string.class);\n               methodhandle methodhandle = lookup.findvirtual(handletest.class,"hello",  methodtype);\n               methodhandle.invoke(new handletest(), "hello methodhandle");\n           } catch (throwable e) {\n               e.printstacktrace();\n           }\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   另外，还可以通过bindto()方法将实例方法句柄绑定到某个实例上，在调用时就不用指定调用目标了。下面的关于字段的方法句柄是类似的。\n   \n   private void hello(string msg) {\n       system.out.println(msg);\n   }\n   public static void main(string[] args) {\n       try {\n           methodhandles.lookup lookup = methodhandles.lookup();\n           methodtype methodtype = methodtype.methodtype(void.class, string.class);\n           handletest handletest = new handletest();\n           methodhandle methodhandle = lookup.findvirtual(handletest.class, "hello", methodtype).bindto(handletest);\n           methodhandle.invoke("hello world!"); // 不用指定调用目标对象了。\n       } catch (throwable e) {\n           e.printstacktrace();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   如果既没有绑定调用目标，又没有指定的话，那么调用句柄时会抛出wrongmethodtypeexception。\n   \n   \n * 静态方法：通过lookup的findstatic()方法来获取静态方法句柄，注意，可以获取到main方法，但是注意产生死循环，下面是一个错误用例：\n   \n   public static void main(string[] args) {\n       try {\n           methodhandles.lookup lookup = methodhandles.lookup();\n           methodtype methodtype = methodtype.methodtype(void.class, string[].class);\n           methodhandle methodhandle = lookup.findstatic(handletest.class,"main",  methodtype);\n           string[] sarr = {};\n           methodhandle.invoke(sarr); // 产生死循环\n       } catch (throwable e) {\n           e.printstacktrace();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n * 字段：可以通过调用lookup的findsetter()和findgetter()来获取字段的setter和getter方法。下面只演示了实例字段，类字段是相似的。\n   \n   private object o;\n   \n   public static void main(string[] args) {\n       try {\n           final methodhandles.lookup lookup = methodhandles.lookup();\n           final methodhandle setter = lookup.findsetter(handletest.class, "o", object.class);\n           final handletest handletest = new handletest();\n           setter.invoke(handletest, "hello world!");\n           final methodhandle getter = lookup.findgetter(handletest.class,"o",  object.class);\n           system.out.println(getter.invoke(handletest)); // hello world!\n       } catch (throwable e) {\n           e.printstacktrace();\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n\n# 总结\n方法句柄和反射等技术一样，离普通业务开发人员比较远，很少用得到。但是还是那句话，可以不用，但是必须要会。',charsets:{cjk:!0}},{title:"Java中的反射",frontmatter:{title:"Java中的反射",categories:["编程语言"],tags:["Java"],date:"2021-01-28T21:19:33.000Z",permalink:"/pages/0a8d09/"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/01.%E5%9F%BA%E7%A1%80/22.Java%E5%8F%8D%E5%B0%84.html",relativePath:"01.编程语言/01.Java/01.基础/22.Java反射.md",key:"v-3d1ebebc",path:"/pages/0a8d09/",headers:[{level:2,title:"使用反射",slug:"使用反射",normalizedTitle:"使用反射",charIndex:51},{level:3,title:"获取Class对象",slug:"获取class对象",normalizedTitle:"获取class对象",charIndex:178},{level:3,title:"创建实例",slug:"创建实例",normalizedTitle:"创建实例",charIndex:1097},{level:3,title:"获取字段",slug:"获取字段",normalizedTitle:"获取字段",charIndex:1107},{level:3,title:"获取方法",slug:"获取方法",normalizedTitle:"获取方法",charIndex:2445},{level:2,title:"Method",slug:"method",normalizedTitle:"method",charIndex:2466}],excerpt:"<p>反射是Java中很重要的机制，虽然业务代码中很少用反射，但是各种框架中几乎都用到了反射。我们虽然不怎么使用反射，但必须要知道反射是怎么实现的。</p>\n",lastUpdated:"2021-02-22",headersStr:"使用反射 获取Class对象 创建实例 获取字段 获取方法 Method",content:'反射是Java中很重要的机制，虽然业务代码中很少用反射，但是各种框架中几乎都用到了反射。我们虽然不怎么使用反射，但必须要知道反射是怎么实现的。\n\n# 使用反射\n我们写的Java类在经过编译后，会生成字节码文件存储在磁盘上。在运行时，当第一次用到该类时会加载类，类加载后在内存中存在一个对应的Class对象，该对象是类的运行时表示。\n\n所以反射的第一步，就要获取Class对象。\n\n# 获取Class对象\n * 通过数据类型的Class属性来获取：\n   \n   Class<Integer> clazz1 = int.class;\n   Class<Integer> clazz2 = Integer.class;\n   System.out.println(clazz1.getName()); // int\n   System.out.println(clazz2.getName()); // java.lang.Integer\n   Class<Void> clazz3 = void.class;\n   System.out.println(clazz3.getName()); // void\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   注意，基本类型也是可以获取的，但和包装类型的类不一样。\n   \n   \n * 对象的getClass()方法：\n   \n   Integer integer = 1;\n   Class<? extends Integer> clazz1 = integer.getClass();\n   System.out.println(clazz1.getName()); // java.lang.Integer\n   \n   \n   1\n   2\n   3\n   getClass()方法是在java.lang.Object类中定义的。\n   \n   \n * 通过静态方法Class.forName()：\n   \n   try {\n       Class<?> clazz1 = Class.forName("java.lang.Integer");\n       System.out.println(clazz1.getName());\n   } catch (ClassNotFoundException e) {\n       e.printStackTrace();\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n在获取了Class对象后，就可以反射创建实例，调用方法，获取字段等。\n\n# 创建实例\n * 通过Class对象的newInstance()方法：\n   \n   Class<Integer> clazz1 = Integer.class;\n   Integer integer;\n   try {\n       integer = clazz1.newInstance();\n   } catch (InstantiationException | IllegalAccessException e) {\n       e.printStackTrace();\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   该方法在Java 9中已经被标记@Deprecated了。\n   \n   \n * 通过Constructor来构造，首先需要获取Constructor实例。如果Class对象表示的是接口，基本类型，数组或void，那么下面两个方法返回的数组的长度为0。\n   \n    * getConstructors()：返回对应Class中的所有public构造器。\n    * getDeclaredConstructors()：返回对应Class中所有的构造器，不管访问权限。\n   \n   另外还有一些返回单个Constructor的方法，需要指定构造器的参数列表。如果Class是定义在非静态上下文中的内部类，那么形参列表的第一个参数表示外围类的Class对象。\n   \n    * getConstructor()：返回指定构造器，只能返回满足条件的public的构造器。\n    * getDeclaredConstructor()：返回指定构造器，不受访问权限的约束。\n   \n   另外还有一个相关方法：\n   \n    * getEnclosingConstructor()：如果Class是定义在某个构造器中的局部内部类或匿名内部类，那么返回这个外围构造器，如果不存在则返回null。\n   \n   获取到Constructor后，可以调用其newInstance()方法来创建实例。但是注意，如果该Constructor表示的是非静态上下文中内部类的构造器，那么第一个参数需要指定为外围类的实例对象。\n   \n   \n\n# 获取字段\n和构造器一样，获取字段也有两组方法，要么返回多个要么返回一个。先来看返回多个的情况：\n\n * getFields()：返回类或接口中public的所有字段（包括父类或父接口），如果没有public的，则返回空数组。\n   \n   \n * getDeclaredFields()：返回所有不包含继承的字段，但包含所有权限修饰符所修饰的字段。获取到的private字段可以直接访问。\n   \n   \n\n对于上面两个方法，如果Class表示数组，基本类型或void，那么返回空数组。\n\n另外还有获取单个字段的方法，含义和上面两个方法类似。\n\n * getField() ：根据名称，返回public字段（包含继承到的）。\n * getDeclaredField()：根据名称，返回不包含继承的字段（不受权限修饰符的影响）。\n\n# 获取方法\nClass类提供了返回一个或多个Method的方法。下面两个方法会返回Method数组：\n\n * getMethods()：如果Class对象表示普通类，返回所有public方法（包括继承到的）；如果Class对象表示数组，返回Object类中除了clone()方法的所有方法；如果Class对象表示接口，返回的Method数组中不包含Object类中的方法。如果接口中没有声明方法，且其继承链上的接口也没有声明方法，那么返回空数组；注意对于类总是会从Object类中继承方法，所以不会返回空数组。返回的方法中不包含"<init>"和"<cinit>"方法。\n * getDeclaredMethods()：和getMethods()类似，会返回直接声明的所有方法（即不受访问权限修饰符约束），但是不包含通过继承得到的方法。\n\n下面三个方法会返回单个Method对象：\n\n * getMethod()：根据方法名和参数列表获取public方法，如果参数列表指定为null，会被看作空数组。继承规则和getMethods()一样。\n * getDeclaredMethod()：和getMethod()类似，但是无法获取继承而来的方法，且不受权限修饰符的约束。\n * getEnclosingMethod()：如果当前Class对象表示方法中的本地或匿名内部类，那么返回包含该内部类的方法；对于其他情况，返回null。\n\n不管对于Constructor，Field还是Method，如果当前对这些对象各自所表示的目标不具有访问权限，那么可以通过调用各自的setAccessible(true)方法，可以绕过JVM的权限检查。\n\n笔记\n\n关于 setAccessible(true)是否破坏了private的安全性。首先，private不是用来保证字段或方法的安全性的，而是为了面向对象思想中的封装。private只是约束开发者遵守面向对象，而不是为了保证不能访问。\n\n# Method\nMethod有一个方法叫invoke，这是Java反射的精髓，用来实现方法的被动调用。我们在SpringBoot项目中写的handlerMethod就是这样被调用的。\n\n在JVM中有一个反射膨胀（inflation）机制：由于很多情况下反射只会调用一两次，所以JVM设置了一个名为sun.reflect.inflation.Threshold阈值，默认等于15。当反射方法的调用次数超过15次时，会使用ASM生成新的类，保证后面调用比native要快。当调用次数小于15时，直接用native的方式来调用，没有额外类的生成，校验，加载的开销。另外，还可以通过参数sun.reflect.noInflation来设置是否禁用反射膨胀机制，默认值为false。',normalizedContent:'反射是java中很重要的机制，虽然业务代码中很少用反射，但是各种框架中几乎都用到了反射。我们虽然不怎么使用反射，但必须要知道反射是怎么实现的。\n\n# 使用反射\n我们写的java类在经过编译后，会生成字节码文件存储在磁盘上。在运行时，当第一次用到该类时会加载类，类加载后在内存中存在一个对应的class对象，该对象是类的运行时表示。\n\n所以反射的第一步，就要获取class对象。\n\n# 获取class对象\n * 通过数据类型的class属性来获取：\n   \n   class<integer> clazz1 = int.class;\n   class<integer> clazz2 = integer.class;\n   system.out.println(clazz1.getname()); // int\n   system.out.println(clazz2.getname()); // java.lang.integer\n   class<void> clazz3 = void.class;\n   system.out.println(clazz3.getname()); // void\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   注意，基本类型也是可以获取的，但和包装类型的类不一样。\n   \n   \n * 对象的getclass()方法：\n   \n   integer integer = 1;\n   class<? extends integer> clazz1 = integer.getclass();\n   system.out.println(clazz1.getname()); // java.lang.integer\n   \n   \n   1\n   2\n   3\n   getclass()方法是在java.lang.object类中定义的。\n   \n   \n * 通过静态方法class.forname()：\n   \n   try {\n       class<?> clazz1 = class.forname("java.lang.integer");\n       system.out.println(clazz1.getname());\n   } catch (classnotfoundexception e) {\n       e.printstacktrace();\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n在获取了class对象后，就可以反射创建实例，调用方法，获取字段等。\n\n# 创建实例\n * 通过class对象的newinstance()方法：\n   \n   class<integer> clazz1 = integer.class;\n   integer integer;\n   try {\n       integer = clazz1.newinstance();\n   } catch (instantiationexception | illegalaccessexception e) {\n       e.printstacktrace();\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   该方法在java 9中已经被标记@deprecated了。\n   \n   \n * 通过constructor来构造，首先需要获取constructor实例。如果class对象表示的是接口，基本类型，数组或void，那么下面两个方法返回的数组的长度为0。\n   \n    * getconstructors()：返回对应class中的所有public构造器。\n    * getdeclaredconstructors()：返回对应class中所有的构造器，不管访问权限。\n   \n   另外还有一些返回单个constructor的方法，需要指定构造器的参数列表。如果class是定义在非静态上下文中的内部类，那么形参列表的第一个参数表示外围类的class对象。\n   \n    * getconstructor()：返回指定构造器，只能返回满足条件的public的构造器。\n    * getdeclaredconstructor()：返回指定构造器，不受访问权限的约束。\n   \n   另外还有一个相关方法：\n   \n    * getenclosingconstructor()：如果class是定义在某个构造器中的局部内部类或匿名内部类，那么返回这个外围构造器，如果不存在则返回null。\n   \n   获取到constructor后，可以调用其newinstance()方法来创建实例。但是注意，如果该constructor表示的是非静态上下文中内部类的构造器，那么第一个参数需要指定为外围类的实例对象。\n   \n   \n\n# 获取字段\n和构造器一样，获取字段也有两组方法，要么返回多个要么返回一个。先来看返回多个的情况：\n\n * getfields()：返回类或接口中public的所有字段（包括父类或父接口），如果没有public的，则返回空数组。\n   \n   \n * getdeclaredfields()：返回所有不包含继承的字段，但包含所有权限修饰符所修饰的字段。获取到的private字段可以直接访问。\n   \n   \n\n对于上面两个方法，如果class表示数组，基本类型或void，那么返回空数组。\n\n另外还有获取单个字段的方法，含义和上面两个方法类似。\n\n * getfield() ：根据名称，返回public字段（包含继承到的）。\n * getdeclaredfield()：根据名称，返回不包含继承的字段（不受权限修饰符的影响）。\n\n# 获取方法\nclass类提供了返回一个或多个method的方法。下面两个方法会返回method数组：\n\n * getmethods()：如果class对象表示普通类，返回所有public方法（包括继承到的）；如果class对象表示数组，返回object类中除了clone()方法的所有方法；如果class对象表示接口，返回的method数组中不包含object类中的方法。如果接口中没有声明方法，且其继承链上的接口也没有声明方法，那么返回空数组；注意对于类总是会从object类中继承方法，所以不会返回空数组。返回的方法中不包含"<init>"和"<cinit>"方法。\n * getdeclaredmethods()：和getmethods()类似，会返回直接声明的所有方法（即不受访问权限修饰符约束），但是不包含通过继承得到的方法。\n\n下面三个方法会返回单个method对象：\n\n * getmethod()：根据方法名和参数列表获取public方法，如果参数列表指定为null，会被看作空数组。继承规则和getmethods()一样。\n * getdeclaredmethod()：和getmethod()类似，但是无法获取继承而来的方法，且不受权限修饰符的约束。\n * getenclosingmethod()：如果当前class对象表示方法中的本地或匿名内部类，那么返回包含该内部类的方法；对于其他情况，返回null。\n\n不管对于constructor，field还是method，如果当前对这些对象各自所表示的目标不具有访问权限，那么可以通过调用各自的setaccessible(true)方法，可以绕过jvm的权限检查。\n\n笔记\n\n关于 setaccessible(true)是否破坏了private的安全性。首先，private不是用来保证字段或方法的安全性的，而是为了面向对象思想中的封装。private只是约束开发者遵守面向对象，而不是为了保证不能访问。\n\n# method\nmethod有一个方法叫invoke，这是java反射的精髓，用来实现方法的被动调用。我们在springboot项目中写的handlermethod就是这样被调用的。\n\n在jvm中有一个反射膨胀（inflation）机制：由于很多情况下反射只会调用一两次，所以jvm设置了一个名为sun.reflect.inflation.threshold阈值，默认等于15。当反射方法的调用次数超过15次时，会使用asm生成新的类，保证后面调用比native要快。当调用次数小于15时，直接用native的方式来调用，没有额外类的生成，校验，加载的开销。另外，还可以通过参数sun.reflect.noinflation来设置是否禁用反射膨胀机制，默认值为false。',charsets:{cjk:!0}},{title:"Java集合概述",frontmatter:{title:"Java集合概述",categories:["编程语言"],tags:["Java","Collection"],date:"2021-01-18T12:19:10.000Z",permalink:"/pages/3bb6cb/"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/02.%E9%9B%86%E5%90%88/01.Java%E9%9B%86%E5%90%88%E6%A6%82%E8%BF%B0.html",relativePath:"01.编程语言/01.Java/02.集合/01.Java集合概述.md",key:"v-3cc5bc10",path:"/pages/3bb6cb/",headers:[{level:2,title:"集合体系概览",slug:"集合体系概览",normalizedTitle:"集合体系概览",charIndex:135},{level:2,title:"基础数据结构",slug:"基础数据结构",normalizedTitle:"基础数据结构",charIndex:671},{level:3,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:699},{level:3,title:"链表",slug:"链表",normalizedTitle:"链表",charIndex:702},{level:2,title:"Java中的集合实现",slug:"java中的集合实现",normalizedTitle:"java中的集合实现",charIndex:1173},{level:3,title:"列表",slug:"列表",normalizedTitle:"列表",charIndex:414},{level:3,title:"队列和栈",slug:"队列和栈",normalizedTitle:"队列和栈",charIndex:747},{level:3,title:"映射",slug:"映射",normalizedTitle:"映射",charIndex:526},{level:3,title:"线程安全",slug:"线程安全",normalizedTitle:"线程安全",charIndex:2063}],excerpt:"<p>集合可以说是无处不在，我们日常的业务代码以及各种框架底层实现都大量使用集合。集合是存储和管理数据的工具，不同集合采用不同的数据结构，这些数据结构本身并无优劣之分，但是在特定场景下其效率将会产生天壤之别。所以，熟练掌握各种集合以及底层的实现原理对系统开发至关重要。</p>\n",lastUpdated:"2021-01-19",headersStr:"集合体系概览 基础数据结构 数组 链表 Java中的集合实现 列表 队列和栈 映射 线程安全",content:"集合可以说是无处不在，我们日常的业务代码以及各种框架底层实现都大量使用集合。集合是存储和管理数据的工具，不同集合采用不同的数据结构，这些数据结构本身并无优劣之分，但是在特定场景下其效率将会产生天壤之别。所以，熟练掌握各种集合以及底层的实现原理对系统开发至关重要。\n\n# 集合体系概览\nJava集合类库将接口与实现分离，接口定义了基本操作，实现决定采用哪种数据结构来存储数据以及如何实现这些操作。Java集合体系中的接口如下图所示：\n\n\n\n整个体系可以分为四部分：\n\n * RandomAccess：这个接口不包含任何方法，属于一个标记接口。可以用它来测试一个特定的集合是否支持高效的随机访问。\n   \n   \n * Iterator：迭代器，可以用来对iterable对象进行迭代和删除操作。\n   \n   \n * Collection：单列集合，存储某一类型的数据。一共有三个子接口分别是List，Set，Queue，分别表示列表，集合（不同于本文所属的广义上的集合，而是数学概念中的集合），队列。另外，以前Java提供了关于栈的实现，但是由于其效率不太高，已不推荐使用，可以使用双端队列来模拟。\n   \n   \n * Map：双列集合，存储键和值的映射关系。关于为什么Map不继承于Collection，Java官方给出的回答时Collection的这种单列关系无法表示Map中的双列关系，就算把map中的键值对封装为entry存入collection中，那么无法直接根据键获取到值，也无法直接根据键删除一对键值。\n   \n   \n\n# 基础数据结构\n其实根据存储特点，本质上就两种数据结构--数组和链表，其他比如队列，栈，树，图等都是基于数组和链表来实现的，数组和链表属于物理数据结构，而队列和栈等更像是逻辑数据结构。不管是Collection的各个子接口还是Map，都提供了基于不同数据结构的实现，这些不同的实现具有不同的使用场景。所以，在项目中要根据业务逻辑合理选择使用哪种容器，不要一股脑地使用ArrayList存储元素，HashMap存储映射关系。\n\n# 数组\n数组是两大基础数据结构之一。数组表示一组连续存储的数据，正是因为连续的特性，所以数组随机访问的效率很高，只需O(1)O(1)O(1)的时间复杂度；不过也正是因为连续，所以导致插入和删除操作效率不如链表，因为插入和删除会导致数组元素的移动，时间复杂度为O(n)O(n)O(n)。\n\n# 链表\n链表是两大基础数据结构之一。链表和数组是互补的，因为数组的优点刚好是链表的缺点，数组的缺点刚好是链表的优点。所以，链表不能随机访问，如果要访问某个元素，需要遍历整个链表，时间复杂度为O(n)O(n)O(n)；但是链表适合插入和删除，时间复杂度仅为O(1)O(1)O(1)。\n\n# Java中的集合实现\n\n\n# 列表\n列表存储了一组逻辑上并无关联的同一类型的数据，采用数组和链表实现均可。如ArrayList采用数组，LinkedList采用链表。\n\n# 队列和栈\n队列和栈主要用来实现某种特定策略，比如队列可以用来实现先进先出（FIFO），栈可以用来实现先进后出（LIFO）。队列和栈既可以使用数组也可以使用链表来实现。使用数组实现的队列有ArrayDeque，这是一个双端队列，可以用来实现栈；使用链表存储的队列有LinkedBlockingDeque，这是一个双端阻塞队列的实现。\n\n# 映射\n尽管数组可以实现随机访问，但是当访问元素之前必须要知道相应的下标，否则还是要像链表一样进行遍历操作，时间复杂度为O(n)O(n)O(n)。Map接口定义的根据键来获取值的操作可以让查找的时间复杂度降低至O(1)O(1)O(1)。映射可以使用hash和树来实现，注意映射并不等于hash，hash只是一种实现方式。一般像是HashMap， LinkedHashMap，TreeMap等，都综合运用了多种数据接口，如HashMap中就用了数组，链表，红黑树。\n\n提示\n\n关于树为什么能够实现映射以及为什么使用红黑树，这里说一下鄙人的拙见。映射的本质是提高查找的效率，而有些树也很有利于查找，比如二叉查找树，但是由于二叉查找树可能存在让查找线性化的问题（左斜树或右斜树），所以一般采用平衡二叉树来避免这个问题，平衡二叉树的定义是指左右子树的高度差不超过1，AVL树严格地实现了这样的要求。但是可能是实践实现，发现AVL树在使用中花费了大量时间用于维护自身的平衡结构，效率不太高（尽管可以优化）。红黑树算是一种非严格的平衡二叉树，对平衡的要求没有那么苛刻（当然也带来了复杂度），从而提高了查找的效率。\n\nB树或者B+树更多用于需要与磁盘打交道的场景，如数据库，目的是让整棵树变矮（减少与磁盘的交互次数）。关于B树或B+树与红黑树的查找效率对比可见下图，至于为什么Java设计团队要使用红黑树而不使用B树或B+树，这应该属于设计问题吧（其实也没什么不可以的）。\n\n\n\n# 线程安全\n上面的讨论中是假设在单线程中，如果在多线程场景中，对集合的操作可能会导致集合内部数据结构的紊乱，所以需要采取相应手段来确保集合操作的线程安全性。在很早以前，Java提供的集合框架都是线程安全的（如Vector，Stack，HashTable等），但也带来了很大的问题，因为这些集合中的方法都是由synchronized关键字修饰的，在早期该关键字的效率很低，而且经过实践发现大多数时候对于集合的操作还是在单线程中的，这样导致集合操作的效率很低了，这也是不推荐使用stack来实现栈，而使用Deque的实现类来代替的原因。\n\n但多线程的问题还是存在的，除了上述的遗留安全类集合，Java还提供了其他关于线程安全的集合类。整个Java中的线程安全集合可以分为三大类：\n\n * 遗留的安全集合：如HashTable，Vector等。\n * 修饰的安全集合：Collections类提供了很多以“Synchronized”开头的修饰类，如SynchronizedMap，SynchronizedList等。这些修饰类的内部利用装饰器模式通过synchronized关键字来保证对原线程不安全的集合操作的线程安全。虽然近年来synchronized关键字的性能得到了优化，但是还有更好的实现。\n * JUC并发包提供的安全集合： * Blocking类：大部分实现基于锁（显式锁），并提供用来阻塞线程的方法。\n    * CopyOnWrite类：修改时拷贝，适用于读多写少的场景，因为拷贝的代价较高。\n    * Concurrent类：内部很多操作采用CAS优化，利用分段锁来提供较高的吞吐量。但是这类容器具有弱一致性，即在遍历容器时，虽然遍历操作可以进行，但是遍历读取到的内容可能是旧数据；还有就是求大小的弱一致性，size方法返回的未必就是真正的size。\n   \n   \n\n提示\n\n对于线程不安全的集合，如果发送了并发修改，会抛出ConcurrentModificationException（可以参考另一篇文章），这种称为fail-fast机制，只是让遍历结束，而不能保证线程安全性。对于线程安全的集合并发访问不会导致失败，这种机制称为fail-safe。",normalizedContent:"集合可以说是无处不在，我们日常的业务代码以及各种框架底层实现都大量使用集合。集合是存储和管理数据的工具，不同集合采用不同的数据结构，这些数据结构本身并无优劣之分，但是在特定场景下其效率将会产生天壤之别。所以，熟练掌握各种集合以及底层的实现原理对系统开发至关重要。\n\n# 集合体系概览\njava集合类库将接口与实现分离，接口定义了基本操作，实现决定采用哪种数据结构来存储数据以及如何实现这些操作。java集合体系中的接口如下图所示：\n\n\n\n整个体系可以分为四部分：\n\n * randomaccess：这个接口不包含任何方法，属于一个标记接口。可以用它来测试一个特定的集合是否支持高效的随机访问。\n   \n   \n * iterator：迭代器，可以用来对iterable对象进行迭代和删除操作。\n   \n   \n * collection：单列集合，存储某一类型的数据。一共有三个子接口分别是list，set，queue，分别表示列表，集合（不同于本文所属的广义上的集合，而是数学概念中的集合），队列。另外，以前java提供了关于栈的实现，但是由于其效率不太高，已不推荐使用，可以使用双端队列来模拟。\n   \n   \n * map：双列集合，存储键和值的映射关系。关于为什么map不继承于collection，java官方给出的回答时collection的这种单列关系无法表示map中的双列关系，就算把map中的键值对封装为entry存入collection中，那么无法直接根据键获取到值，也无法直接根据键删除一对键值。\n   \n   \n\n# 基础数据结构\n其实根据存储特点，本质上就两种数据结构--数组和链表，其他比如队列，栈，树，图等都是基于数组和链表来实现的，数组和链表属于物理数据结构，而队列和栈等更像是逻辑数据结构。不管是collection的各个子接口还是map，都提供了基于不同数据结构的实现，这些不同的实现具有不同的使用场景。所以，在项目中要根据业务逻辑合理选择使用哪种容器，不要一股脑地使用arraylist存储元素，hashmap存储映射关系。\n\n# 数组\n数组是两大基础数据结构之一。数组表示一组连续存储的数据，正是因为连续的特性，所以数组随机访问的效率很高，只需o(1)o(1)o(1)的时间复杂度；不过也正是因为连续，所以导致插入和删除操作效率不如链表，因为插入和删除会导致数组元素的移动，时间复杂度为o(n)o(n)o(n)。\n\n# 链表\n链表是两大基础数据结构之一。链表和数组是互补的，因为数组的优点刚好是链表的缺点，数组的缺点刚好是链表的优点。所以，链表不能随机访问，如果要访问某个元素，需要遍历整个链表，时间复杂度为o(n)o(n)o(n)；但是链表适合插入和删除，时间复杂度仅为o(1)o(1)o(1)。\n\n# java中的集合实现\n\n\n# 列表\n列表存储了一组逻辑上并无关联的同一类型的数据，采用数组和链表实现均可。如arraylist采用数组，linkedlist采用链表。\n\n# 队列和栈\n队列和栈主要用来实现某种特定策略，比如队列可以用来实现先进先出（fifo），栈可以用来实现先进后出（lifo）。队列和栈既可以使用数组也可以使用链表来实现。使用数组实现的队列有arraydeque，这是一个双端队列，可以用来实现栈；使用链表存储的队列有linkedblockingdeque，这是一个双端阻塞队列的实现。\n\n# 映射\n尽管数组可以实现随机访问，但是当访问元素之前必须要知道相应的下标，否则还是要像链表一样进行遍历操作，时间复杂度为o(n)o(n)o(n)。map接口定义的根据键来获取值的操作可以让查找的时间复杂度降低至o(1)o(1)o(1)。映射可以使用hash和树来实现，注意映射并不等于hash，hash只是一种实现方式。一般像是hashmap， linkedhashmap，treemap等，都综合运用了多种数据接口，如hashmap中就用了数组，链表，红黑树。\n\n提示\n\n关于树为什么能够实现映射以及为什么使用红黑树，这里说一下鄙人的拙见。映射的本质是提高查找的效率，而有些树也很有利于查找，比如二叉查找树，但是由于二叉查找树可能存在让查找线性化的问题（左斜树或右斜树），所以一般采用平衡二叉树来避免这个问题，平衡二叉树的定义是指左右子树的高度差不超过1，avl树严格地实现了这样的要求。但是可能是实践实现，发现avl树在使用中花费了大量时间用于维护自身的平衡结构，效率不太高（尽管可以优化）。红黑树算是一种非严格的平衡二叉树，对平衡的要求没有那么苛刻（当然也带来了复杂度），从而提高了查找的效率。\n\nb树或者b+树更多用于需要与磁盘打交道的场景，如数据库，目的是让整棵树变矮（减少与磁盘的交互次数）。关于b树或b+树与红黑树的查找效率对比可见下图，至于为什么java设计团队要使用红黑树而不使用b树或b+树，这应该属于设计问题吧（其实也没什么不可以的）。\n\n\n\n# 线程安全\n上面的讨论中是假设在单线程中，如果在多线程场景中，对集合的操作可能会导致集合内部数据结构的紊乱，所以需要采取相应手段来确保集合操作的线程安全性。在很早以前，java提供的集合框架都是线程安全的（如vector，stack，hashtable等），但也带来了很大的问题，因为这些集合中的方法都是由synchronized关键字修饰的，在早期该关键字的效率很低，而且经过实践发现大多数时候对于集合的操作还是在单线程中的，这样导致集合操作的效率很低了，这也是不推荐使用stack来实现栈，而使用deque的实现类来代替的原因。\n\n但多线程的问题还是存在的，除了上述的遗留安全类集合，java还提供了其他关于线程安全的集合类。整个java中的线程安全集合可以分为三大类：\n\n * 遗留的安全集合：如hashtable，vector等。\n * 修饰的安全集合：collections类提供了很多以“synchronized”开头的修饰类，如synchronizedmap，synchronizedlist等。这些修饰类的内部利用装饰器模式通过synchronized关键字来保证对原线程不安全的集合操作的线程安全。虽然近年来synchronized关键字的性能得到了优化，但是还有更好的实现。\n * juc并发包提供的安全集合： * blocking类：大部分实现基于锁（显式锁），并提供用来阻塞线程的方法。\n    * copyonwrite类：修改时拷贝，适用于读多写少的场景，因为拷贝的代价较高。\n    * concurrent类：内部很多操作采用cas优化，利用分段锁来提供较高的吞吐量。但是这类容器具有弱一致性，即在遍历容器时，虽然遍历操作可以进行，但是遍历读取到的内容可能是旧数据；还有就是求大小的弱一致性，size方法返回的未必就是真正的size。\n   \n   \n\n提示\n\n对于线程不安全的集合，如果发送了并发修改，会抛出concurrentmodificationexception（可以参考另一篇文章），这种称为fail-fast机制，只是让遍历结束，而不能保证线程安全性。对于线程安全的集合并发访问不会导致失败，这种机制称为fail-safe。",charsets:{cjk:!0}},{title:"Java集合中的ConcurrentModificationException",frontmatter:{title:"Java集合中的ConcurrentModificationException",categories:["编程语言"],tags:["Java","Collection"],date:"2020-11-14T00:00:00.000Z",permalink:"/pages/574b5f/"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/02.%E9%9B%86%E5%90%88/100.Java%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84ConcurrentModificationException.html",relativePath:"01.编程语言/01.Java/02.集合/100.Java集合中的ConcurrentModificationException.md",key:"v-2ae52180",path:"/pages/574b5f/",headers:[{level:2,title:"什么是ConcurrentModificationException",slug:"什么是concurrentmodificationexception",normalizedTitle:"什么是concurrentmodificationexception",charIndex:2},{level:2,title:"快速失败机制",slug:"快速失败机制",normalizedTitle:"快速失败机制",charIndex:194},{level:2,title:"迭代器",slug:"迭代器",normalizedTitle:"迭代器",charIndex:201},{level:2,title:"for-each循环与remove操作",slug:"for-each循环与remove操作",normalizedTitle:"for-each循环与remove操作",charIndex:1663},{level:2,title:"如何安全地进行remove？",slug:"如何安全地进行remove？",normalizedTitle:"如何安全地进行remove？",charIndex:2463},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:3158}],excerpt:'<h2 id="什么是concurrentmodificationexception"><a class="header-anchor" href="#什么是concurrentmodificationexception">#</a> 什么是ConcurrentModificationException</h2>\n<p><strong>ConcurrentModificationException</strong>是Java中的一个单独的异常类，当方法检测到对象被并发修改且该修改操作不允许时，就会抛出这类异常。但是该异常并非一定指的是多个线程对某个对象进行并发修改，如果在某个线程内对某一方法发起一连串的调用，也可能抛出该异常。例如，如果某个线程正在修改正在被具有快速失败机制的迭代器进行迭代的集合，那么迭代器就会抛出该异常。</p>\n',lastUpdated:"2021-01-18",headersStr:"什么是ConcurrentModificationException 快速失败机制 迭代器 for-each循环与remove操作 如何安全地进行remove？ 参考",content:"# 什么是ConcurrentModificationException\nConcurrentModificationException是Java中的一个单独的异常类，当方法检测到对象被并发修改且该修改操作不允许时，就会抛出这类异常。但是该异常并非一定指的是多个线程对某个对象进行并发修改，如果在某个线程内对某一方法发起一连串的调用，也可能抛出该异常。例如，如果某个线程正在修改正在被具有快速失败机制的迭代器进行迭代的集合，那么迭代器就会抛出该异常。\n\n# 快速失败机制\n快速失败机制（fail-fast）是Java集合迭代器采用的一种错误检测机制,当迭代器在执行迭代操作时，如果检测到集合发送了结构性变化，那么会中止迭代操作，并抛出ConcurrentModificationException异常。注意是结构性的修改，包括添加和删除，而不是简单更改集合元素的值。\n\n# 迭代器\n这里以java.util.ArrayList为例。ArrayList内部有两类迭代器，Itr和ListItr，都以内部类存在。前者实现了Iterator接口，后者实现了ListIterator（继承了Iterator）接口。ListItr的功能更丰富，可以实现向前遍历等。本文以Itr为例进行说明。 在探究快速失败机制之前，先看一下迭代器的结构。Itr内部有三个属性：\n\nint cursor;       // 下一个被返回的元素的下标\nint lastRet = -1; // 上次被返回元素的下标，如果没返回过，则为-1\nint expectedModCount = modCount;\n\n\n1\n2\n3\nmodCount是在java.util.AbstractList中定义的属性。Itr内部关于迭代的两个方法：\n\npublic boolean hasNext() {\n\treturn cursor != size;\n}\n\npublic E next() {\n\tcheckForComodification();\n\tint i = cursor;\n\tif (i >= size)\n\t\tthrow new NoSuchElementException();\n\tObject[] elementData = ArrayList.this.elementData;\n\tif (i >= elementData.length)\n\t\tthrow new ConcurrentModificationException();\n\tcursor = i + 1;\n\treturn (E) elementData[lastRet = i];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n注意到，在next方法中，第一行调用了一个方法，该方法的目的就是检测并发修改异常的，其内部代码为：\n\nfinal void checkForComodification() {\n\tif (modCount != expectedModCount)\n\t\tthrow new ConcurrentModificationException();\n}\n\n\n1\n2\n3\n4\n逻辑也很简单，比较modCount和expectedModCount是否相等。记住，modCount是与ArrayList对象的属性，而expectedModCount是Itr迭代器对象的属性。在迭代器创建时，两者是相等的，但是随着ArrayList对象的结构性变化，只有modCount才会变化，比如在add方法中：\n\npublic boolean add(E e) {\n\tmodCount++;\n\tadd(e, elementData, size);\n\treturn true;\n}\n\n\n1\n2\n3\n4\n5\n通过以上分析，可以知道ConcurrentModificationException是如何产生的了，这也是快速失败机制在ArrayList中的实现。\n\n# for-each循环与remove操作\n很多教程或书籍都说不要在for-each方法中调用ArrayList的remove方法，为什么呢？比如对于下面这段代码：\n\nfor(Integer i : list) {\n\tlist.remove(i);\n}\n\n\n1\n2\n3\n毫无疑问，引发了并发修改异常。利用jad反编译工具，得到代码如下：\n\npublic static void main(String args[])\n{\n    ArrayList list = new ArrayList(Arrays.asList(new Integer[] {\n        Integer.valueOf(1), Integer.valueOf(2), Integer.valueOf(3), Integer.valueOf(4), Integer.valueOf(5)\n    }));\n    Integer i;\n    for(Iterator iterator = list.iterator(); iterator.hasNext(); list.remove(i))\n        i = (Integer)iterator.next();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n原来编译器将for-each转为了迭代器实现，另外，在使用迭代器迭代的时候，直接调用ArrayList的remove方法是导致异常的最直接原因。该remove方法还调用了内部一个名为fastRemove的方法，在该方法内部对modCount进行了自增操作，注意，是仅对modCount进行操作，然后迭代器调用next方法并进行快速失败检查时发现expectedModCount与modCount不一致，就抛出异常了。 另外，通过反编译后的代码可知，异常是在遍历完第一个元素后，遍历第二个元素前抛出的。\n\n# 如何安全地进行remove？\n具体的方法就是使用迭代器的remove方法,其源码为：\n\npublic void remove() {\n\tif (lastRet < 0)\n\t\tthrow new IllegalStateException();\n\tcheckForComodification();\n\n\ttry {\n\t\tArrayList.this.remove(lastRet);\n\t\tcursor = lastRet;\n\t\tlastRet = -1;\n\t\texpectedModCount = modCount;\n\t} catch (IndexOutOfBoundsException ex) {\n\t\tthrow new ConcurrentModificationException();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n这里可以发现，其实质性的操作也是调用ArrayList对象的remove方法来实现的。最为关键的地方在于expectedModCount = modCount;,这里同步了两者的值，从而避免了并发修改异常。 这里注意一点，就是在调用迭代器的remove方法时，需要先调用迭代器的next方法，原因在迭代器的remove方法的第一、二行。 这样虽然避免了并发修改异常，但是也不是万事大吉的。由于ArrayList本身就不是线程安全的，这里就只考虑单线程的情况下。比如对ArrayList创建了迭代器对象，但是在迭代之前，就已经发生了结构性变化，那么后面无论怎么使用迭代器进行遍历，也有可能出现并发修改异常^1。\n\n# 参考\n * Java API DOCs (ConcurrentModificationException)\n * GeeksForGeeks: fail-fast-fail-safe-iterators-java\n * java.util.ArrayList源码^2",normalizedContent:"# 什么是concurrentmodificationexception\nconcurrentmodificationexception是java中的一个单独的异常类，当方法检测到对象被并发修改且该修改操作不允许时，就会抛出这类异常。但是该异常并非一定指的是多个线程对某个对象进行并发修改，如果在某个线程内对某一方法发起一连串的调用，也可能抛出该异常。例如，如果某个线程正在修改正在被具有快速失败机制的迭代器进行迭代的集合，那么迭代器就会抛出该异常。\n\n# 快速失败机制\n快速失败机制（fail-fast）是java集合迭代器采用的一种错误检测机制,当迭代器在执行迭代操作时，如果检测到集合发送了结构性变化，那么会中止迭代操作，并抛出concurrentmodificationexception异常。注意是结构性的修改，包括添加和删除，而不是简单更改集合元素的值。\n\n# 迭代器\n这里以java.util.arraylist为例。arraylist内部有两类迭代器，itr和listitr，都以内部类存在。前者实现了iterator接口，后者实现了listiterator（继承了iterator）接口。listitr的功能更丰富，可以实现向前遍历等。本文以itr为例进行说明。 在探究快速失败机制之前，先看一下迭代器的结构。itr内部有三个属性：\n\nint cursor;       // 下一个被返回的元素的下标\nint lastret = -1; // 上次被返回元素的下标，如果没返回过，则为-1\nint expectedmodcount = modcount;\n\n\n1\n2\n3\nmodcount是在java.util.abstractlist中定义的属性。itr内部关于迭代的两个方法：\n\npublic boolean hasnext() {\n\treturn cursor != size;\n}\n\npublic e next() {\n\tcheckforcomodification();\n\tint i = cursor;\n\tif (i >= size)\n\t\tthrow new nosuchelementexception();\n\tobject[] elementdata = arraylist.this.elementdata;\n\tif (i >= elementdata.length)\n\t\tthrow new concurrentmodificationexception();\n\tcursor = i + 1;\n\treturn (e) elementdata[lastret = i];\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n注意到，在next方法中，第一行调用了一个方法，该方法的目的就是检测并发修改异常的，其内部代码为：\n\nfinal void checkforcomodification() {\n\tif (modcount != expectedmodcount)\n\t\tthrow new concurrentmodificationexception();\n}\n\n\n1\n2\n3\n4\n逻辑也很简单，比较modcount和expectedmodcount是否相等。记住，modcount是与arraylist对象的属性，而expectedmodcount是itr迭代器对象的属性。在迭代器创建时，两者是相等的，但是随着arraylist对象的结构性变化，只有modcount才会变化，比如在add方法中：\n\npublic boolean add(e e) {\n\tmodcount++;\n\tadd(e, elementdata, size);\n\treturn true;\n}\n\n\n1\n2\n3\n4\n5\n通过以上分析，可以知道concurrentmodificationexception是如何产生的了，这也是快速失败机制在arraylist中的实现。\n\n# for-each循环与remove操作\n很多教程或书籍都说不要在for-each方法中调用arraylist的remove方法，为什么呢？比如对于下面这段代码：\n\nfor(integer i : list) {\n\tlist.remove(i);\n}\n\n\n1\n2\n3\n毫无疑问，引发了并发修改异常。利用jad反编译工具，得到代码如下：\n\npublic static void main(string args[])\n{\n    arraylist list = new arraylist(arrays.aslist(new integer[] {\n        integer.valueof(1), integer.valueof(2), integer.valueof(3), integer.valueof(4), integer.valueof(5)\n    }));\n    integer i;\n    for(iterator iterator = list.iterator(); iterator.hasnext(); list.remove(i))\n        i = (integer)iterator.next();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n原来编译器将for-each转为了迭代器实现，另外，在使用迭代器迭代的时候，直接调用arraylist的remove方法是导致异常的最直接原因。该remove方法还调用了内部一个名为fastremove的方法，在该方法内部对modcount进行了自增操作，注意，是仅对modcount进行操作，然后迭代器调用next方法并进行快速失败检查时发现expectedmodcount与modcount不一致，就抛出异常了。 另外，通过反编译后的代码可知，异常是在遍历完第一个元素后，遍历第二个元素前抛出的。\n\n# 如何安全地进行remove？\n具体的方法就是使用迭代器的remove方法,其源码为：\n\npublic void remove() {\n\tif (lastret < 0)\n\t\tthrow new illegalstateexception();\n\tcheckforcomodification();\n\n\ttry {\n\t\tarraylist.this.remove(lastret);\n\t\tcursor = lastret;\n\t\tlastret = -1;\n\t\texpectedmodcount = modcount;\n\t} catch (indexoutofboundsexception ex) {\n\t\tthrow new concurrentmodificationexception();\n\t}\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n这里可以发现，其实质性的操作也是调用arraylist对象的remove方法来实现的。最为关键的地方在于expectedmodcount = modcount;,这里同步了两者的值，从而避免了并发修改异常。 这里注意一点，就是在调用迭代器的remove方法时，需要先调用迭代器的next方法，原因在迭代器的remove方法的第一、二行。 这样虽然避免了并发修改异常，但是也不是万事大吉的。由于arraylist本身就不是线程安全的，这里就只考虑单线程的情况下。比如对arraylist创建了迭代器对象，但是在迭代之前，就已经发生了结构性变化，那么后面无论怎么使用迭代器进行遍历，也有可能出现并发修改异常^1。\n\n# 参考\n * java api docs (concurrentmodificationexception)\n * geeksforgeeks: fail-fast-fail-safe-iterators-java\n * java.util.arraylist源码^2",charsets:{cjk:!0}},{title:"Java中的volatile关键字",frontmatter:{title:"Java中的volatile关键字",categories:["编程语言"],tags:["Java"],date:"2021-01-23T14:26:33.000Z",permalink:"/pages/d1fc66/"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/03.%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/01.volatile%E5%85%B3%E9%94%AE%E5%AD%97.html",relativePath:"01.编程语言/01.Java/03.线程与并发/01.volatile关键字.md",key:"v-4e171c5f",path:"/pages/d1fc66/",headers:[{level:2,title:"两个问题",slug:"两个问题",normalizedTitle:"两个问题",charIndex:205},{level:2,title:"缓存一致性",slug:"缓存一致性",normalizedTitle:"缓存一致性",charIndex:173},{level:2,title:"Store Buffers",slug:"store-buffers",normalizedTitle:"store buffers",charIndex:1899},{level:2,title:"lock指令前缀",slug:"lock指令前缀",normalizedTitle:"lock指令前缀",charIndex:2563},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:3142}],excerpt:"<p>关于Java中的<code>volatile</code>关键字，我个人认为是Java中最难理解的关键字了（太难了，没有之一 ）。笔者曾经因为不能很好理解该关键字，放弃了Java转而去学C，但是发现C里面也有<code>volatile</code>这个关键字（当时我的内心是崩溃的 😭）。很多资料也在说该关键字，但仍然没有解决笔者的疑惑，比如该关键字到底是怎么让多个CPU之间保证了可见性的？与缓存一致性协议又是怎样的关系？本文就来一一解释这些问题。</p>\n",lastUpdated:"2021-01-23",headersStr:"两个问题 缓存一致性 Store Buffers lock指令前缀 总结",content:'关于Java中的volatile关键字，我个人认为是Java中最难理解的关键字了（太难了，没有之一 ）。笔者曾经因为不能很好理解该关键字，放弃了Java转而去学C，但是发现C里面也有volatile这个关键字（当时我的内心是崩溃的 😭）。很多资料也在说该关键字，但仍然没有解决笔者的疑惑，比如该关键字到底是怎么让多个CPU之间保证了可见性的？与缓存一致性协议又是怎样的关系？本文就来一一解释这些问题。\n\n# 两个问题\n在分析volatile的原理之前，先来看一下两个经典的问题。\n\nprivate static boolean isDone;\n// private static volatile boolean isDone;\npublic static void main(String[] args) throws InterruptedException {\n  new Thread(() -> {\n    try {\n      Thread.sleep(3000);\n      isDone = true;\n      System.out.println("Thread A is done!");\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n  }, "A").start();\n  new Thread(() -> {\n    while (!isDone);\n    System.out.println("Thread B is done!");\n  }, "B").start();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n上面是第一段程序，运行后会发现线程B不会结束。但是如果给isDone加上volatile关键字，一切就正常了。这种问题被称为线程之间的可见性，也就是说volatile关键字保证了线程之间的可见性。\n\n下面再来看一段程序：\n\nprivate static Object singleton;\n// private static volatile Object singleton;\npublic static Object getObject() {\n  if (singleton == null) {\n    synchronized (Object.class) {\n      if (singleton == null) {\n        singleton = new Object();\n      }\n    }\n  }\n  return singleton;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n上面是经典的实现单例模式的方法，被称为DCL（double check lock）。但是直接使用上面的实现，可能会抛出NullPointerException。但是如果给singleton加上volatile关键字，一切就正常了。这种问题被称为指令重排序问题，也就是说volatile关键字保证了对被修饰的目标进行操作的执令不会被重排序。\n\n笔记\n\n关于DCL为什么会导致空指针异常的，这里做一个简单的补充。对于new操作，大致需要下面三个步骤：\n\n * 分配新对象内存。\n * 调用类构造器初始化成员变量。\n * 将内存分配到的地址写入对象引用中。\n\n所以，一个对象的创建并不是原子操作，完全有可能上面第三步在第二步之前执行，从而导致异常。\n\n# 缓存一致性\n现如今很多处理器都是多核的，每个CPU都有自己的私有缓存，访问同一内存的不同线程在不同的CPU中运行是很正常的事情，但是这样会导致一个问题，就是同一内存的数据在不同缓存中不一致了。为了解决这个问题，硬件工程师们引入了缓存一致性协议，这些协议规定了多CPU之间如何保证缓存的一致性。可以参考笔者之前写的关于CPU缓存的系列博客：\n\n * CPU缓存的基础架构\n   \n   \n * CPU缓存一致性协议概述\n   \n   \n * CPU缓存一致性协议之MSI\n   \n   \n * CPU缓存一致性协议之MESI\n   \n   \n\n注意，MESI协议只是缓存一致性协议中的一种，目前由Intel公司广泛使用。另外，还有其他笔者尚未提及到的缓存一致性协议，如广泛被AMD公司采用的MOESI协议。这些协议的名称中每个字母都表示缓存行的一种状态，一般状态越多，效率越高，但是实现难度越大。\n\n# Store Buffers\n缓存一致性协议能够保证多CPU之间的缓存一致，但是为什么说volatile具有保证线程可见性的功能呢？也就是说既然有缓存一致性协议，那么为什么还需要volatile来保证一致性。\n\n关于这个问题，也是困惑了笔者很久，究其原因还是对硬件细节了解不够。\n\n在CPU缓存一致性协议之MESI这篇文章末尾讲到，MESI协议规定在发出“read invalidate”或“validate”消息后只有收到其他CPU的“acknowledge”消息后才能执行写操作。但是在接收到“acknowledge”消息前后写入并不会影响最终写入的值，所以硬件工程师们为了提高缓存一致性协议的效率，又在CPU和其私有缓存之间引入了一个部件，叫做Store Buffers（又叫Write Buffers），关于这部分可以参考笔者之前的文章：CPU中的Store Buffers。\n\n引入Store Buffers后，对缓存的写操作不会因为缓存一致性消息的发送与接收而阻塞。但是这可能会导致一个问题，就是位于前面的指令的结果被写入了Store Buffers中，而位于后面的指令的结果被直接写入了缓存中，缓存一致性协议只能确保缓存中的一致，不能管理Store Buffers。所以，在其他CPU看来，该CPU对这两条指令进行了重排序，而这种重排序可能导致线程之间的可见性问题。而为了解决这种问题，从代码层面而言，就需要使用volatile，但是在CPU层面肯定不是volatile来解决问题的，具体细节请继续参考下文。\n\n# lock指令前缀\n关于这部分，笔者直接引用从其他资料中查阅到的结果。\n\n对于被volatile所修饰的变量执行写操作，会在该写操作后执行下面一句汇编代码：\n\nlock addl $0x0,(%esp)\n\n\n1\n重点在于这个lock前缀，这个指令前缀的作用类似于内存屏障，内存屏障会标记Store Buffers中的变量，后序的写操作都会写入Store Buffers中，而不会直接写入缓存行中，当刷新Store Buffers时，也是先刷新先写入的（FIFO特性）。这样就保证了其他CPU先看到的结果一定是先执行的，从而避免了因重排序带来的可见性问题。\n\n另外，lock前缀还能够让一些非原子指令具有原子性，如HotSpot中关于CAS的实现就利用了该前缀。在早期CPU中还没有缓存时，那时lock前缀会锁住总线，在当前指令结束之前其他CPU不能访问内存。当然，这种粗暴的方式效率肯定很低，后来的lock只会锁住其他CPU对于所锁住的内存地址的访问（无法发起缓存一致性消息）。\n\n既然lock前缀能够让所修饰的指令变得具有原子性，而HotSpot中volatile也是基于lock前缀来实现的，那为什么说volatile不能保证缓存一致性呢？请注意，HotSpot只是在对变量修改指令的后面插入了一条lock指令，而不是让变量修改指令变得具有原子性。\n\n# 总结\n本文只是对CPU层面的指令重排序做了介绍，其实编译器还可能进行指令的重排序。Java内存模型中有一个先行发生原则（Happens-Before），该原则规定了一些操作必须在哪些操作之后进行，Java编译器不会对这些操作进行重排，但是对于其他的操作都是未定义的。volatile变量规则属于先行发生原则中的一种，所以Java编译器不会对由volatile修饰的变量进行过度优化。',normalizedContent:'关于java中的volatile关键字，我个人认为是java中最难理解的关键字了（太难了，没有之一 ）。笔者曾经因为不能很好理解该关键字，放弃了java转而去学c，但是发现c里面也有volatile这个关键字（当时我的内心是崩溃的 😭）。很多资料也在说该关键字，但仍然没有解决笔者的疑惑，比如该关键字到底是怎么让多个cpu之间保证了可见性的？与缓存一致性协议又是怎样的关系？本文就来一一解释这些问题。\n\n# 两个问题\n在分析volatile的原理之前，先来看一下两个经典的问题。\n\nprivate static boolean isdone;\n// private static volatile boolean isdone;\npublic static void main(string[] args) throws interruptedexception {\n  new thread(() -> {\n    try {\n      thread.sleep(3000);\n      isdone = true;\n      system.out.println("thread a is done!");\n    } catch (interruptedexception e) {\n      e.printstacktrace();\n    }\n  }, "a").start();\n  new thread(() -> {\n    while (!isdone);\n    system.out.println("thread b is done!");\n  }, "b").start();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n上面是第一段程序，运行后会发现线程b不会结束。但是如果给isdone加上volatile关键字，一切就正常了。这种问题被称为线程之间的可见性，也就是说volatile关键字保证了线程之间的可见性。\n\n下面再来看一段程序：\n\nprivate static object singleton;\n// private static volatile object singleton;\npublic static object getobject() {\n  if (singleton == null) {\n    synchronized (object.class) {\n      if (singleton == null) {\n        singleton = new object();\n      }\n    }\n  }\n  return singleton;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n上面是经典的实现单例模式的方法，被称为dcl（double check lock）。但是直接使用上面的实现，可能会抛出nullpointerexception。但是如果给singleton加上volatile关键字，一切就正常了。这种问题被称为指令重排序问题，也就是说volatile关键字保证了对被修饰的目标进行操作的执令不会被重排序。\n\n笔记\n\n关于dcl为什么会导致空指针异常的，这里做一个简单的补充。对于new操作，大致需要下面三个步骤：\n\n * 分配新对象内存。\n * 调用类构造器初始化成员变量。\n * 将内存分配到的地址写入对象引用中。\n\n所以，一个对象的创建并不是原子操作，完全有可能上面第三步在第二步之前执行，从而导致异常。\n\n# 缓存一致性\n现如今很多处理器都是多核的，每个cpu都有自己的私有缓存，访问同一内存的不同线程在不同的cpu中运行是很正常的事情，但是这样会导致一个问题，就是同一内存的数据在不同缓存中不一致了。为了解决这个问题，硬件工程师们引入了缓存一致性协议，这些协议规定了多cpu之间如何保证缓存的一致性。可以参考笔者之前写的关于cpu缓存的系列博客：\n\n * cpu缓存的基础架构\n   \n   \n * cpu缓存一致性协议概述\n   \n   \n * cpu缓存一致性协议之msi\n   \n   \n * cpu缓存一致性协议之mesi\n   \n   \n\n注意，mesi协议只是缓存一致性协议中的一种，目前由intel公司广泛使用。另外，还有其他笔者尚未提及到的缓存一致性协议，如广泛被amd公司采用的moesi协议。这些协议的名称中每个字母都表示缓存行的一种状态，一般状态越多，效率越高，但是实现难度越大。\n\n# store buffers\n缓存一致性协议能够保证多cpu之间的缓存一致，但是为什么说volatile具有保证线程可见性的功能呢？也就是说既然有缓存一致性协议，那么为什么还需要volatile来保证一致性。\n\n关于这个问题，也是困惑了笔者很久，究其原因还是对硬件细节了解不够。\n\n在cpu缓存一致性协议之mesi这篇文章末尾讲到，mesi协议规定在发出“read invalidate”或“validate”消息后只有收到其他cpu的“acknowledge”消息后才能执行写操作。但是在接收到“acknowledge”消息前后写入并不会影响最终写入的值，所以硬件工程师们为了提高缓存一致性协议的效率，又在cpu和其私有缓存之间引入了一个部件，叫做store buffers（又叫write buffers），关于这部分可以参考笔者之前的文章：cpu中的store buffers。\n\n引入store buffers后，对缓存的写操作不会因为缓存一致性消息的发送与接收而阻塞。但是这可能会导致一个问题，就是位于前面的指令的结果被写入了store buffers中，而位于后面的指令的结果被直接写入了缓存中，缓存一致性协议只能确保缓存中的一致，不能管理store buffers。所以，在其他cpu看来，该cpu对这两条指令进行了重排序，而这种重排序可能导致线程之间的可见性问题。而为了解决这种问题，从代码层面而言，就需要使用volatile，但是在cpu层面肯定不是volatile来解决问题的，具体细节请继续参考下文。\n\n# lock指令前缀\n关于这部分，笔者直接引用从其他资料中查阅到的结果。\n\n对于被volatile所修饰的变量执行写操作，会在该写操作后执行下面一句汇编代码：\n\nlock addl $0x0,(%esp)\n\n\n1\n重点在于这个lock前缀，这个指令前缀的作用类似于内存屏障，内存屏障会标记store buffers中的变量，后序的写操作都会写入store buffers中，而不会直接写入缓存行中，当刷新store buffers时，也是先刷新先写入的（fifo特性）。这样就保证了其他cpu先看到的结果一定是先执行的，从而避免了因重排序带来的可见性问题。\n\n另外，lock前缀还能够让一些非原子指令具有原子性，如hotspot中关于cas的实现就利用了该前缀。在早期cpu中还没有缓存时，那时lock前缀会锁住总线，在当前指令结束之前其他cpu不能访问内存。当然，这种粗暴的方式效率肯定很低，后来的lock只会锁住其他cpu对于所锁住的内存地址的访问（无法发起缓存一致性消息）。\n\n既然lock前缀能够让所修饰的指令变得具有原子性，而hotspot中volatile也是基于lock前缀来实现的，那为什么说volatile不能保证缓存一致性呢？请注意，hotspot只是在对变量修改指令的后面插入了一条lock指令，而不是让变量修改指令变得具有原子性。\n\n# 总结\n本文只是对cpu层面的指令重排序做了介绍，其实编译器还可能进行指令的重排序。java内存模型中有一个先行发生原则（happens-before），该原则规定了一些操作必须在哪些操作之后进行，java编译器不会对这些操作进行重排，但是对于其他的操作都是未定义的。volatile变量规则属于先行发生原则中的一种，所以java编译器不会对由volatile修饰的变量进行过度优化。',charsets:{cjk:!0}},{title:"Java中的ThreadLocal",frontmatter:{title:"Java中的ThreadLocal",categories:["编程语言"],tags:["Java","Thread"],date:"2021-01-23T19:52:51.000Z",permalink:"/pages/994e0e/"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/03.%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/11.ThreadLocal.html",relativePath:"01.编程语言/01.Java/03.线程与并发/11.ThreadLocal.md",key:"v-36755d7a",path:"/pages/994e0e/",headers:[{level:2,title:"使用示例",slug:"使用示例",normalizedTitle:"使用示例",charIndex:188},{level:2,title:"实现原理",slug:"实现原理",normalizedTitle:"实现原理",charIndex:92},{level:3,title:"设置元素",slug:"设置元素",normalizedTitle:"设置元素",charIndex:1416},{level:3,title:"获取元素",slug:"获取元素",normalizedTitle:"获取元素",charIndex:2050},{level:2,title:"移除元素",slug:"移除元素",normalizedTitle:"移除元素",charIndex:3139},{level:2,title:"InheritableThreadLocal",slug:"inheritablethreadlocal",normalizedTitle:"inheritablethreadlocal",charIndex:3243}],excerpt:"<p>很多资料提及<code>ThreadLocal</code>时都会说到“线程安全”，“共享变量”这种话题，让人以为<code>ThreadLocal</code>是用来复制共享变量到线程本地的。其实不然，了解一下<code>ThreadLocal</code>的实现原理就明白，在<code>Thread</code>类中定义了一个类似于线程上下文的实例属性，而<code>ThreadLocal</code>可以看作是操作线程上下文的工具。</p>\n",lastUpdated:"2021-03-21",headersStr:"使用示例 实现原理 设置元素 获取元素 移除元素 InheritableThreadLocal",content:'很多资料提及ThreadLocal时都会说到“线程安全”，“共享变量”这种话题，让人以为ThreadLocal是用来复制共享变量到线程本地的。其实不然，了解一下ThreadLocal的实现原理就明白，在Thread类中定义了一个类似于线程上下文的实例属性，而ThreadLocal可以看作是操作线程上下文的工具。\n\n提示\n\n本文所有的JDK源码的版本为Java 11。\n\n# 使用示例\npublic class ThreadLocalTest {\n  private static ThreadLocal<String> threadLocal = new ThreadLocal<>();\n  public static void main(String[] args) {\n    for (int i = 0; i < 10; i++) {\n      int j = i;\n      new Thread(() -> {\n        // 设置线程本地变量\n        threadLocal.set("Thread " + j);\n        try {\n          Thread.sleep(1000);\n        } catch (InterruptedException e) {\n          e.printStackTrace();\n        }\n        doWork();\n      }, "Thread " + i).start();\n    }\n  }\n  public static void doWork() {\n    // 获取线程本地变量\n    final String s = threadLocal.get();\n    System.out.println(Thread.currentThread().getName() + " : " + s);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n其实ThreadLocal允许每个线程存储数据到自己的本地内存中，只要不remove掉，那么直到当前线程结束之前，都可以在任何地方通过ThreadLocal访问到所设置的值，避免了参数的传递。\n\n# 实现原理\nThreadLocal类中定义了两个实例属性：threadLocals和inheritableThreadLocals，这两个属性都是ThreadLocal.ThreadLocalMap类型的（这是定制化的HashMap，其key固定为ThreadLocal）。而ThreadLocal可以看作是操作这两个属性的工具。每个本地变量关联了一个ThreadLocal对象，而Thread里面的者两个属性的类型又是key为ThreadLocal类型的map，说明一个线程可以关联很多ThreadLocal对象，即一个线程可以创建很多本地变量。\n\n笔记\n\nThreadLocalMap通过开发定址法解决哈希冲突，而HashMap使用的是链地址法。\n\n开发定址法是指从哈希冲突的那个单元开始，按照一定的次序，从哈希表中找到一个空闲的单元。具体的方案有线行探查法、平方探查法、双散列函数探查法。\n\n链地址法是指在冲突的那个单元处引出一条单链表。\n\n# 设置元素\n通过ThreadLocal的set()方法可以向线程上下文中设置值，其源码为：\n\npublic void set(T value) {\n  Thread t = Thread.currentThread();\n  ThreadLocalMap map = getMap(t);\n  // 如果线程的threadLocals属性不为null，则设置值\n  if (map != null) {\n    map.set(this, value);\n  } else { // 如果线程的threadLocals属性为null，则进行创建并往里面添加值\n    createMap(t, value);\n  }\n}\n\nThreadLocalMap getMap(Thread t) {\n  // 直接返回相应线程的threadLocals属性\n  return t.threadLocals;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n通过createMap()来创建线程的threadLocals属性：\n\nvoid createMap(Thread t, T firstValue) {\n  // 新建ThreadLocalMap对象并复制给对应线程的threadLocals属性\n  t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n\n\n1\n2\n3\n4\n# 获取元素\n通过ThreadLocal的get()方法可以获取保存在线程本地中的变量。\n\npublic T get() {\n  Thread t = Thread.currentThread();\n  ThreadLocalMap map = getMap(t);\n  // 如果对应线程的threadLocals属性不为null，则获取内部保存的值\n  if (map != null) {\n    ThreadLocalMap.Entry e = map.getEntry(this);\n    if (e != null) {\n      @SuppressWarnings("unchecked")\n      T result = (T)e.value;\n      return result;\n    }\n  }\n  /*\n  如果线程的threadLocals属性为null或者内部没有当前ThreadLocal对应的变量，则调用setInitialValue()\n  其实经过下面的分析可以直到，这种情况下返回的是null\n  */\n  return setInitialValue();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nprivate T setInitialValue() {\n  // 返回的value为null\n  T value = initialValue();\n  Thread t = Thread.currentThread();\n  ThreadLocalMap map = getMap(t);\n  if (map != null) {\n    // 设置值\n    map.set(this, value);\n  } else {\n    // 如果对应线程的threadLocals属性不为null，则获取内部保存的值\n    createMap(t, value);\n  }\n  if (this instanceof TerminatingThreadLocal) {\n    TerminatingThreadLocal.register((TerminatingThreadLocal<?>) this);\n  }\n  return value;\n}\n\nprotected T initialValue() {\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 移除元素\n由于线程内部的那两个属性一旦创建，则在整个线程的生命周期内都存在，所以决定不再访问某个本地变量时，最好将其移除掉，否则造成内存泄漏。可以调用ThreadLocal的remove()方法移除。\n\n# InheritableThreadLocal\n一般情况下，在父线程中通过ThreadLocal设置线程本地变量，在子线程中是获取不到的。如果想让子线程能够访问父线程里面的本地变量，则可以使用前面提到的Thead里面的另一个实例属性inheritableThreadLocals，可以使用ThreadLocal的一个子类InheritableThreadLocal来操纵该属性。InheritableThreadLocal重写父类的getMap()方法，使得其操纵的是inheritableThreadLocals属性而不是threadLocals属性。\n\n下面一段截取自Thread的构造方法里面的代码：\n\nif (inheritThreadLocals && parent.inheritableThreadLocals != null)\n  this.inheritableThreadLocals =\n    ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);\n\n\n1\n2\n3\n上面代码中调用了TheadLocal中的createInheritedMap()，并把父线程的inheritableThreadLocals属性作为参数传递过去。\n\nstatic ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) {\n  /*\n  创建一个新的ThreadLocalMap，并把父线程的inheritableThreadLocals属性保存的内容添加进去\n  */\n  return new ThreadLocalMap(parentMap);\n}\n\n\n1\n2\n3\n4\n5\n6\n可以发现，子变量是通过复制父线程里面保存的本地变量来实现了获取父线程的里面的本地变量，而不是真正在运行时获取父线程中的本地变量。',normalizedContent:'很多资料提及threadlocal时都会说到“线程安全”，“共享变量”这种话题，让人以为threadlocal是用来复制共享变量到线程本地的。其实不然，了解一下threadlocal的实现原理就明白，在thread类中定义了一个类似于线程上下文的实例属性，而threadlocal可以看作是操作线程上下文的工具。\n\n提示\n\n本文所有的jdk源码的版本为java 11。\n\n# 使用示例\npublic class threadlocaltest {\n  private static threadlocal<string> threadlocal = new threadlocal<>();\n  public static void main(string[] args) {\n    for (int i = 0; i < 10; i++) {\n      int j = i;\n      new thread(() -> {\n        // 设置线程本地变量\n        threadlocal.set("thread " + j);\n        try {\n          thread.sleep(1000);\n        } catch (interruptedexception e) {\n          e.printstacktrace();\n        }\n        dowork();\n      }, "thread " + i).start();\n    }\n  }\n  public static void dowork() {\n    // 获取线程本地变量\n    final string s = threadlocal.get();\n    system.out.println(thread.currentthread().getname() + " : " + s);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n其实threadlocal允许每个线程存储数据到自己的本地内存中，只要不remove掉，那么直到当前线程结束之前，都可以在任何地方通过threadlocal访问到所设置的值，避免了参数的传递。\n\n# 实现原理\nthreadlocal类中定义了两个实例属性：threadlocals和inheritablethreadlocals，这两个属性都是threadlocal.threadlocalmap类型的（这是定制化的hashmap，其key固定为threadlocal）。而threadlocal可以看作是操作这两个属性的工具。每个本地变量关联了一个threadlocal对象，而thread里面的者两个属性的类型又是key为threadlocal类型的map，说明一个线程可以关联很多threadlocal对象，即一个线程可以创建很多本地变量。\n\n笔记\n\nthreadlocalmap通过开发定址法解决哈希冲突，而hashmap使用的是链地址法。\n\n开发定址法是指从哈希冲突的那个单元开始，按照一定的次序，从哈希表中找到一个空闲的单元。具体的方案有线行探查法、平方探查法、双散列函数探查法。\n\n链地址法是指在冲突的那个单元处引出一条单链表。\n\n# 设置元素\n通过threadlocal的set()方法可以向线程上下文中设置值，其源码为：\n\npublic void set(t value) {\n  thread t = thread.currentthread();\n  threadlocalmap map = getmap(t);\n  // 如果线程的threadlocals属性不为null，则设置值\n  if (map != null) {\n    map.set(this, value);\n  } else { // 如果线程的threadlocals属性为null，则进行创建并往里面添加值\n    createmap(t, value);\n  }\n}\n\nthreadlocalmap getmap(thread t) {\n  // 直接返回相应线程的threadlocals属性\n  return t.threadlocals;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n通过createmap()来创建线程的threadlocals属性：\n\nvoid createmap(thread t, t firstvalue) {\n  // 新建threadlocalmap对象并复制给对应线程的threadlocals属性\n  t.threadlocals = new threadlocalmap(this, firstvalue);\n}\n\n\n1\n2\n3\n4\n# 获取元素\n通过threadlocal的get()方法可以获取保存在线程本地中的变量。\n\npublic t get() {\n  thread t = thread.currentthread();\n  threadlocalmap map = getmap(t);\n  // 如果对应线程的threadlocals属性不为null，则获取内部保存的值\n  if (map != null) {\n    threadlocalmap.entry e = map.getentry(this);\n    if (e != null) {\n      @suppresswarnings("unchecked")\n      t result = (t)e.value;\n      return result;\n    }\n  }\n  /*\n  如果线程的threadlocals属性为null或者内部没有当前threadlocal对应的变量，则调用setinitialvalue()\n  其实经过下面的分析可以直到，这种情况下返回的是null\n  */\n  return setinitialvalue();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nprivate t setinitialvalue() {\n  // 返回的value为null\n  t value = initialvalue();\n  thread t = thread.currentthread();\n  threadlocalmap map = getmap(t);\n  if (map != null) {\n    // 设置值\n    map.set(this, value);\n  } else {\n    // 如果对应线程的threadlocals属性不为null，则获取内部保存的值\n    createmap(t, value);\n  }\n  if (this instanceof terminatingthreadlocal) {\n    terminatingthreadlocal.register((terminatingthreadlocal<?>) this);\n  }\n  return value;\n}\n\nprotected t initialvalue() {\n  return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n# 移除元素\n由于线程内部的那两个属性一旦创建，则在整个线程的生命周期内都存在，所以决定不再访问某个本地变量时，最好将其移除掉，否则造成内存泄漏。可以调用threadlocal的remove()方法移除。\n\n# inheritablethreadlocal\n一般情况下，在父线程中通过threadlocal设置线程本地变量，在子线程中是获取不到的。如果想让子线程能够访问父线程里面的本地变量，则可以使用前面提到的thead里面的另一个实例属性inheritablethreadlocals，可以使用threadlocal的一个子类inheritablethreadlocal来操纵该属性。inheritablethreadlocal重写父类的getmap()方法，使得其操纵的是inheritablethreadlocals属性而不是threadlocals属性。\n\n下面一段截取自thread的构造方法里面的代码：\n\nif (inheritthreadlocals && parent.inheritablethreadlocals != null)\n  this.inheritablethreadlocals =\n    threadlocal.createinheritedmap(parent.inheritablethreadlocals);\n\n\n1\n2\n3\n上面代码中调用了theadlocal中的createinheritedmap()，并把父线程的inheritablethreadlocals属性作为参数传递过去。\n\nstatic threadlocalmap createinheritedmap(threadlocalmap parentmap) {\n  /*\n  创建一个新的threadlocalmap，并把父线程的inheritablethreadlocals属性保存的内容添加进去\n  */\n  return new threadlocalmap(parentmap);\n}\n\n\n1\n2\n3\n4\n5\n6\n可以发现，子变量是通过复制父线程里面保存的本地变量来实现了获取父线程的里面的本地变量，而不是真正在运行时获取父线程中的本地变量。',charsets:{cjk:!0}},{title:"Java中的LockSupport",frontmatter:{title:"Java中的LockSupport",categories:["编程语言"],tags:["Java"],date:"2021-01-24T14:42:35.000Z",permalink:"/pages/140566/"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/03.%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/12.Java%E4%B8%AD%E7%9A%84LockSupport.html",relativePath:"01.编程语言/01.Java/03.线程与并发/12.Java中的LockSupport.md",key:"v-4fefe66d",path:"/pages/140566/",headers:[{level:2,title:"park()",slug:"park",normalizedTitle:"park()",charIndex:86},{level:2,title:"unpark()",slug:"unpark",normalizedTitle:"unpark()",charIndex:177},{level:2,title:"parkNanos",slug:"parknanos",normalizedTitle:"parknanos",charIndex:1467},{level:2,title:"park(Object blocker)",slug:"park-object-blocker",normalizedTitle:"park(object blocker)",charIndex:1556},{level:2,title:"parkUntil()",slug:"parkuntil",normalizedTitle:"parkuntil()",charIndex:2092}],excerpt:"<p>Java中的<code>LockSupport</code>是一个工具类，用来挂起和唤醒线程，其他很多同步类中都使用了该工具类。不过<code>LockSupport</code>最终还是调用<code>Unsafe</code>类来实现的。</p>\n",lastUpdated:"2021-01-26",headersStr:"park() unpark() parkNanos park(Object blocker) parkUntil()",content:'Java中的LockSupport是一个工具类，用来挂起和唤醒线程，其他很多同步类中都使用了该工具类。不过LockSupport最终还是调用Unsafe类来实现的。\n\n# park()\n假设在线程A中调用了LockSupport.park()方法来挂起当前线程，那么线程A将会一直被挂起直到下面一种情况发生：\n\n * 其他线程调用LockSupport.unpark()并把参数设置为线程A。\n * 其他线程中断了线程A。\n\nThread A = new Thread(() -> {\n    System.out.println("Thread A: Begin park!");\n    LockSupport.park();\n    System.out.println("Thread A: End park!");\n});\nA.start();\nnew Thread(() -> {\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    // 下面两种方式都可以唤醒线程A\n    // A.interrupt();\n    LockSupport.unpark(A);\n}).start();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n输入如下：\n\nThread A: Begin park!\n// 间隔1s（本行内容仅为说明，不是输出内容）\nThread A: End park!\n\n\n1\n2\n3\n# unpark()\n上面代码中展示了unpark()的基本使用方法。该方法接收一个线程参数，如果该线程没有start，那么该操作不保证有任何效果。如果将started的线程A当前被挂起了，那么该方法唤醒线程A；如果当前线程A没有被挂起，那么保证线程A下一次调用park()方法时不会被阻塞（记住只是一次）。\n\nThread A = new Thread(() -> {\n    try {\n        Thread.sleep(1000);\n        System.out.println("begin park!");\n        LockSupport.park();\n        System.out.println("end park!");\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n});\nA.start();\nnew Thread(() -> {\n    // 线程A此时还没有被挂起\n    LockSupport.unpark(A);\n}).start();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n输出如下：\n\nThread A: Begin park!\n// 没有时间间隔（本行内容仅为说明，不是输出内容）\nThread A: End park!\n\n\n1\n2\n3\n注意，unpark()方法并不像线程的interrupt()方法一样会中断线程，即唤醒线程不会中断线程（不会产生中断异常和设置中断标志位），但线程中断确实可以唤醒线程。例如在线程A进行sleep的过程之间，是无法唤醒线程A的，因为线程A没有被挂起。\n\n# parkNanos\n如果在线程A调用LockSuppot.parkNanos()方法之前，线程A已经被调用过unpark()，那么直接返回；否则将会在指定时间后自动返回。\n\n# park(Object blocker)\n这是带有blocker的挂起方法，当线程被挂起时，该blocker对象会被记录到线程内部（Thread类中定义的parkBlocker属性）。JDK推荐使用带有blocker的park()方法，并且将blocker设置为this，这样使用诊断工具时就可以知道是在哪个类中被挂起了。下面是该方法的源码：\n\npublic static void park(Object blocker) {\n    Thread t = Thread.currentThread();\n    // 设置blocker到当前线程上\n    setBlocker(t, blocker);\n    // 挂起线程\n    U.park(false, 0L);\n    // 将blocker清除掉，因为该属性一般是在线程被挂起时才有用\n    setBlocker(t, null);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n另外还可以通过下面这个方法同时设置挂起的超时时间。\n\n// 只是多了一个超时时间\npublic static void parkNanos(Object blocker, long nanos){...}\n\n\n1\n2\n# parkUntil()\npublic static void parkUntil(long deadline) {\n    U.park(true, deadline);\n}\n\n\n1\n2\n3\n该方法表示线程挂起直到deadline表示的绝对时间，单位为毫秒，即deadline为时间戳。',normalizedContent:'java中的locksupport是一个工具类，用来挂起和唤醒线程，其他很多同步类中都使用了该工具类。不过locksupport最终还是调用unsafe类来实现的。\n\n# park()\n假设在线程a中调用了locksupport.park()方法来挂起当前线程，那么线程a将会一直被挂起直到下面一种情况发生：\n\n * 其他线程调用locksupport.unpark()并把参数设置为线程a。\n * 其他线程中断了线程a。\n\nthread a = new thread(() -> {\n    system.out.println("thread a: begin park!");\n    locksupport.park();\n    system.out.println("thread a: end park!");\n});\na.start();\nnew thread(() -> {\n    try {\n        thread.sleep(1000);\n    } catch (interruptedexception e) {\n        e.printstacktrace();\n    }\n    // 下面两种方式都可以唤醒线程a\n    // a.interrupt();\n    locksupport.unpark(a);\n}).start();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n输入如下：\n\nthread a: begin park!\n// 间隔1s（本行内容仅为说明，不是输出内容）\nthread a: end park!\n\n\n1\n2\n3\n# unpark()\n上面代码中展示了unpark()的基本使用方法。该方法接收一个线程参数，如果该线程没有start，那么该操作不保证有任何效果。如果将started的线程a当前被挂起了，那么该方法唤醒线程a；如果当前线程a没有被挂起，那么保证线程a下一次调用park()方法时不会被阻塞（记住只是一次）。\n\nthread a = new thread(() -> {\n    try {\n        thread.sleep(1000);\n        system.out.println("begin park!");\n        locksupport.park();\n        system.out.println("end park!");\n    } catch (interruptedexception e) {\n        e.printstacktrace();\n    }\n});\na.start();\nnew thread(() -> {\n    // 线程a此时还没有被挂起\n    locksupport.unpark(a);\n}).start();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n输出如下：\n\nthread a: begin park!\n// 没有时间间隔（本行内容仅为说明，不是输出内容）\nthread a: end park!\n\n\n1\n2\n3\n注意，unpark()方法并不像线程的interrupt()方法一样会中断线程，即唤醒线程不会中断线程（不会产生中断异常和设置中断标志位），但线程中断确实可以唤醒线程。例如在线程a进行sleep的过程之间，是无法唤醒线程a的，因为线程a没有被挂起。\n\n# parknanos\n如果在线程a调用locksuppot.parknanos()方法之前，线程a已经被调用过unpark()，那么直接返回；否则将会在指定时间后自动返回。\n\n# park(object blocker)\n这是带有blocker的挂起方法，当线程被挂起时，该blocker对象会被记录到线程内部（thread类中定义的parkblocker属性）。jdk推荐使用带有blocker的park()方法，并且将blocker设置为this，这样使用诊断工具时就可以知道是在哪个类中被挂起了。下面是该方法的源码：\n\npublic static void park(object blocker) {\n    thread t = thread.currentthread();\n    // 设置blocker到当前线程上\n    setblocker(t, blocker);\n    // 挂起线程\n    u.park(false, 0l);\n    // 将blocker清除掉，因为该属性一般是在线程被挂起时才有用\n    setblocker(t, null);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n另外还可以通过下面这个方法同时设置挂起的超时时间。\n\n// 只是多了一个超时时间\npublic static void parknanos(object blocker, long nanos){...}\n\n\n1\n2\n# parkuntil()\npublic static void parkuntil(long deadline) {\n    u.park(true, deadline);\n}\n\n\n1\n2\n3\n该方法表示线程挂起直到deadline表示的绝对时间，单位为毫秒，即deadline为时间戳。',charsets:{cjk:!0}},{title:"Java中的AtomicInteger",frontmatter:{title:"Java中的AtomicInteger",categories:["编程语言"],tags:["Java"],date:"2021-01-24T00:40:11.000Z",permalink:"/pages/4d7f44/"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/03.%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91/21.AtomicInteger.html",relativePath:"01.编程语言/01.Java/03.线程与并发/21.AtomicInteger.md",key:"v-d51657cc",path:"/pages/4d7f44/",headers:[{level:2,title:"基本使用",slug:"基本使用",normalizedTitle:"基本使用",charIndex:86},{level:3,title:"创建AtomicInteger",slug:"创建atomicinteger",normalizedTitle:"创建atomicinteger",charIndex:107},{level:3,title:"Incremental操作",slug:"incremental操作",normalizedTitle:"incremental操作",charIndex:285},{level:3,title:"decremental 操作",slug:"decremental-操作",normalizedTitle:"decremental 操作",charIndex:718},{level:3,title:"更新值",slug:"更新值",normalizedTitle:"更新值",charIndex:1055},{level:2,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:57},{level:3,title:"compareAndSwapInt()",slug:"compareandswapint",normalizedTitle:"compareandswapint()",charIndex:2821},{level:3,title:"getAndAddInt()",slug:"getandaddint",normalizedTitle:"getandaddint()",charIndex:3532}],excerpt:"<p><code>AtomicInteger</code>提供了很多原子性的操作方法，另外还有<code>AtomicBoolean</code>，<code>AtomicLong</code>，但原理都是类似的。本文以<code>AtomicInteger</code>为例，分析基本使用和底层原理。</p>\n",lastUpdated:"2021-01-24",headersStr:"基本使用 创建AtomicInteger Incremental操作 decremental 操作 更新值 原理 compareAndSwapInt() getAndAddInt()",content:'AtomicInteger提供了很多原子性的操作方法，另外还有AtomicBoolean，AtomicLong，但原理都是类似的。本文以AtomicInteger为例，分析基本使用和底层原理。\n\n# 基本使用\n# 创建AtomicInteger\nAtomicInteger提供了两个构造器，一个无参，默认初始值为0；另一个有一个参数，为所指定的初始值。\n\npublic AtomicInteger() {}\npublic AtomicInteger(int initialValue) {\n    value = initialValue;\n}\n\n\n1\n2\n3\n4\n# Incremental操作\ngetAndIncrement()和incrementAndGet()\n\n两者都会执行自增操作，但是前者返回增长前的值，而后者返回增长后的值。\n\npublic static void main(String[] args) {\n    /*\n    AtomicInteger虽然执行的是原子操作，但是如果atomicInteger被多个线程共享，\n    那么下面两条输出语句的结果可能不如预期。\n    */\n    AtomicInteger atomicInteger = new AtomicInteger(); // 初始值为0\n    System.out.println(atomicInteger.getAndIncrement()); // 0\n    System.out.println(atomicInteger.incrementAndGet()); // 2\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# decremental 操作\ngetAndDecrement()和decrementAndGet()\n\n两者都会执行自减操作，但是前者返回减少前的值，而后者返回减少后的值。\n\npublic static void main(String[] args) {\n    AtomicInteger atomicInteger = new AtomicInteger(10); // 初始值为10\n    System.out.println(atomicInteger.getAndDecrement()); // 10\n    System.out.println(atomicInteger.decrementAndGet()); // 8\n}\n\n\n1\n2\n3\n4\n5\n# 更新值\n 1. 可以调用下面方法来原子性地更新值，expectedValue表示当前值，newValue是需要设置的新值。该方法返回一个boolean类型的结果，当expectedValue和当前值不相等时，修改失败，返回false；否则返回true，表示修改成功。\n    \n    boolean compareAndSet(int expectedValue, int newValue)\n    \n    \n    1\n    \n 2. 另外还有两个方法可以原子性地修改值：\n    \n    \n\nint getAndAdd(int delta)\nint addAndGet(int delta)    \n\n\n1\n2\n两者都会执行修改操作，修改后的值为当前值与delta之和，不过前者返回修改前的值，后者返回修改后的值。\n\n 3. 另外还有两个支持lambda表达式的方法：\n    \n    int getAndUpdate(IntUnaryOperator updateFunction)\n    int updateAndGet(IntUnaryOperator updateFunction)\n    \n    \n    1\n    2\n    下面是这两个方法的使用例子：\n    \n    public static void main(String[] args) {\n        AtomicInteger atomicInteger = new AtomicInteger(10);\n        System.out.println(atomicInteger.getAndUpdate(x -> x * x)); // 10\n        System.out.println(atomicInteger.updateAndGet(x -> (int)Math.sqrt(x))); // 10\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n 4. 另外还有两个方法：\n    \n    int getAndAccumulate(int x, IntBinaryOperator accumulatorFunction)\n    int accumulateAndGet(int x, IntBinaryOperator accumulatorFunction)\n    \n    \n    1\n    2\n    IntBinaryOperator类型为一个二元运算器，将当前值与x（delta）进行运算。下面是这两个方法的使用例子：\n    \n    public static void main(String[] args) {\n        AtomicInteger atomicInteger = new AtomicInteger(10);\n        System.out.println(atomicInteger.getAndAccumulate(5, Integer::sum)); // 10\n        System.out.println(atomicInteger.accumulateAndGet(-5, Integer::sum)); // 10\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n 5. 其他方法：\n    \n    // 将当前值设置为newValue，由于value属性由volatile修饰，所以可以保证对其他线程的可见性\n    void set(int newValue)\n    // 在单线程内使用，不会使用内存屏障\n    void lazySet(int newValue)\n    // 返回AtomicInteger的value当前值\n    int get()\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n# 原理\n几乎所有的原子类都调用了Unsafe类，该类被命名为不安全的，因为其功能很强大，如果使用不当会导致不可预料的后果。\n\n# compareAndSwapInt()\n该方法内部实现了经典的CAS算法，该方法位于Unsafe类中，是一个native方法。\n\n/**\no: 原子类对象\noffset: 原子类对象中value值的偏移量\nexpected: 期望的value的当前值\nx: 新值\n*/\npublic final native boolean compareAndSetInt(Object o, long offset,\n                                                 int expected,\n                                                 int x);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n在HotSpot的实现源码中，有一段关键代码：\n\nLOCK_IF_MP(%4) "cmpxchgl %1, (%3)"\n\n\n1\n大概意思是当在多处理器中会对cmpxchgl指令加上lock前缀。\n\n警告\n\n下面内容的真实性未经验证！！！\n\ncmpxchgl指令为cmpxchg的变种，两者都差不多，另外还有一个指令叫做xchg。\n\nxchg表示交换两个操作数，是原子指令。\n\ncmpxchg表示比较并交换两个操作数，不是原子指令，所以在多核CPU中为了原子性要加lock前缀。\n\ncmpxchg将al\\ax\\eax\\rax中的值与第一操作数进行比较：\n\n * 如果相等，把第二操作数直接装载到第一操作数，zf置为1。\n * 如果不相等，第一操作数的值装载到al\\ax\\eax\\rax，并将zf清0。\n\n更多细节请参考这个pdf。\n\n# getAndAddInt()\ncompareAndSwapInt()方法可能存在修改失败的情况，但是有时候必须要修改成功，比如调用incrementAndGet()，addAndGet()等方法，所以需要使用Unsafe类中getAndAddInt()方法。下面是该方法的源码：\n\npublic final int getAndAddInt(Object o, long offset, int delta) {\n    int v;\n    do {\n        /* 通过字段偏移量的方式读取内存获取由volatile修饰的value值 */\n        v = getIntVolatile(o, offset);\n        /* 循环执行weakCompareAndSetInt方法，直到修改成功或超过虚拟机设置的自旋参数 */\n    } while (!weakCompareAndSetInt(o, offset, v, v + delta));\n    return v;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9',normalizedContent:'atomicinteger提供了很多原子性的操作方法，另外还有atomicboolean，atomiclong，但原理都是类似的。本文以atomicinteger为例，分析基本使用和底层原理。\n\n# 基本使用\n# 创建atomicinteger\natomicinteger提供了两个构造器，一个无参，默认初始值为0；另一个有一个参数，为所指定的初始值。\n\npublic atomicinteger() {}\npublic atomicinteger(int initialvalue) {\n    value = initialvalue;\n}\n\n\n1\n2\n3\n4\n# incremental操作\ngetandincrement()和incrementandget()\n\n两者都会执行自增操作，但是前者返回增长前的值，而后者返回增长后的值。\n\npublic static void main(string[] args) {\n    /*\n    atomicinteger虽然执行的是原子操作，但是如果atomicinteger被多个线程共享，\n    那么下面两条输出语句的结果可能不如预期。\n    */\n    atomicinteger atomicinteger = new atomicinteger(); // 初始值为0\n    system.out.println(atomicinteger.getandincrement()); // 0\n    system.out.println(atomicinteger.incrementandget()); // 2\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# decremental 操作\ngetanddecrement()和decrementandget()\n\n两者都会执行自减操作，但是前者返回减少前的值，而后者返回减少后的值。\n\npublic static void main(string[] args) {\n    atomicinteger atomicinteger = new atomicinteger(10); // 初始值为10\n    system.out.println(atomicinteger.getanddecrement()); // 10\n    system.out.println(atomicinteger.decrementandget()); // 8\n}\n\n\n1\n2\n3\n4\n5\n# 更新值\n 1. 可以调用下面方法来原子性地更新值，expectedvalue表示当前值，newvalue是需要设置的新值。该方法返回一个boolean类型的结果，当expectedvalue和当前值不相等时，修改失败，返回false；否则返回true，表示修改成功。\n    \n    boolean compareandset(int expectedvalue, int newvalue)\n    \n    \n    1\n    \n 2. 另外还有两个方法可以原子性地修改值：\n    \n    \n\nint getandadd(int delta)\nint addandget(int delta)    \n\n\n1\n2\n两者都会执行修改操作，修改后的值为当前值与delta之和，不过前者返回修改前的值，后者返回修改后的值。\n\n 3. 另外还有两个支持lambda表达式的方法：\n    \n    int getandupdate(intunaryoperator updatefunction)\n    int updateandget(intunaryoperator updatefunction)\n    \n    \n    1\n    2\n    下面是这两个方法的使用例子：\n    \n    public static void main(string[] args) {\n        atomicinteger atomicinteger = new atomicinteger(10);\n        system.out.println(atomicinteger.getandupdate(x -> x * x)); // 10\n        system.out.println(atomicinteger.updateandget(x -> (int)math.sqrt(x))); // 10\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n 4. 另外还有两个方法：\n    \n    int getandaccumulate(int x, intbinaryoperator accumulatorfunction)\n    int accumulateandget(int x, intbinaryoperator accumulatorfunction)\n    \n    \n    1\n    2\n    intbinaryoperator类型为一个二元运算器，将当前值与x（delta）进行运算。下面是这两个方法的使用例子：\n    \n    public static void main(string[] args) {\n        atomicinteger atomicinteger = new atomicinteger(10);\n        system.out.println(atomicinteger.getandaccumulate(5, integer::sum)); // 10\n        system.out.println(atomicinteger.accumulateandget(-5, integer::sum)); // 10\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n 5. 其他方法：\n    \n    // 将当前值设置为newvalue，由于value属性由volatile修饰，所以可以保证对其他线程的可见性\n    void set(int newvalue)\n    // 在单线程内使用，不会使用内存屏障\n    void lazyset(int newvalue)\n    // 返回atomicinteger的value当前值\n    int get()\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n\n# 原理\n几乎所有的原子类都调用了unsafe类，该类被命名为不安全的，因为其功能很强大，如果使用不当会导致不可预料的后果。\n\n# compareandswapint()\n该方法内部实现了经典的cas算法，该方法位于unsafe类中，是一个native方法。\n\n/**\no: 原子类对象\noffset: 原子类对象中value值的偏移量\nexpected: 期望的value的当前值\nx: 新值\n*/\npublic final native boolean compareandsetint(object o, long offset,\n                                                 int expected,\n                                                 int x);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n在hotspot的实现源码中，有一段关键代码：\n\nlock_if_mp(%4) "cmpxchgl %1, (%3)"\n\n\n1\n大概意思是当在多处理器中会对cmpxchgl指令加上lock前缀。\n\n警告\n\n下面内容的真实性未经验证！！！\n\ncmpxchgl指令为cmpxchg的变种，两者都差不多，另外还有一个指令叫做xchg。\n\nxchg表示交换两个操作数，是原子指令。\n\ncmpxchg表示比较并交换两个操作数，不是原子指令，所以在多核cpu中为了原子性要加lock前缀。\n\ncmpxchg将al\\ax\\eax\\rax中的值与第一操作数进行比较：\n\n * 如果相等，把第二操作数直接装载到第一操作数，zf置为1。\n * 如果不相等，第一操作数的值装载到al\\ax\\eax\\rax，并将zf清0。\n\n更多细节请参考这个pdf。\n\n# getandaddint()\ncompareandswapint()方法可能存在修改失败的情况，但是有时候必须要修改成功，比如调用incrementandget()，addandget()等方法，所以需要使用unsafe类中getandaddint()方法。下面是该方法的源码：\n\npublic final int getandaddint(object o, long offset, int delta) {\n    int v;\n    do {\n        /* 通过字段偏移量的方式读取内存获取由volatile修饰的value值 */\n        v = getintvolatile(o, offset);\n        /* 循环执行weakcompareandsetint方法，直到修改成功或超过虚拟机设置的自旋参数 */\n    } while (!weakcompareandsetint(o, offset, v, v + delta));\n    return v;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9',charsets:{cjk:!0}},{title:"Java方法调用",frontmatter:{title:"Java方法调用",categories:["编程语言"],tags:["Java"],date:"2021-01-28T16:25:09.000Z",permalink:"/pages/5825a9/"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/05.JVM/01.%E6%89%A7%E8%A1%8C%E5%AD%90%E7%B3%BB%E7%BB%9F/01.Java%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8.html",relativePath:"01.编程语言/01.Java/05.JVM/01.执行子系统/01.Java方法调用.md",key:"v-2127413f",path:"/pages/5825a9/",headers:[{level:2,title:"解析（Resolution）",slug:"解析（resolution）",normalizedTitle:"解析（resolution）",charIndex:492},{level:2,title:"分派（Dispatch）",slug:"分派（dispatch）",normalizedTitle:"分派（dispatch）",charIndex:741},{level:3,title:"静态分派",slug:"静态分派",normalizedTitle:"静态分派",charIndex:900},{level:3,title:"动态分派",slug:"动态分派",normalizedTitle:"动态分派",charIndex:1876},{level:3,title:"单分派与多分派",slug:"单分派与多分派",normalizedTitle:"单分派与多分派",charIndex:2542},{level:3,title:"接口中的方法",slug:"接口中的方法",normalizedTitle:"接口中的方法",charIndex:430},{level:3,title:"动态类型",slug:"动态类型",normalizedTitle:"动态类型",charIndex:466},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:144}],excerpt:"<p>Java方法调用不仅指方法的代码被执行，方法调用阶段唯一的任务就是确定被调用的方法版本。有些方法在编译时就能确定所调用的版本，而有些则需要等到运行时才能确定。因为在Java中，方法可能是私有的，也有可能是static或final的，另外有些方法还可以被重载和重写（听起来可能很混乱）。本文参考《深入理解Java虚拟机（第三版）》总结一下关于方法解析和分配与方法调用相关的指令。</p>\n",lastUpdated:"2021-01-29",headersStr:"解析（Resolution） 分派（Dispatch） 静态分派 动态分派 单分派与多分派 接口中的方法 动态类型 参考",content:"Java方法调用不仅指方法的代码被执行，方法调用阶段唯一的任务就是确定被调用的方法版本。有些方法在编译时就能确定所调用的版本，而有些则需要等到运行时才能确定。因为在Java中，方法可能是私有的，也有可能是static或final的，另外有些方法还可以被重载和重写（听起来可能很混乱）。本文参考《深入理解Java虚拟机（第三版）》总结一下关于方法解析和分配与方法调用相关的指令。\n\nJava编译器会将方法调用编译为下面5中方法调用指令：\n\n * invokestatic：调用static方法。\n   \n   提示\n   \n   对于<cinit>方法没有使用invokestatic指令进行调用，本文所参考的书上也没有讲为什么。\n   \n   \n * invokespecial：调用<init>()方法，私有方法和父类中的方法。\n   \n   \n * invokevirtual：调用所有的虚方法。\n   \n   \n * invokeinterface：调用接口中的方法。\n   \n   \n * invokedynamic：与支持动态类型语言有关，请见下文。\n   \n   \n\n# 解析（Resolution）\n方法解析是一个静态的过程，在编译期间就完全确定了，在类加载的阶段就会把涉及到的符号引用全部转换为直接引用。\n\n所有的静态方法，私有方法，实例构造器，父类方法以及被final修饰的方法，都是在编译时就确定好了方法的直接引用。前4种是通过invokestatic或invokespecial来执行的，而final方法是通过invokevirtual指令调用的（由于历史设计原因）。这些能够在编译时阶段进行解析的方法称为非虚方法（共5种），而其他方法则被称为虚方法。\n\n# 分派（Dispatch）\n上面说到方法解析是一个静态的过程，而分派既可能是静态的，也有可能是动态的。另外根据的宗量，可以分为单分派和多分派。理论上可以有四种组合，不过在Java中，目前Java属于静态多分派和动态单分派的语言（之所以强调目前，是因为不确定未来Java会不会做出改变，如C#在4.0前后的变化）。\n\n# 静态分派\n首先看一段代码（引用自原书）：\n\npublic class StaticDispatch {\n    static abstract class Human {}\n    static class Man extends Human {}\n    static class Woman extends Human {}\n}\n\n\n1\n2\n3\n4\n5\n根据上面的类声明，对于下面的定义：\n\nHuman man = new Man();\n\n\n1\nHuman属于静态类型（或外观类型），而Man属于运行时类型（或实际类型）。关于原书（第三版）P305页第2段有一句话确实不好理解（原书作者写的时候也想到了，还好有例子​），所以下面记录一下原书作者举的例子：\n\n// 运行时类型的变化\nHuman human = (new Random()).nextBoolean() ? new Man() : new Woman();\n\n// 静态类型变化\nsr.sayHello((Man)human);\nsr.sayHello((Woman)human);\n\n\n1\n2\n3\n4\n5\n6\n注意\n\n关于静态类型变化这里，当然有一条语句会抛出ClassCastException，这里作者重点是说明静态类型可以这样变化，而不是说实际中代码可以这样写。\n\n可见，对于变量human，其运行时类型和静态类型都是可以变化的。但是运行时类型的变化只有在运行时才可知；而对于静态类型，在编译时就是可知的，如上面代码第2行静态类型为Human，第5行静态类型为Man，第6行静态类型为Woman。\n\n所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派。静态分派最典型的应用就是方法重载（Overload），静态分派的动作发生在编译阶段，所以说静态分派是由编译器而不是虚拟机来进行的，和上面讲到的方法解析有些类似，所以有一些资料将静态分派归为解析而不是分派。\n\n另外，有些时候编译器能够确定出方法的重载版本，但在很多情况下这个重载版本不是唯一的，只能确定一个相对更合适的版本。原书第3版P306页举了一个例子，在重载匹配过程中，参数可能经过一系列的转换。对于基本类型可能按照数据范围小的类型逐渐转为数据范围大的类型，对于引用类型，可能按照类继承体系从下往上转。\n\n# 动态分派\n动态分派与Java里面的重写有很大的关联，之所以有动态分派是因为存在重写（Override）这个特性，而正是有因为有了动态分派，重写才得以被支持。\n\n提示\n\n重写肯定是多态性的体现，而重载算不算多态，目前有一些争议。\n\n重写方法的执行与invokevirtual指令有关，该指令的运行时处理流程大致分为以下几步：\n\n * 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。\n * 如果在类型C中存在与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.IllegalError异常。\n * 如果不存在相符的方法，则按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。\n * 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。\n\n所以方法重写的本质是：invokevirtual指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法的版本。这种运行期根据实际类型确定方法执行版本的分派过程称为动态分派。重写方法属于一种虚方法，字段永远不可能是虚的，所以字段不会参与多态。\n\n另外，如原书第三版P311举的例子，如果子类重写了父类构造方法里面所调用的方法，那么在实例化子类时，该子类重写的方法会被调用。很多时候我们对“receiver.OverloadMethod”这种模式很熟悉而忽略了构造器调用重写方法的这种情况。\n\n# 单分派与多分派\n有时候重载和重写会同时出现，关于这部分，原书中举了例子（第三版P312），但是个人没有很好理解。后来在知乎问答中找到一个例子感觉比较好，可以参考“ze ran”用户的回答。\n\n警告\n\n这部分纯属个人理解，未经证实。\n\n重载属于静态分派，重写属于动态分派；静态分派在编译时根据静态类型匹配方法，而在运行时根据调用者的运行时类型进行方法匹配。所以对于那两个例子而言，首先确定重载版本，然后再根据变量的运行时类型来确定重写版本。\n\n# 接口中的方法\n在Java 8以前，往接口中添加方法是一件痛苦的事情，因为往接口中添加了方法就要给所有的实现类添加方法。Java 8开始，可以往类中添加静态方法和默认方法。\n\n之所以在接口中提供静态方法是为了避免定义一些相关的工具类，如Collectons，Collectors等。这样提高了内聚性。\n\n子类不必实现父接口的默认方法，所以往接口中添加默认方法是安全的。但有时候多个父接口以及父类的方法可能会导致冲突，Java中的规则如下：\n\n 1. 类中的方法优先级最高，父类声明的方法优先级高于任何声明为默认方法的优先级。\n    \n    \n 2. 多个父接口中出现冲突，那么选择最具体（more-specific）的那个接口中的方法（有点就近原则的意思）。\n    \n    \n 3. 如果上面两条规则都无法判断，那么继承了多个接口的类必须通过显式覆盖所要调用的方法，因为是从继承链的底层往最上层查找。\n    \n    \n\n对于接口中的静态方法，还是通过invokestatic指令进行调用的，因为在编译时能唯一确定，不属于虚方法。\n\n当对象的静态类型为接口时，调用方法是通过invokeinterface指令来进行的。\n\n# 动态类型\n每一处含有invokedynamic指令的位置都被称作“动态调用点”，这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是CONSTANT_Dynamic_info类型的，这种类型的常量中包含了一个引导方法在引导方法表中的下标，引导方法表（BootstrapMethods属性）位于类文件的属性表中。这些引导方法返回值是java.lang.invoke.CallSite类型的对象，该对象代表了真正要执行的目标方法。\n\n# 参考\n * 《深入理解Java虚拟机 （第三版）》周志明 著\n   \n   \n * 知乎问答",normalizedContent:"java方法调用不仅指方法的代码被执行，方法调用阶段唯一的任务就是确定被调用的方法版本。有些方法在编译时就能确定所调用的版本，而有些则需要等到运行时才能确定。因为在java中，方法可能是私有的，也有可能是static或final的，另外有些方法还可以被重载和重写（听起来可能很混乱）。本文参考《深入理解java虚拟机（第三版）》总结一下关于方法解析和分配与方法调用相关的指令。\n\njava编译器会将方法调用编译为下面5中方法调用指令：\n\n * invokestatic：调用static方法。\n   \n   提示\n   \n   对于<cinit>方法没有使用invokestatic指令进行调用，本文所参考的书上也没有讲为什么。\n   \n   \n * invokespecial：调用<init>()方法，私有方法和父类中的方法。\n   \n   \n * invokevirtual：调用所有的虚方法。\n   \n   \n * invokeinterface：调用接口中的方法。\n   \n   \n * invokedynamic：与支持动态类型语言有关，请见下文。\n   \n   \n\n# 解析（resolution）\n方法解析是一个静态的过程，在编译期间就完全确定了，在类加载的阶段就会把涉及到的符号引用全部转换为直接引用。\n\n所有的静态方法，私有方法，实例构造器，父类方法以及被final修饰的方法，都是在编译时就确定好了方法的直接引用。前4种是通过invokestatic或invokespecial来执行的，而final方法是通过invokevirtual指令调用的（由于历史设计原因）。这些能够在编译时阶段进行解析的方法称为非虚方法（共5种），而其他方法则被称为虚方法。\n\n# 分派（dispatch）\n上面说到方法解析是一个静态的过程，而分派既可能是静态的，也有可能是动态的。另外根据的宗量，可以分为单分派和多分派。理论上可以有四种组合，不过在java中，目前java属于静态多分派和动态单分派的语言（之所以强调目前，是因为不确定未来java会不会做出改变，如c#在4.0前后的变化）。\n\n# 静态分派\n首先看一段代码（引用自原书）：\n\npublic class staticdispatch {\n    static abstract class human {}\n    static class man extends human {}\n    static class woman extends human {}\n}\n\n\n1\n2\n3\n4\n5\n根据上面的类声明，对于下面的定义：\n\nhuman man = new man();\n\n\n1\nhuman属于静态类型（或外观类型），而man属于运行时类型（或实际类型）。关于原书（第三版）p305页第2段有一句话确实不好理解（原书作者写的时候也想到了，还好有例子​），所以下面记录一下原书作者举的例子：\n\n// 运行时类型的变化\nhuman human = (new random()).nextboolean() ? new man() : new woman();\n\n// 静态类型变化\nsr.sayhello((man)human);\nsr.sayhello((woman)human);\n\n\n1\n2\n3\n4\n5\n6\n注意\n\n关于静态类型变化这里，当然有一条语句会抛出classcastexception，这里作者重点是说明静态类型可以这样变化，而不是说实际中代码可以这样写。\n\n可见，对于变量human，其运行时类型和静态类型都是可以变化的。但是运行时类型的变化只有在运行时才可知；而对于静态类型，在编译时就是可知的，如上面代码第2行静态类型为human，第5行静态类型为man，第6行静态类型为woman。\n\n所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派。静态分派最典型的应用就是方法重载（overload），静态分派的动作发生在编译阶段，所以说静态分派是由编译器而不是虚拟机来进行的，和上面讲到的方法解析有些类似，所以有一些资料将静态分派归为解析而不是分派。\n\n另外，有些时候编译器能够确定出方法的重载版本，但在很多情况下这个重载版本不是唯一的，只能确定一个相对更合适的版本。原书第3版p306页举了一个例子，在重载匹配过程中，参数可能经过一系列的转换。对于基本类型可能按照数据范围小的类型逐渐转为数据范围大的类型，对于引用类型，可能按照类继承体系从下往上转。\n\n# 动态分派\n动态分派与java里面的重写有很大的关联，之所以有动态分派是因为存在重写（override）这个特性，而正是有因为有了动态分派，重写才得以被支持。\n\n提示\n\n重写肯定是多态性的体现，而重载算不算多态，目前有一些争议。\n\n重写方法的执行与invokevirtual指令有关，该指令的运行时处理流程大致分为以下几步：\n\n * 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作c。\n * 如果在类型c中存在与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.illegalerror异常。\n * 如果不存在相符的方法，则按照继承关系从下往上依次对c的各个父类进行第二步的搜索和验证过程。\n * 如果始终没有找到合适的方法，则抛出java.lang.abstractmethoderror异常。\n\n所以方法重写的本质是：invokevirtual指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法的版本。这种运行期根据实际类型确定方法执行版本的分派过程称为动态分派。重写方法属于一种虚方法，字段永远不可能是虚的，所以字段不会参与多态。\n\n另外，如原书第三版p311举的例子，如果子类重写了父类构造方法里面所调用的方法，那么在实例化子类时，该子类重写的方法会被调用。很多时候我们对“receiver.overloadmethod”这种模式很熟悉而忽略了构造器调用重写方法的这种情况。\n\n# 单分派与多分派\n有时候重载和重写会同时出现，关于这部分，原书中举了例子（第三版p312），但是个人没有很好理解。后来在知乎问答中找到一个例子感觉比较好，可以参考“ze ran”用户的回答。\n\n警告\n\n这部分纯属个人理解，未经证实。\n\n重载属于静态分派，重写属于动态分派；静态分派在编译时根据静态类型匹配方法，而在运行时根据调用者的运行时类型进行方法匹配。所以对于那两个例子而言，首先确定重载版本，然后再根据变量的运行时类型来确定重写版本。\n\n# 接口中的方法\n在java 8以前，往接口中添加方法是一件痛苦的事情，因为往接口中添加了方法就要给所有的实现类添加方法。java 8开始，可以往类中添加静态方法和默认方法。\n\n之所以在接口中提供静态方法是为了避免定义一些相关的工具类，如collectons，collectors等。这样提高了内聚性。\n\n子类不必实现父接口的默认方法，所以往接口中添加默认方法是安全的。但有时候多个父接口以及父类的方法可能会导致冲突，java中的规则如下：\n\n 1. 类中的方法优先级最高，父类声明的方法优先级高于任何声明为默认方法的优先级。\n    \n    \n 2. 多个父接口中出现冲突，那么选择最具体（more-specific）的那个接口中的方法（有点就近原则的意思）。\n    \n    \n 3. 如果上面两条规则都无法判断，那么继承了多个接口的类必须通过显式覆盖所要调用的方法，因为是从继承链的底层往最上层查找。\n    \n    \n\n对于接口中的静态方法，还是通过invokestatic指令进行调用的，因为在编译时能唯一确定，不属于虚方法。\n\n当对象的静态类型为接口时，调用方法是通过invokeinterface指令来进行的。\n\n# 动态类型\n每一处含有invokedynamic指令的位置都被称作“动态调用点”，这条指令的第一个参数不再是代表方法符号引用的constant_methodref_info常量，而是constant_dynamic_info类型的，这种类型的常量中包含了一个引导方法在引导方法表中的下标，引导方法表（bootstrapmethods属性）位于类文件的属性表中。这些引导方法返回值是java.lang.invoke.callsite类型的对象，该对象代表了真正要执行的目标方法。\n\n# 参考\n * 《深入理解java虚拟机 （第三版）》周志明 著\n   \n   \n * 知乎问答",charsets:{cjk:!0}},{title:"JDBC API概述",frontmatter:{title:"JDBC API概述",categories:["编程语言"],tags:["Java","JDBC"],date:"2021-01-08T20:54:06.000Z",permalink:"/pages/e71797/"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/01.Java/06.JDBC/01.API%E6%A6%82%E8%BF%B0.html",relativePath:"01.编程语言/01.Java/06.JDBC/01.API概述.md",key:"v-5f9e1822",path:"/pages/e71797/",headers:[{level:2,title:"建立数据源连接",slug:"建立数据源连接",normalizedTitle:"建立数据源连接",charIndex:71},{level:2,title:"执行SQL语句",slug:"执行sql语句",normalizedTitle:"执行sql语句",charIndex:39},{level:2,title:"处理SQL语句执行结果",slug:"处理sql语句执行结果",normalizedTitle:"处理sql语句执行结果",charIndex:1108},{level:2,title:"关闭连接",slug:"关闭连接",normalizedTitle:"关闭连接",charIndex:63},{level:2,title:"JDBC API中的类与接口",slug:"jdbc-api中的类与接口",normalizedTitle:"jdbc api中的类与接口",charIndex:1383},{level:3,title:"java.sql",slug:"java-sql",normalizedTitle:"java.sql",charIndex:1427},{level:3,title:"javax.sql",slug:"javax-sql",normalizedTitle:"javax.sql",charIndex:1436},{level:2,title:"Driver与DriverManager",slug:"driver与drivermanager",normalizedTitle:"driver与drivermanager",charIndex:2060},{level:2,title:"DataSource",slug:"datasource",normalizedTitle:"datasource",charIndex:444},{level:2,title:"Statement",slug:"statement",normalizedTitle:"statement",charIndex:1035},{level:2,title:"ResultSet",slug:"resultset",normalizedTitle:"resultset",charIndex:1138},{level:3,title:"游标操作方式和敏感性",slug:"游标操作方式和敏感性",normalizedTitle:"游标操作方式和敏感性",charIndex:4248},{level:3,title:"并行性",slug:"并行性",normalizedTitle:"并行性",charIndex:4667},{level:3,title:"可保持性",slug:"可保持性",normalizedTitle:"可保持性",charIndex:4893},{level:3,title:"关闭ResultSet",slug:"关闭resultset",normalizedTitle:"关闭resultset",charIndex:5043},{level:2,title:"事务",slug:"事务",normalizedTitle:"事务",charIndex:560},{level:2,title:"DatabaseMetaData",slug:"databasemetadata",normalizedTitle:"databasemetadata",charIndex:4811},{level:2,title:"常见数据库的驱动实现类名和URL格式",slug:"常见数据库的驱动实现类名和url格式",normalizedTitle:"常见数据库的驱动实现类名和url格式",charIndex:5646},{level:3,title:"MySQL",slug:"mysql",normalizedTitle:"mysql",charIndex:5667},{level:3,title:"Oracle",slug:"oracle",normalizedTitle:"oracle",charIndex:5812},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:4028}],excerpt:"<p>使用JDBC操作数据源大致需要以下几个步骤：</p>\n<ul>\n<li>与数据库建立连接</li>\n<li>执行SQL语句</li>\n<li>检索SQL执行结果</li>\n<li>关闭连接</li>\n</ul>\n",lastUpdated:"2021-03-21",headersStr:"建立数据源连接 执行SQL语句 处理SQL语句执行结果 关闭连接 JDBC API中的类与接口 java.sql javax.sql Driver与DriverManager DataSource Statement ResultSet 游标操作方式和敏感性 并行性 可保持性 关闭ResultSet 事务 DatabaseMetaData 常见数据库的驱动实现类名和URL格式 MySQL Oracle 参考",content:'使用JDBC操作数据源大致需要以下几个步骤：\n\n * 与数据库建立连接\n * 执行SQL语句\n * 检索SQL执行结果\n * 关闭连接\n\n# 建立数据源连接\nJDBC API中定义了Connection接口，用来表示与底层数据源的连接。应用程序可以使用两种方式获取Connection对象。\n\n * DriverManager：JDBC 1.0规范中就已经存在，完全由JDBC API实现。\n   \n   Connection connection = DriverManager.getConection(...);\n   \n   \n   1\n   JDBC 4.0之后的版本，创建Connection对象之前，不再需要通过Class.forName(DriverPath)显示地加载驱动类，DriverManager类通过SPI机制加载驱动。DriverManager中有三个getConection()的重载，根据数据库连接信息的不同可以使用不同的重载版本。\n   \n   \n * DataSource：这个接口是在JDBC 2.0规范可选包中引入的。它提供了比DriverManager更多的底层数据源相关的细节。相比DriverManager，这种方式不需要对连接信息进行硬编码。第二个优势体现在连接池和分布式事务上。\n   \n   \n\nJDBC API中只提供了DataSource接口的定义，而没有提供实现，具体的实现由JDBC驱动程序提供，另外一些主流的数据库连接池（如Druid）也提供了实现。MyBatis框架中也提供了DataSource接口的实现，可以通过DataSourceFactory来获取。\n\nJDBC API中定义了两个DataSource接口比较重要的扩展，分别为：\n\n * ConnectionPoolDataSource：支持缓存和复用Conection对象，在很大程度上提升应用性能和伸缩性。\n * XADataSource：该实例返回的Connection对象能够支持分布式事务。\n\n# 执行SQL语句\n因为不同的数据库提供的操作可能会有差别，所以JDBC API中提供了DataBaseMetadata接口，应用程序可以使用该接口实例来确定目前使用的数据源是否支持某一特性。另外，JDBC API中还定义了转义语法，应用程序能够访问JDBC厂商提供的非标准特性。\n\n获取Connection对象之后，可以设置事务属性，并创建Statement等类型的对象。Statement可以理解为JDBC API中提供的SQL语句执行器，通过该实例对象调用方法执行相应操作。\n\n# 处理SQL语句执行结果\nSQL语句执行后，可以通过调用getResultSet()方法获取查询结果集，或者通过调用getUpdateCount()方法来获取更新操作影响的行数。前者返回ResultSet类型的实例，可以通过该实例获取结果集。\n\n# 关闭连接\n当我们使用完Connection对象后，需要显式地关闭该对象。可以通过close()方法关闭，还可以通过isClosed()方法判断连接是否关闭，同时通过isValid()方法判断连接是否有效。当连接关闭后或者是无效时，调用除了前面所说的几个方法外，将会抛出SQLException。\n\n# JDBC API中的类与接口\n前面讲了使用JDBC API的基本过程，JDBC API由java.sql和javax.sql两个包构成。\n\n# java.sql\njava.sql包含了最核心的API，可以把这些API分为数据类型接口，枚举类，驱动相关类和接口，异常类。\n\n\n\n\n\n除了这几类外，还有一些API，主要包括以下几个接口：\n\n\n\n这些接口都继承自java.sql.Wrapper，该接口提供了程序访问原始类型的功能，从而使用JDBC驱动中一些非标准的特性。部分接口之间的关系如下图所示（注意不是严格的UML类图）：\n\n\n\n# javax.sql\njavax.sql包中的类和接口最早是由JDBC 2.0版本的可选包提供的，这个可选包最早出现在J2SE 1.2版本中。该包主要包括了数据源，连接池相关，ResultSet的扩展和分布式扩展相关的API：\n\n\n\n两个包的关系体现在通过javax.sql.DataSource获取java.sql.Connection实例。另外，javax.sql包还提供了一个PooledConnection接口，当应用程序调用DataSource对象的getConnection()方法时，返回一个Connection对象；但当使用数据库连接池时（如Druid），返回的实际上是PooledConnection对象，一般情况下，如果连接池中存在PooledConnection对象，则直接返回；否则通过ConnectionPoolDataSource对象的getConnection()方法创建新的连接。\n\n# Driver与DriverManager\nJDBC驱动的实现方式可能有很多种，主要包括以下几种：\n\n * JDBC-ODBC Bridge Driver\n * Native API Driver\n * JDBC-Net Driver\n * Native Protocol Driver\n\n最常使用的就是Native Protocol Driver，通常由数据库厂商直接提供。\n\n所有的JDBC驱动必须实现java.sql.Driver接口，而且实现类包含了一个静态初始化代码块，例如com.mysql.cj.jdbc.Driver中就包含如下代码：\n\nstatic {\n    try {\n        java.sql.DriverManager.registerDriver(new Driver());\n    } catch (SQLException E) {\n        throw new RuntimeException("Can\'t register driver!");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n这也是为什么我们使用JDBC操作数据库时一般会先加载驱动，例如：\n\nClass.forName("com.mysql.cj.jdbc.Driver");\n\n\n1\nDriver接口中提供了一个acceptsURL()方法，DriverManager类可以通过Driver的实现类来调用该方法判断一个给定的URL是否能与数据库成功地建立连接。当我们试图调用DriverManager的getConnection()时，会调用Driver接口的connect()方法。\n\nJDBC 4.0及以上的版本可以不用手动加载驱动，原因是得益于Java的SPI机制，DriverManager可以通过ServiceLoader获取类路径下的所有的驱动，当然前提是这些驱动必须符合SPI的发现机制，比如对于mysql的驱动，在classpath:/META-INF/services/java.sql.Driver文件中保存了mysql的jdbc驱动：\n\ncom.mysql.cj.jdbc.Driver\n\n\n1\n另外，注意不同的JDK版本实现好像有不一致的地方，在Java11中，DriverManager不再是通过静态代码块加载驱动，而是在获取连接时（调用getConnection()时）进行懒加载，具体加载的逻辑在ensureDriversInitialized()方法中。\n\n# DataSource\nDataSource对象用于表示能够提供数据库连接的数据源对象，如果数据库相关的信息发生了变化，则可以简单地修改DataSource对象的属性来反映这些变化，而不用修改应用程序的任何代码。\n\nDataSource接口可以实现来提供以下两种功能：\n\n * 通过连接池提高系统的性能和伸缩性\n * 通过XADataSource接口支持分布式事务。\n\n同DriverManager一样，DataSource也提供了getConnection()方法，该方法同样调用了Driver实现类的connect()方法。\n\n实际项目中更多的是使用DataSource而不是DriverManager，而一般项目中不会直接创建DataSource实例，所以关于这部分内容的分析待后面分析到相应实现时再补充。\n\n# Statement\n前面提到，Statement相当于SQL执行器，该接口内部定义了执行SQL语句的方法。另外，API中还提供了PreparedStatement（继承自Statement）和CallableStatement（继承自PreparedStatement）这两个子接口。\n\n每个Connection实例可以创建多个Statement实例，并可以在创建时指定ResultSet的属性。\n\nStatement中主要定义了三种执行SQL语句的方法：\n\nResultSet executeQuery(String sql) throws SQLException; // 执行查询操作，返回结果集\nint executeUpdate(String sql) throws SQLException; // 执行更新操作（增删改），返回受影响行数\n// 不区分查询还是更新，当返回true时，则表示是查询操作并可以获取ResultSet;如果是false,则表示是更新操作，可以获取受影响行数\nboolean execute(String sql, int autoGeneratedKeys) throws SQLException; \n\n\n1\n2\n3\n4\n关于上述方法的重载以及其他更多方法请参考Statement的API文档。\n\nPreparedStatement接口继承自Statement，在其基础上增加了占位符的功能（占位符为?）。CallableStatement在PreparedStatement的基础上增加了调用存储过程和检索调用结果的功能。\n\nStatemetn执行完SQL后也需要关闭，可以通过调用其close()方法进行关闭，可以通过isClosed()方法判断是否已经关闭了。\n\n# ResultSet\n# 游标操作方式和敏感性\nResultSet提供了检索和操作SQL执行结果相关的方法，其属性主要体现在两个方面：\n\n * 游标可操作的方式。\n * ResultSet对象的修改对数据库的影响（敏感性）。\n\n一共有三种不同类型的ResultSet：\n\n * TYPE_FORWARD_ONLY：不可滚动，游标只能向前移动，从第一行到最后一行，不能向后移动（默认为该值）。\n * TYPE_SCROLL_INSENSITIVE：可滚动，可以相对于当前位置移动，也可以移动到绝对位置。这种类型的ResultSet对数据库不敏感。\n * TYPE_SCROLL_SENSITIVE：可滚动，可以相对于当前位置移动，也可以移动到绝对位置。这种类型的ResultSet对数据库敏感。\n\nDatabaseMetadata接口中提供了一个supportsResultSetType()方法，用于判断数据库驱动是否支持某种类型的ResultSet对象。\n\n# 并行性\nResultSet对象的并行性决定了它支持更新的级别，目前JDBC中支持两个级别：\n\n * CONCUR_READ_ONLY：表示只能从ResultSet对象中读取数据，不能更新数据（默认为该值）。\n * CONCUR_UPDATABLE：表示既可以读取数据，又可以更新数据。\n\nDatabaseMetaData接口中提供了一个supportsResultSetConcurrency()方法，判断JDBC驱动是否支持某一级别的并行性。\n\n# 可保持性\nResultSet的可保持性是指调用Connection的commit()方法后，是否关闭在当前事务中创建的ResultSet对象。下面两个常量可以用来在创建Statement实例时指定ResultSet的可保持性：\n\n * HOLD_CURSORS_OVER_COMMIT：提交事务时，不关闭ResultSet对象。\n * CLOSE_CURSORS_AT_COMMIT：提交事务时，关闭ResultSet对象，从而可以提高性能。\n\n默认可保持性取决于驱动的实现，\n\n# 关闭ResultSet\n在下面两种情况下，ResultSet会被显式地关闭：\n\n * 调用其自身的close()方法。\n * 调用创建ResultSet对象的Statement或相关联的Connection的close()方法。\n\n在下面两种情况下，ResultSet会被隐式地关闭：\n\n * 相关联的Statement实例重复执行时。\n * 可保持性为CLOSE_CURSORS_AT_COMMIT的ResultSet对象在事务提交后会被关闭。\n\n# 事务\nJDBC API中的事务管理符合SQL:2003规范，主要包含下面几个概念：\n\n * 自动提交模式\n * 事务隔离级别\n * 保存点\n\n# DatabaseMetaData\nDatabaseMetaData接口用于提供底层数据源相关的信息，该接口主要用于为应用程序或工具确定如何与底层数据源交互。该接口提供了很多方法，主要可以分为以下几类：\n\n * 获取数据源信息\n * 确定数据源是否支持某一特性或功能\n * 获取数据源限制\n * 确定数据源包含哪些JDBC对象以及这些对象的属性\n * 获取数据源对事务的支持\n\n具体信息请参考对应的Java Doc。\n\n# 常见数据库的驱动实现类名和URL格式\n# MySQL\ncom.mysql.jdbc.Driver // 旧\ncom.mysql.cj.jdbc.Driver // 新\njdbc:mysql://<host>:<port>/<database_name>[?<parameter1&parameter2...>]\n\n\n1\n2\n3\n# Oracle\noracle.jdbc.driver.OracleDriver\njdbc:oracle:@//<host>:<port>/<database_name>\n\n\n1\n2\n# 参考\n * 《MyBatis 3源码深度解析》',normalizedContent:'使用jdbc操作数据源大致需要以下几个步骤：\n\n * 与数据库建立连接\n * 执行sql语句\n * 检索sql执行结果\n * 关闭连接\n\n# 建立数据源连接\njdbc api中定义了connection接口，用来表示与底层数据源的连接。应用程序可以使用两种方式获取connection对象。\n\n * drivermanager：jdbc 1.0规范中就已经存在，完全由jdbc api实现。\n   \n   connection connection = drivermanager.getconection(...);\n   \n   \n   1\n   jdbc 4.0之后的版本，创建connection对象之前，不再需要通过class.forname(driverpath)显示地加载驱动类，drivermanager类通过spi机制加载驱动。drivermanager中有三个getconection()的重载，根据数据库连接信息的不同可以使用不同的重载版本。\n   \n   \n * datasource：这个接口是在jdbc 2.0规范可选包中引入的。它提供了比drivermanager更多的底层数据源相关的细节。相比drivermanager，这种方式不需要对连接信息进行硬编码。第二个优势体现在连接池和分布式事务上。\n   \n   \n\njdbc api中只提供了datasource接口的定义，而没有提供实现，具体的实现由jdbc驱动程序提供，另外一些主流的数据库连接池（如druid）也提供了实现。mybatis框架中也提供了datasource接口的实现，可以通过datasourcefactory来获取。\n\njdbc api中定义了两个datasource接口比较重要的扩展，分别为：\n\n * connectionpooldatasource：支持缓存和复用conection对象，在很大程度上提升应用性能和伸缩性。\n * xadatasource：该实例返回的connection对象能够支持分布式事务。\n\n# 执行sql语句\n因为不同的数据库提供的操作可能会有差别，所以jdbc api中提供了databasemetadata接口，应用程序可以使用该接口实例来确定目前使用的数据源是否支持某一特性。另外，jdbc api中还定义了转义语法，应用程序能够访问jdbc厂商提供的非标准特性。\n\n获取connection对象之后，可以设置事务属性，并创建statement等类型的对象。statement可以理解为jdbc api中提供的sql语句执行器，通过该实例对象调用方法执行相应操作。\n\n# 处理sql语句执行结果\nsql语句执行后，可以通过调用getresultset()方法获取查询结果集，或者通过调用getupdatecount()方法来获取更新操作影响的行数。前者返回resultset类型的实例，可以通过该实例获取结果集。\n\n# 关闭连接\n当我们使用完connection对象后，需要显式地关闭该对象。可以通过close()方法关闭，还可以通过isclosed()方法判断连接是否关闭，同时通过isvalid()方法判断连接是否有效。当连接关闭后或者是无效时，调用除了前面所说的几个方法外，将会抛出sqlexception。\n\n# jdbc api中的类与接口\n前面讲了使用jdbc api的基本过程，jdbc api由java.sql和javax.sql两个包构成。\n\n# java.sql\njava.sql包含了最核心的api，可以把这些api分为数据类型接口，枚举类，驱动相关类和接口，异常类。\n\n\n\n\n\n除了这几类外，还有一些api，主要包括以下几个接口：\n\n\n\n这些接口都继承自java.sql.wrapper，该接口提供了程序访问原始类型的功能，从而使用jdbc驱动中一些非标准的特性。部分接口之间的关系如下图所示（注意不是严格的uml类图）：\n\n\n\n# javax.sql\njavax.sql包中的类和接口最早是由jdbc 2.0版本的可选包提供的，这个可选包最早出现在j2se 1.2版本中。该包主要包括了数据源，连接池相关，resultset的扩展和分布式扩展相关的api：\n\n\n\n两个包的关系体现在通过javax.sql.datasource获取java.sql.connection实例。另外，javax.sql包还提供了一个pooledconnection接口，当应用程序调用datasource对象的getconnection()方法时，返回一个connection对象；但当使用数据库连接池时（如druid），返回的实际上是pooledconnection对象，一般情况下，如果连接池中存在pooledconnection对象，则直接返回；否则通过connectionpooldatasource对象的getconnection()方法创建新的连接。\n\n# driver与drivermanager\njdbc驱动的实现方式可能有很多种，主要包括以下几种：\n\n * jdbc-odbc bridge driver\n * native api driver\n * jdbc-net driver\n * native protocol driver\n\n最常使用的就是native protocol driver，通常由数据库厂商直接提供。\n\n所有的jdbc驱动必须实现java.sql.driver接口，而且实现类包含了一个静态初始化代码块，例如com.mysql.cj.jdbc.driver中就包含如下代码：\n\nstatic {\n    try {\n        java.sql.drivermanager.registerdriver(new driver());\n    } catch (sqlexception e) {\n        throw new runtimeexception("can\'t register driver!");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n这也是为什么我们使用jdbc操作数据库时一般会先加载驱动，例如：\n\nclass.forname("com.mysql.cj.jdbc.driver");\n\n\n1\ndriver接口中提供了一个acceptsurl()方法，drivermanager类可以通过driver的实现类来调用该方法判断一个给定的url是否能与数据库成功地建立连接。当我们试图调用drivermanager的getconnection()时，会调用driver接口的connect()方法。\n\njdbc 4.0及以上的版本可以不用手动加载驱动，原因是得益于java的spi机制，drivermanager可以通过serviceloader获取类路径下的所有的驱动，当然前提是这些驱动必须符合spi的发现机制，比如对于mysql的驱动，在classpath:/meta-inf/services/java.sql.driver文件中保存了mysql的jdbc驱动：\n\ncom.mysql.cj.jdbc.driver\n\n\n1\n另外，注意不同的jdk版本实现好像有不一致的地方，在java11中，drivermanager不再是通过静态代码块加载驱动，而是在获取连接时（调用getconnection()时）进行懒加载，具体加载的逻辑在ensuredriversinitialized()方法中。\n\n# datasource\ndatasource对象用于表示能够提供数据库连接的数据源对象，如果数据库相关的信息发生了变化，则可以简单地修改datasource对象的属性来反映这些变化，而不用修改应用程序的任何代码。\n\ndatasource接口可以实现来提供以下两种功能：\n\n * 通过连接池提高系统的性能和伸缩性\n * 通过xadatasource接口支持分布式事务。\n\n同drivermanager一样，datasource也提供了getconnection()方法，该方法同样调用了driver实现类的connect()方法。\n\n实际项目中更多的是使用datasource而不是drivermanager，而一般项目中不会直接创建datasource实例，所以关于这部分内容的分析待后面分析到相应实现时再补充。\n\n# statement\n前面提到，statement相当于sql执行器，该接口内部定义了执行sql语句的方法。另外，api中还提供了preparedstatement（继承自statement）和callablestatement（继承自preparedstatement）这两个子接口。\n\n每个connection实例可以创建多个statement实例，并可以在创建时指定resultset的属性。\n\nstatement中主要定义了三种执行sql语句的方法：\n\nresultset executequery(string sql) throws sqlexception; // 执行查询操作，返回结果集\nint executeupdate(string sql) throws sqlexception; // 执行更新操作（增删改），返回受影响行数\n// 不区分查询还是更新，当返回true时，则表示是查询操作并可以获取resultset;如果是false,则表示是更新操作，可以获取受影响行数\nboolean execute(string sql, int autogeneratedkeys) throws sqlexception; \n\n\n1\n2\n3\n4\n关于上述方法的重载以及其他更多方法请参考statement的api文档。\n\npreparedstatement接口继承自statement，在其基础上增加了占位符的功能（占位符为?）。callablestatement在preparedstatement的基础上增加了调用存储过程和检索调用结果的功能。\n\nstatemetn执行完sql后也需要关闭，可以通过调用其close()方法进行关闭，可以通过isclosed()方法判断是否已经关闭了。\n\n# resultset\n# 游标操作方式和敏感性\nresultset提供了检索和操作sql执行结果相关的方法，其属性主要体现在两个方面：\n\n * 游标可操作的方式。\n * resultset对象的修改对数据库的影响（敏感性）。\n\n一共有三种不同类型的resultset：\n\n * type_forward_only：不可滚动，游标只能向前移动，从第一行到最后一行，不能向后移动（默认为该值）。\n * type_scroll_insensitive：可滚动，可以相对于当前位置移动，也可以移动到绝对位置。这种类型的resultset对数据库不敏感。\n * type_scroll_sensitive：可滚动，可以相对于当前位置移动，也可以移动到绝对位置。这种类型的resultset对数据库敏感。\n\ndatabasemetadata接口中提供了一个supportsresultsettype()方法，用于判断数据库驱动是否支持某种类型的resultset对象。\n\n# 并行性\nresultset对象的并行性决定了它支持更新的级别，目前jdbc中支持两个级别：\n\n * concur_read_only：表示只能从resultset对象中读取数据，不能更新数据（默认为该值）。\n * concur_updatable：表示既可以读取数据，又可以更新数据。\n\ndatabasemetadata接口中提供了一个supportsresultsetconcurrency()方法，判断jdbc驱动是否支持某一级别的并行性。\n\n# 可保持性\nresultset的可保持性是指调用connection的commit()方法后，是否关闭在当前事务中创建的resultset对象。下面两个常量可以用来在创建statement实例时指定resultset的可保持性：\n\n * hold_cursors_over_commit：提交事务时，不关闭resultset对象。\n * close_cursors_at_commit：提交事务时，关闭resultset对象，从而可以提高性能。\n\n默认可保持性取决于驱动的实现，\n\n# 关闭resultset\n在下面两种情况下，resultset会被显式地关闭：\n\n * 调用其自身的close()方法。\n * 调用创建resultset对象的statement或相关联的connection的close()方法。\n\n在下面两种情况下，resultset会被隐式地关闭：\n\n * 相关联的statement实例重复执行时。\n * 可保持性为close_cursors_at_commit的resultset对象在事务提交后会被关闭。\n\n# 事务\njdbc api中的事务管理符合sql:2003规范，主要包含下面几个概念：\n\n * 自动提交模式\n * 事务隔离级别\n * 保存点\n\n# databasemetadata\ndatabasemetadata接口用于提供底层数据源相关的信息，该接口主要用于为应用程序或工具确定如何与底层数据源交互。该接口提供了很多方法，主要可以分为以下几类：\n\n * 获取数据源信息\n * 确定数据源是否支持某一特性或功能\n * 获取数据源限制\n * 确定数据源包含哪些jdbc对象以及这些对象的属性\n * 获取数据源对事务的支持\n\n具体信息请参考对应的java doc。\n\n# 常见数据库的驱动实现类名和url格式\n# mysql\ncom.mysql.jdbc.driver // 旧\ncom.mysql.cj.jdbc.driver // 新\njdbc:mysql://<host>:<port>/<database_name>[?<parameter1&parameter2...>]\n\n\n1\n2\n3\n# oracle\noracle.jdbc.driver.oracledriver\njdbc:oracle:@//<host>:<port>/<database_name>\n\n\n1\n2\n# 参考\n * 《mybatis 3源码深度解析》',charsets:{cjk:!0}},{title:"JavaScript中的变量与作用域",frontmatter:{title:"JavaScript中的变量与作用域",categories:["编程语言"],tags:["JavaScript"],date:"2021-01-01T15:54:20.000Z",permalink:"/pages/856738/"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.JavaScript/01.%E5%8F%98%E9%87%8F/01.%E5%8F%98%E9%87%8F.html",relativePath:"01.编程语言/02.JavaScript/01.变量/01.变量.md",key:"v-d8f4ec52",path:"/pages/856738/",headers:[{level:2,title:"变量提升",slug:"变量提升",normalizedTitle:"变量提升",charIndex:70},{level:2,title:"块级作用域",slug:"块级作用域",normalizedTitle:"块级作用域",charIndex:859},{level:3,title:"for循环中的块级作用域",slug:"for循环中的块级作用域",normalizedTitle:"for循环中的块级作用域",charIndex:1893}],excerpt:"<p>本文来分析JavaScript中的变量。使用变量之前要进行声明，在JS中可以使用<code>var</code>，<code>let</code>和<code>const</code>（后两者是ES6引入的）。</p>\n",lastUpdated:"2021-01-21",headersStr:"变量提升 块级作用域 for循环中的块级作用域",content:'本文来分析JavaScript中的变量。使用变量之前要进行声明，在JS中可以使用var，let和const（后两者是ES6引入的）。\n\n# 变量提升\n对于var，所声明的变量有两个作用域：全局作用域和函数作用域。对于全局作用域中声明的变量会绑定到window对象上，造成全局污染。\n\nvar a = 1\nconsole.log(a === window.a) // true\n\n\n1\n2\n另外var声明具有变量提升机制。可以在变量声明之前访问该变量。\n\nconsole.log(a) // undefined\nvar a = 10\n\n\n1\n2\n上面的代码被JS引擎解析后的执行步骤变成了下面这样子：\n\nvar a\nconsole.log(a) // undefined\na = 10\n\n\n1\n2\n3\n上面这种效果就被称为变量提升（hoisting），另外在函数作用域中也存在变量提升：\n\nfunction foo() {\n  if(condition) {\n    var a = 10\n    console.log(a)\n  } else {\n    console.log(a)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n上面的代码会被解释为：\n\nfunction foo() {\n  var a\n  if(condition) {\n    a = 10\n    console.log(a)\n  } else {\n    console.log(a)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n提示\n\n另外，在全局作用域中，不使用任何关键字声明变量也可以：\n\na = 10\nconsole.log(a) // 10\nconsole.log(window.a === a) // true\n\n\n1\n2\n3\n但是下面这种方式就会报错了（ReferenceError）：\n\nconsole.log(a)\na = 10\n\n\n1\n2\n最好别使用这种方式和var关键字，使用let和const代替。\n\n# 块级作用域\nlet和const在全局作用域中声明的变量，不会绑定到window对象上。\n\nlet b = 2;\nconst c = 3;\nconsole.log(window.b === b); // false\nconsole.log(window.c === c); // false\n\n\n1\n2\n3\n4\n另外不管是在全局或函数作用域中，也不具有var的那种变量提升效果。\n\nconsole.log(a) // ReferenceError\nlet a = 10\n\nfunction foo() {\n  if(condition) {\n    var a = 10\n    console.log(a)\n  } else {\n    console.log(a) // ReferenceError\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n实际上，JavaScript引擎在扫描代码发现变量声明时，要么将它们提升至作用域顶部（遇到var声明），要么将声明放入暂时性死区（TDZ）中（遇到let和const声明时）。访问TDZ中的变量会触发运行错误，只有执行过变量声明语句后，变量才会从TDZ中移出，才可正常访问。\n\nlet和const具有块级作用域，通常指函数和由{}包裹的区域。\n\nlet msg = "msg"\nfunction fun() {\n    console.log(msg)\n    let msg = "msg1"\n}\n\n\n1\n2\n3\n4\n5\n注意，上述代码会报错，和其他很多语言不一样，JS中块级作用域内不能存在先使用后声明的变量。\n\n所以，下面两种修改都是OK的。\n\nlet msg = "msg"\nfunction fun() {\n    console.log(msg) // output: msg\n}\n\n\n1\n2\n3\n4\nlet msg = "msg"\nfunction fun() {\n    let msg = "msg1"\n    console.log(msg) // output: msg1\n}\n\n\n1\n2\n3\n4\n5\n提示\n\nconst和let类似，不过前者是用来定义常量的，这种常量直到被回收时都不能改变值。当该值类型是引用时，可以更改该引用中的值，但是不能指向其他引用。\n\n可以发现，JavaScript中关于变量声明是非常复杂的。在使用时遵循先声明后使用的原则，尽量不要使用var。\n\n# for循环中的块级作用域\nvar i = 100\nfor(var i = 1; i < 5; ++i) {\n    console.log(i)\n}\nconsole.log(i) // output: 5\n\n\n1\n2\n3\n4\n5\n注意，和其他很多语言不一样的是，for循环里面的var变量声明没有块级作用域，导致修改了全局变量。只需要把for循环处的var改为let即可。\n\nvar i = 100\nfor(let i = 1; i < 5; ++i) {\n    console.log(i)\n}\nconsole.log(i) // output: 100\n\n\n1\n2\n3\n4\n5\n再次说明，不要使用var。（太难了~ 😢）',normalizedContent:'本文来分析javascript中的变量。使用变量之前要进行声明，在js中可以使用var，let和const（后两者是es6引入的）。\n\n# 变量提升\n对于var，所声明的变量有两个作用域：全局作用域和函数作用域。对于全局作用域中声明的变量会绑定到window对象上，造成全局污染。\n\nvar a = 1\nconsole.log(a === window.a) // true\n\n\n1\n2\n另外var声明具有变量提升机制。可以在变量声明之前访问该变量。\n\nconsole.log(a) // undefined\nvar a = 10\n\n\n1\n2\n上面的代码被js引擎解析后的执行步骤变成了下面这样子：\n\nvar a\nconsole.log(a) // undefined\na = 10\n\n\n1\n2\n3\n上面这种效果就被称为变量提升（hoisting），另外在函数作用域中也存在变量提升：\n\nfunction foo() {\n  if(condition) {\n    var a = 10\n    console.log(a)\n  } else {\n    console.log(a)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n上面的代码会被解释为：\n\nfunction foo() {\n  var a\n  if(condition) {\n    a = 10\n    console.log(a)\n  } else {\n    console.log(a)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n提示\n\n另外，在全局作用域中，不使用任何关键字声明变量也可以：\n\na = 10\nconsole.log(a) // 10\nconsole.log(window.a === a) // true\n\n\n1\n2\n3\n但是下面这种方式就会报错了（referenceerror）：\n\nconsole.log(a)\na = 10\n\n\n1\n2\n最好别使用这种方式和var关键字，使用let和const代替。\n\n# 块级作用域\nlet和const在全局作用域中声明的变量，不会绑定到window对象上。\n\nlet b = 2;\nconst c = 3;\nconsole.log(window.b === b); // false\nconsole.log(window.c === c); // false\n\n\n1\n2\n3\n4\n另外不管是在全局或函数作用域中，也不具有var的那种变量提升效果。\n\nconsole.log(a) // referenceerror\nlet a = 10\n\nfunction foo() {\n  if(condition) {\n    var a = 10\n    console.log(a)\n  } else {\n    console.log(a) // referenceerror\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n实际上，javascript引擎在扫描代码发现变量声明时，要么将它们提升至作用域顶部（遇到var声明），要么将声明放入暂时性死区（tdz）中（遇到let和const声明时）。访问tdz中的变量会触发运行错误，只有执行过变量声明语句后，变量才会从tdz中移出，才可正常访问。\n\nlet和const具有块级作用域，通常指函数和由{}包裹的区域。\n\nlet msg = "msg"\nfunction fun() {\n    console.log(msg)\n    let msg = "msg1"\n}\n\n\n1\n2\n3\n4\n5\n注意，上述代码会报错，和其他很多语言不一样，js中块级作用域内不能存在先使用后声明的变量。\n\n所以，下面两种修改都是ok的。\n\nlet msg = "msg"\nfunction fun() {\n    console.log(msg) // output: msg\n}\n\n\n1\n2\n3\n4\nlet msg = "msg"\nfunction fun() {\n    let msg = "msg1"\n    console.log(msg) // output: msg1\n}\n\n\n1\n2\n3\n4\n5\n提示\n\nconst和let类似，不过前者是用来定义常量的，这种常量直到被回收时都不能改变值。当该值类型是引用时，可以更改该引用中的值，但是不能指向其他引用。\n\n可以发现，javascript中关于变量声明是非常复杂的。在使用时遵循先声明后使用的原则，尽量不要使用var。\n\n# for循环中的块级作用域\nvar i = 100\nfor(var i = 1; i < 5; ++i) {\n    console.log(i)\n}\nconsole.log(i) // output: 5\n\n\n1\n2\n3\n4\n5\n注意，和其他很多语言不一样的是，for循环里面的var变量声明没有块级作用域，导致修改了全局变量。只需要把for循环处的var改为let即可。\n\nvar i = 100\nfor(let i = 1; i < 5; ++i) {\n    console.log(i)\n}\nconsole.log(i) // output: 100\n\n\n1\n2\n3\n4\n5\n再次说明，不要使用var。（太难了~ 😢）',charsets:{cjk:!0}},{title:"JavaScript中的数组",frontmatter:{title:"JavaScript中的数组",categories:["编程语言"],tags:["JavaScript"],date:"2021-01-02T17:11:40.000Z",permalink:"/pages/fb73c5/"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.JavaScript/02.%E6%95%B0%E7%BB%84/01.%E6%95%B0%E7%BB%84.html",relativePath:"01.编程语言/02.JavaScript/02.数组/01.数组.md",key:"v-4e5c5b42",path:"/pages/fb73c5/",headers:[{level:2,title:"创建数组",slug:"创建数组",normalizedTitle:"创建数组",charIndex:58},{level:2,title:"类型与检测",slug:"类型与检测",normalizedTitle:"类型与检测",charIndex:36},{level:2,title:"解构赋值",slug:"解构赋值",normalizedTitle:"解构赋值",charIndex:518},{level:2,title:"元素操作",slug:"元素操作",normalizedTitle:"元素操作",charIndex:42},{level:3,title:"添加元素",slug:"添加元素",normalizedTitle:"添加元素",charIndex:667},{level:3,title:"移除元素",slug:"移除元素",normalizedTitle:"移除元素",charIndex:963},{level:3,title:"填充元素",slug:"填充元素",normalizedTitle:"填充元素",charIndex:1093},{level:3,title:"数组截取",slug:"数组截取",normalizedTitle:"数组截取",charIndex:1467},{level:3,title:"清空元素",slug:"清空元素",normalizedTitle:"清空元素",charIndex:2149},{level:3,title:"数组的拆分和合并",slug:"数组的拆分和合并",normalizedTitle:"数组的拆分和合并",charIndex:2292},{level:3,title:"元素查找",slug:"元素查找",normalizedTitle:"元素查找",charIndex:2537},{level:2,title:"数组排序",slug:"数组排序",normalizedTitle:"数组排序",charIndex:2837},{level:2,title:"数组遍历",slug:"数组遍历",normalizedTitle:"数组遍历",charIndex:2898}],excerpt:"<p>本文总结了一些JavaScript中关于数组的常用操作，包括数组的创建，类型与检测和元素操作，排序和遍历等。</p>\n",lastUpdated:"2021-01-23",headersStr:"创建数组 类型与检测 解构赋值 元素操作 添加元素 移除元素 填充元素 数组截取 清空元素 数组的拆分和合并 元素查找 数组排序 数组遍历",content:'本文总结了一些JavaScript中关于数组的常用操作，包括数组的创建，类型与检测和元素操作，排序和遍历等。\n\n# 创建数组\nlet hd= ["hdcms"]\nhd[3] = "houdunren"\nconsole.log(hd) // 自动扩充 ["hdcms", undefined, undefined, "houdunren"] \n\nlet array = new Array(6, 7, 9); // array.length === 3\narray = new Array(6); // array.length === 6\narray = Array.of(6); // array.length === 1\n\n\n1\n2\n3\n4\n5\n6\n7\n注意使用new Array(var)方式创建数组，如果参数var只是一个数字，会导致创建一个长度为var的数组，而不是一个长度为1且只包含值var的数组，所以可以用Array.of(vars)来解决这个问题。\n\n一般对象有length属性，那么可以通过Array.from()将参数转化为数组。\n\n将可变参数转化为数组。\n\n# 类型与检测\n * isArray(var)\n\n# 解构赋值\nlet arr = ["A", "B"]\nlet [arg1, arg2] = arr\n// arg1 === "A"\n// arg2 === "B"\n\n\n1\n2\n3\n4\nconst [... arr] = "abcdefg"\n// arr为对应的字符数组\n\n\n1\n2\n# 元素操作\n# 添加元素\n下面是几种添加元素的方式：\n\nlet array = ["A", "B", "C"]\narray[array.length] = "D"\narray[array.length] = "E"\n\nlet array2 = ["AA", "BB"]\narray = [...array, ...array2] // 也可以实现添加操作\n\nlet length = array.push("AAA", "AAAA") // 在数组末尾添加元素\nlength = array.unshift("BBB", "BBBB") // 在数组开头添加元素\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 移除元素\nlet array = ["A", "B", "C"]\nlet obj = array.pop() // obj: "C" 从数组后面移除元素\nobj = array.shift(); // obj: "A" 从数组前面移除元素\n\n\n1\n2\n3\n# 填充元素\nlet array = Array(5).fill("A") // 填充元素\narray = ["A", "B", "C"]\narray.fill("AAA", 1, 2) // 可以实现元素替换\n\n\n1\n2\n3\n关于fill()：\n\n/**\n* start: 默认值为0\n* end: 默认值为数组长度\n* 如果start为负，将被转换为array.length + start\n* 如果end为负，将被转换为array.length + end\n* 如果start大于等于end,则没有任何效果\n* 如果start超过length,则没有什么效果\n* 如果end超过length，则只对数组内的有效数据有效果\n*/\narray.fill(value[, start[, end]])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 数组截取\nlet array = [1, 2, 3, 4, 5]\nlet res = array.slice(2, 5)\nconsole.log(res) // output: [3, 4, 5]\nres = array.splice(2, 2)\nconsole.log(res) // output: [3, 4]\n\n\n1\n2\n3\n4\n5\n关于slice()：\n\n/**\n* 如果start为undefined，将被视为0\n* 如果start超过了length，则返回空数组\n* 如果end为undefined，将被视为length\n* 如果end大于了length，将被视为length\n* 返回一个包含被截取元素的新数组\n*/\narray.slice([start[, end]])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n关于splice()：\n\n/**\n* 如果start为负，则被视为倒数第|start|个\n* 如果start大于了length，则被视为length\n* 如果deleteCount被省略了，或者是其值超过了可以被删除的范围，那么从start开始的所有元素都会被删除\n* item* 是加入到start开始处的一些元素\n* 返回被删除的元素组成的新数组\n*/\narray.splice(start[, deleteCount[, item1[, item2[, ...]]]])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nsplice()可以用于在任何位置插入元素，替换元素和删除元素。可以用来实现数组的移动，即将某个元素移动到指定位置。\n\n# 清空元素\n下面展示了四种清空数组的方法：\n\nlet array = [1, 2, 3, 4, 5]\nwhile(array.pop()){}\narray.splice(0, array.length)\narray.length = 0\narray = []\n\n\n1\n2\n3\n4\n5\n# 数组的拆分和合并\nlet A = [1, 2, 3]\nlet B = [4, 5, 6]\nconsole.log(A.concat(B))\nconsole.log([...A, ...B])\n\n\n1\n2\n3\n4\n另外，还可以采用copyWithin():\n\n/**\n* target: 拷贝目标位置下标，如果等于或大于length，那么什么也不会被拷贝。更多信息请参考MDN。\n*/\narray.copyWithin(target[, start[, end]])\n\n\n1\n2\n3\n4\n# 元素查找\nlet array = [1, 2, 3, 4, 5]\nlet index1 = array.indexOf(3)\nlet index2 = array.lastIndexOf(4)\nlet isExist = array.includes(3) // 返回布尔型\n\n\n1\n2\n3\n4\n还可以使用find()和findIndex()实现自定义查找逻辑。\n\nlet array = [1, 2, 3, 4, 5]\nlet res = array.find((item) => {\n    return item === 2\n})\nconsole.log(res)\n\n\n1\n2\n3\n4\n5\n# 数组排序\n * sort()，默认升序排序，可以提供自定义的策略，注意是对数据进行就地排序，而非先复制数组再排序。\n\n# 数组遍历\n * for\n   \n   \n * for of：遍历的是值，如果用来遍历对象，则是对象属性的值。\n   \n   \n * for in：遍历的是索引，如果用来遍历对象，则是对象属性的键的名称。\n   \n   \n * foreach(item, index, target)：target是被遍历的对象。\n   \n   \n\n迭代器操作：\n\n * array.keys()：返回数组下标相关的迭代器。\n   \n   \n * array.values()：返回数组元素相关的迭代器。\n   \n   \n * array.entries()：返回关于数组迭代相关的迭代器。\n   \n   \n\n其他操作：\n\n * every(prediction)：该函数将断言应用在每个元素上，如果每个元素都返回true，那么最后结果为true；否则返回为false。\n   \n   \n * some(prediction)：该函数将断言应用在元素上，直到应用到某个元素返回true时。\n   \n   \n * filter(prediction)：过滤元素，返回新数组。\n   \n   \n * map(function)：映射，返回新数组。\n   \n   \n * reduce(function)：归约操作。',normalizedContent:'本文总结了一些javascript中关于数组的常用操作，包括数组的创建，类型与检测和元素操作，排序和遍历等。\n\n# 创建数组\nlet hd= ["hdcms"]\nhd[3] = "houdunren"\nconsole.log(hd) // 自动扩充 ["hdcms", undefined, undefined, "houdunren"] \n\nlet array = new array(6, 7, 9); // array.length === 3\narray = new array(6); // array.length === 6\narray = array.of(6); // array.length === 1\n\n\n1\n2\n3\n4\n5\n6\n7\n注意使用new array(var)方式创建数组，如果参数var只是一个数字，会导致创建一个长度为var的数组，而不是一个长度为1且只包含值var的数组，所以可以用array.of(vars)来解决这个问题。\n\n一般对象有length属性，那么可以通过array.from()将参数转化为数组。\n\n将可变参数转化为数组。\n\n# 类型与检测\n * isarray(var)\n\n# 解构赋值\nlet arr = ["a", "b"]\nlet [arg1, arg2] = arr\n// arg1 === "a"\n// arg2 === "b"\n\n\n1\n2\n3\n4\nconst [... arr] = "abcdefg"\n// arr为对应的字符数组\n\n\n1\n2\n# 元素操作\n# 添加元素\n下面是几种添加元素的方式：\n\nlet array = ["a", "b", "c"]\narray[array.length] = "d"\narray[array.length] = "e"\n\nlet array2 = ["aa", "bb"]\narray = [...array, ...array2] // 也可以实现添加操作\n\nlet length = array.push("aaa", "aaaa") // 在数组末尾添加元素\nlength = array.unshift("bbb", "bbbb") // 在数组开头添加元素\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n# 移除元素\nlet array = ["a", "b", "c"]\nlet obj = array.pop() // obj: "c" 从数组后面移除元素\nobj = array.shift(); // obj: "a" 从数组前面移除元素\n\n\n1\n2\n3\n# 填充元素\nlet array = array(5).fill("a") // 填充元素\narray = ["a", "b", "c"]\narray.fill("aaa", 1, 2) // 可以实现元素替换\n\n\n1\n2\n3\n关于fill()：\n\n/**\n* start: 默认值为0\n* end: 默认值为数组长度\n* 如果start为负，将被转换为array.length + start\n* 如果end为负，将被转换为array.length + end\n* 如果start大于等于end,则没有任何效果\n* 如果start超过length,则没有什么效果\n* 如果end超过length，则只对数组内的有效数据有效果\n*/\narray.fill(value[, start[, end]])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 数组截取\nlet array = [1, 2, 3, 4, 5]\nlet res = array.slice(2, 5)\nconsole.log(res) // output: [3, 4, 5]\nres = array.splice(2, 2)\nconsole.log(res) // output: [3, 4]\n\n\n1\n2\n3\n4\n5\n关于slice()：\n\n/**\n* 如果start为undefined，将被视为0\n* 如果start超过了length，则返回空数组\n* 如果end为undefined，将被视为length\n* 如果end大于了length，将被视为length\n* 返回一个包含被截取元素的新数组\n*/\narray.slice([start[, end]])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n关于splice()：\n\n/**\n* 如果start为负，则被视为倒数第|start|个\n* 如果start大于了length，则被视为length\n* 如果deletecount被省略了，或者是其值超过了可以被删除的范围，那么从start开始的所有元素都会被删除\n* item* 是加入到start开始处的一些元素\n* 返回被删除的元素组成的新数组\n*/\narray.splice(start[, deletecount[, item1[, item2[, ...]]]])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\nsplice()可以用于在任何位置插入元素，替换元素和删除元素。可以用来实现数组的移动，即将某个元素移动到指定位置。\n\n# 清空元素\n下面展示了四种清空数组的方法：\n\nlet array = [1, 2, 3, 4, 5]\nwhile(array.pop()){}\narray.splice(0, array.length)\narray.length = 0\narray = []\n\n\n1\n2\n3\n4\n5\n# 数组的拆分和合并\nlet a = [1, 2, 3]\nlet b = [4, 5, 6]\nconsole.log(a.concat(b))\nconsole.log([...a, ...b])\n\n\n1\n2\n3\n4\n另外，还可以采用copywithin():\n\n/**\n* target: 拷贝目标位置下标，如果等于或大于length，那么什么也不会被拷贝。更多信息请参考mdn。\n*/\narray.copywithin(target[, start[, end]])\n\n\n1\n2\n3\n4\n# 元素查找\nlet array = [1, 2, 3, 4, 5]\nlet index1 = array.indexof(3)\nlet index2 = array.lastindexof(4)\nlet isexist = array.includes(3) // 返回布尔型\n\n\n1\n2\n3\n4\n还可以使用find()和findindex()实现自定义查找逻辑。\n\nlet array = [1, 2, 3, 4, 5]\nlet res = array.find((item) => {\n    return item === 2\n})\nconsole.log(res)\n\n\n1\n2\n3\n4\n5\n# 数组排序\n * sort()，默认升序排序，可以提供自定义的策略，注意是对数据进行就地排序，而非先复制数组再排序。\n\n# 数组遍历\n * for\n   \n   \n * for of：遍历的是值，如果用来遍历对象，则是对象属性的值。\n   \n   \n * for in：遍历的是索引，如果用来遍历对象，则是对象属性的键的名称。\n   \n   \n * foreach(item, index, target)：target是被遍历的对象。\n   \n   \n\n迭代器操作：\n\n * array.keys()：返回数组下标相关的迭代器。\n   \n   \n * array.values()：返回数组元素相关的迭代器。\n   \n   \n * array.entries()：返回关于数组迭代相关的迭代器。\n   \n   \n\n其他操作：\n\n * every(prediction)：该函数将断言应用在每个元素上，如果每个元素都返回true，那么最后结果为true；否则返回为false。\n   \n   \n * some(prediction)：该函数将断言应用在元素上，直到应用到某个元素返回true时。\n   \n   \n * filter(prediction)：过滤元素，返回新数组。\n   \n   \n * map(function)：映射，返回新数组。\n   \n   \n * reduce(function)：归约操作。',charsets:{cjk:!0}},{title:"JavaScript中的字符串",frontmatter:{title:"JavaScript中的字符串",categories:["编程语言"],tags:["JavaScript"],date:"2021-01-01T17:08:56.000Z",permalink:"/pages/62d559"},regularPath:"/01.%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/02.JavaScript/03.%E5%AD%97%E7%AC%A6%E4%B8%B2/01.%E5%AD%97%E7%AC%A6%E4%B8%B2.html",relativePath:"01.编程语言/02.JavaScript/03.字符串/01.字符串.md",key:"v-8f833ce6",path:"/pages/62d559/",headers:[{level:2,title:"模板字符串",slug:"模板字符串",normalizedTitle:"模板字符串",charIndex:34},{level:3,title:"模板字符串嵌套",slug:"模板字符串嵌套",normalizedTitle:"模板字符串嵌套",charIndex:42},{level:3,title:"标签模板",slug:"标签模板",normalizedTitle:"标签模板",charIndex:183},{level:2,title:"字符串截取",slug:"字符串截取",normalizedTitle:"字符串截取",charIndex:1502},{level:3,title:"substring()",slug:"substring",normalizedTitle:"substring()",charIndex:1510},{level:3,title:"substr()",slug:"substr",normalizedTitle:"substr()",charIndex:1915},{level:3,title:"slice()",slug:"slice",normalizedTitle:"slice()",charIndex:2227},{level:2,title:"字符串检索",slug:"字符串检索",normalizedTitle:"字符串检索",charIndex:2609},{level:2,title:"重复字符串",slug:"重复字符串",normalizedTitle:"重复字符串",charIndex:2730},{level:2,title:"类型转换",slug:"类型转换",normalizedTitle:"类型转换",charIndex:2760},{level:3,title:"字符串转化为数值",slug:"字符串转化为数值",normalizedTitle:"字符串转化为数值",charIndex:2767},{level:3,title:"数值转化为字符串",slug:"数值转化为字符串",normalizedTitle:"数值转化为字符串",charIndex:2927},{level:3,title:"字符串转化为数组",slug:"字符串转化为数组",normalizedTitle:"字符串转化为数组",charIndex:3081},{level:3,title:"字符串数组转化为字符串",slug:"字符串数组转化为字符串",normalizedTitle:"字符串数组转化为字符串",charIndex:3250}],excerpt:"<p>本文归纳总结了JavaScript中关于字符串最常用的操作。</p>\n",lastUpdated:"2021-01-22",headersStr:"模板字符串 模板字符串嵌套 标签模板 字符串截取 substring() substr() slice() 字符串检索 重复字符串 类型转换 字符串转化为数值 数值转化为字符串 字符串转化为数组 字符串数组转化为字符串",content:'本文归纳总结了JavaScript中关于字符串最常用的操作。\n\n# 模板字符串\n# 模板字符串嵌套\nlet a = 1\nlet b = 2\nlet str = `--------${a + `${b}`}---------`\nconsole.log(str) // output: 12\n\n\n1\n2\n3\n4\n注意，只能是在${}内嵌套，而不能在其他位置嵌套。\n\n# 标签模板\nconst name = "HarrisonLee"\nconst age = 22\nconst msg = tag`姓名：${name}, 年龄：${age}`\nfunction tag(strings, ...vars) {\n    console.log(strings)\n    console.log(vars)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n执行以上代码，输出结果如下面所示：\n\n["姓名：", ", 年龄：", ""]\n["HarrisonLee", 22]\n\n\n1\n2\nstrings是由${}分割后的字符串数组，而变长参数包含了标签字符串中的所有参数的值。可以利用该特性来对模板字符串中某些值进行处理。下面是一个简单的例子：\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>Document</title>\n</head>\n<body>\n  <div id="contents"></div>\n  <script>\n    const contents = [\n      {brand: "宝马", content: "宝马的总裁跳槽到奔驰"},\n      {brand: "奔驰", content: "奔驰的总裁跳槽到奥迪"},\n      {brand: "奥迪", content: "奥迪的总裁跳槽到宝马"}\n    ]\n    const msg = `${contents.map(item => \n      highlight`<li>品牌: ${item.brand}, 内容：${item.content}</li>`).join("")}`\n    function highlight(strings, ...vars) {\n      return strings.map((str, key) => {\n        return (str + (vars[key] \n        ? vars[key].replace(\'跳槽\', `<a href="https://www.lagou.com">跳槽<a/>`) \n        : ""))\n      }).join("")\n    }\n    console.log(msg)\n    document.getElementById("contents").innerHTML = msg\n  <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n上面把数组contents中每个元素转换成一个列表元素，但是对列表中的内容中含有“跳槽”二字转化为超链接，上面就利用了标签模板字符串进行处理。\n\n# 字符串截取\n# substring()\nstring.slice(start[, end])\n\n\n1\n使用需要注意以下几点：\n\n * substring()从提取的字符start可达但不包括end。\n   \n   \n * 如果start等于end，substring()返回一个空字符串。\n   \n   \n * 如果end省略，则将substring()字符提取到字符串的末尾。\n   \n   \n * 如果任一参数小于0或是NaN，它被视为为0。\n   \n   \n * 如果任何一个参数都大于string.length，则被视为是string.length。\n   \n   \n * 如果start大于end，那么效果substring()就好像这两个点被交换了一样，例如:\n   \n   string.substring(1, 0) == string.substring(0, 1)\n   \n   \n   1\n   \n\n# substr()\nstring.substr(start[, length])\n\n\n1\n使用需要注意以下几点：\n\n * substr()会从start获取长度为length字符（如果截取到字符串的末尾，则会停止截取）。\n   \n   \n * 如果start大于或等于字符串的长度，则substr()返回一个空字符串。\n   \n   \n * 若start为负数,则将该值加上字符串长度后再进行计算（如果加上字符串的长度后还是负数，则从0开始截取）。\n   \n   \n * 如果length为0或为负数，substr()返回一个空字符串。如果length省略，则将substr()字符提取到字符串的末尾。\n   \n   \n\n# slice()\nslice()方法返回一个索引和另一个索引之间的字符串， 和substring()类似。\n\nstr.slice(beginIndex[, endIndex])\n\n\n1\n * 若beginIndex为负数，则将该值加上字符串长度后再进行计算（如果加上字符串的长度后还是负数，则视作0）。\n * 如果beginIndex大于或等于字符串的长度，则slice()返回一个空字符串。\n * 如果endIndex省略，则将slice()字符提取到字符串的末尾。如果为负，它被视为strLength + endIndex，其中strLength是字符串的长度（如果加上字符串的长度后还是负数，则视作0）。\n * 如果beginIndex大于endIndex，返回空字符串。\n\n提示\n\n这三个函数都不会改变原字符串，会在原字符串的副本上操作然后返回结果。\n\n# 字符串检索\n * number indexOf()\n * number lastIndexOf()\n * boolean includes()\n * boolean startsWith()\n * boolean endsWith()\n\n# 重复字符串\n * str.repeat(times)\n\n# 类型转换\n# 字符串转化为数值\n * Number(string)\n * string * 1\n\nconst string = "99"\nconsole.log(typeof (string * 1)) // number\nconsole.log(typeof Number(string)) // number\n\n\n1\n2\n3\n# 数值转化为字符串\n * number + ""\n * String()\n\nconst string = 99\nconsole.log(typeof (string + "")) // string\nconsole.log(typeof String(string)) // string\n\n\n1\n2\n3\n# 字符串转化为数组\nconst string = "harrisonlee.net"\nconsole.log(string.split(""))\n// output: ["h", "a", "r", "r", "i", "s", "o", "n", "l", "e", "e", ".", "n", "e", "t"]\n\n\n1\n2\n3\n# 字符串数组转化为字符串\nconst array = ["harrison", "lee", ".net"]\nconsole.log(array.join("")) // output: harrisonlee.net\nconsole.log(array.toString()) // output: harrison,lee,.net // 注意逗号\n\n\n1\n2\n3',normalizedContent:'本文归纳总结了javascript中关于字符串最常用的操作。\n\n# 模板字符串\n# 模板字符串嵌套\nlet a = 1\nlet b = 2\nlet str = `--------${a + `${b}`}---------`\nconsole.log(str) // output: 12\n\n\n1\n2\n3\n4\n注意，只能是在${}内嵌套，而不能在其他位置嵌套。\n\n# 标签模板\nconst name = "harrisonlee"\nconst age = 22\nconst msg = tag`姓名：${name}, 年龄：${age}`\nfunction tag(strings, ...vars) {\n    console.log(strings)\n    console.log(vars)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n执行以上代码，输出结果如下面所示：\n\n["姓名：", ", 年龄：", ""]\n["harrisonlee", 22]\n\n\n1\n2\nstrings是由${}分割后的字符串数组，而变长参数包含了标签字符串中的所有参数的值。可以利用该特性来对模板字符串中某些值进行处理。下面是一个简单的例子：\n\n<!doctype html>\n<html lang="en">\n<head>\n  <meta charset="utf-8">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>document</title>\n</head>\n<body>\n  <div id="contents"></div>\n  <script>\n    const contents = [\n      {brand: "宝马", content: "宝马的总裁跳槽到奔驰"},\n      {brand: "奔驰", content: "奔驰的总裁跳槽到奥迪"},\n      {brand: "奥迪", content: "奥迪的总裁跳槽到宝马"}\n    ]\n    const msg = `${contents.map(item => \n      highlight`<li>品牌: ${item.brand}, 内容：${item.content}</li>`).join("")}`\n    function highlight(strings, ...vars) {\n      return strings.map((str, key) => {\n        return (str + (vars[key] \n        ? vars[key].replace(\'跳槽\', `<a href="https://www.lagou.com">跳槽<a/>`) \n        : ""))\n      }).join("")\n    }\n    console.log(msg)\n    document.getelementbyid("contents").innerhtml = msg\n  <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n上面把数组contents中每个元素转换成一个列表元素，但是对列表中的内容中含有“跳槽”二字转化为超链接，上面就利用了标签模板字符串进行处理。\n\n# 字符串截取\n# substring()\nstring.slice(start[, end])\n\n\n1\n使用需要注意以下几点：\n\n * substring()从提取的字符start可达但不包括end。\n   \n   \n * 如果start等于end，substring()返回一个空字符串。\n   \n   \n * 如果end省略，则将substring()字符提取到字符串的末尾。\n   \n   \n * 如果任一参数小于0或是nan，它被视为为0。\n   \n   \n * 如果任何一个参数都大于string.length，则被视为是string.length。\n   \n   \n * 如果start大于end，那么效果substring()就好像这两个点被交换了一样，例如:\n   \n   string.substring(1, 0) == string.substring(0, 1)\n   \n   \n   1\n   \n\n# substr()\nstring.substr(start[, length])\n\n\n1\n使用需要注意以下几点：\n\n * substr()会从start获取长度为length字符（如果截取到字符串的末尾，则会停止截取）。\n   \n   \n * 如果start大于或等于字符串的长度，则substr()返回一个空字符串。\n   \n   \n * 若start为负数,则将该值加上字符串长度后再进行计算（如果加上字符串的长度后还是负数，则从0开始截取）。\n   \n   \n * 如果length为0或为负数，substr()返回一个空字符串。如果length省略，则将substr()字符提取到字符串的末尾。\n   \n   \n\n# slice()\nslice()方法返回一个索引和另一个索引之间的字符串， 和substring()类似。\n\nstr.slice(beginindex[, endindex])\n\n\n1\n * 若beginindex为负数，则将该值加上字符串长度后再进行计算（如果加上字符串的长度后还是负数，则视作0）。\n * 如果beginindex大于或等于字符串的长度，则slice()返回一个空字符串。\n * 如果endindex省略，则将slice()字符提取到字符串的末尾。如果为负，它被视为strlength + endindex，其中strlength是字符串的长度（如果加上字符串的长度后还是负数，则视作0）。\n * 如果beginindex大于endindex，返回空字符串。\n\n提示\n\n这三个函数都不会改变原字符串，会在原字符串的副本上操作然后返回结果。\n\n# 字符串检索\n * number indexof()\n * number lastindexof()\n * boolean includes()\n * boolean startswith()\n * boolean endswith()\n\n# 重复字符串\n * str.repeat(times)\n\n# 类型转换\n# 字符串转化为数值\n * number(string)\n * string * 1\n\nconst string = "99"\nconsole.log(typeof (string * 1)) // number\nconsole.log(typeof number(string)) // number\n\n\n1\n2\n3\n# 数值转化为字符串\n * number + ""\n * string()\n\nconst string = 99\nconsole.log(typeof (string + "")) // string\nconsole.log(typeof string(string)) // string\n\n\n1\n2\n3\n# 字符串转化为数组\nconst string = "harrisonlee.net"\nconsole.log(string.split(""))\n// output: ["h", "a", "r", "r", "i", "s", "o", "n", "l", "e", "e", ".", "n", "e", "t"]\n\n\n1\n2\n3\n# 字符串数组转化为字符串\nconst array = ["harrison", "lee", ".net"]\nconsole.log(array.join("")) // output: harrisonlee.net\nconsole.log(array.tostring()) // output: harrison,lee,.net // 注意逗号\n\n\n1\n2\n3',charsets:{cjk:!0}},{title:"二叉树的遍历",frontmatter:{title:"二叉树的遍历",categories:["数据结构与算法"],tags:["二叉树"],date:"2020-10-22T00:00:00.000Z",permalink:"/pages/73d51c/"},regularPath:"/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/01.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86.html",relativePath:"02.数据结构与算法/01.二叉树的遍历.md",key:"v-4752b513",path:"/pages/73d51c/",headers:[{level:2,title:"前序遍历",slug:"前序遍历",normalizedTitle:"前序遍历",charIndex:631},{level:3,title:"递归",slug:"递归",normalizedTitle:"递归",charIndex:58},{level:3,title:"非递归",slug:"非递归",normalizedTitle:"非递归",charIndex:57},{level:2,title:"中序遍历",slug:"中序遍历",normalizedTitle:"中序遍历",charIndex:1492},{level:3,title:"递归",slug:"递归-2",normalizedTitle:"递归",charIndex:58},{level:3,title:"非递归",slug:"非递归-2",normalizedTitle:"非递归",charIndex:57},{level:2,title:"后序遍历",slug:"后序遍历",normalizedTitle:"后序遍历",charIndex:2430},{level:3,title:"递归",slug:"递归-3",normalizedTitle:"递归",charIndex:58},{level:3,title:"非递归",slug:"非递归-3",normalizedTitle:"非递归",charIndex:57},{level:2,title:"层序遍历",slug:"层序遍历",normalizedTitle:"层序遍历",charIndex:3435}],excerpt:"<p>本文所有的遍历方式都接受两个参数，数的根节点(node)和保存遍历结果的列表(aws)。</p>\n<p>对于前序、中序、后序的非递归遍历方式的思路比较直接，所以不再做文字叙述。</p>\n<p>代码中使用到的BinTreeNode的定义如下：</p>\n",lastUpdated:"2020-12-22",headersStr:"前序遍历 递归 非递归 中序遍历 递归 非递归 后序遍历 递归 非递归 层序遍历",content:"本文所有的遍历方式都接受两个参数，数的根节点(node)和保存遍历结果的列表(aws)。\n\n对于前序、中序、后序的非递归遍历方式的思路比较直接，所以不再做文字叙述。\n\n代码中使用到的BinTreeNode的定义如下：\n\npackage tree;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.NoArgsConstructor;\nimport lombok.Setter;\n\n@NoArgsConstructor\n@AllArgsConstructor\n@Getter\n@Setter\npublic class BinTreeNode<T> {\n    private T data;\n    private BinTreeNode<T> left;\n    private BinTreeNode<T> right;\n\n    public BinTreeNode(T data) {\n        this.data = data;\n    }\n\n    @Override\n    public String toString() {\n        return data.toString();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n# 前序遍历\n# 递归\nprivate <T> void preTraversalRecursive(BinTreeNode<T> node, List<T> aws) {\n    if (node == null) {\n        return;\n    }\n    aws.add(node.getData());\n    preTraversalRecursive(node.getLeft(), aws);\n    preTraversalRecursive(node.getRight(), aws);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 非递归\nprivate <T> void preTraversalIterative(BinTreeNode<T> node, List<T> aws) {\n    Deque<BinTreeNode<T>> deque = new ArrayDeque<>();\n    BinTreeNode<T> tmp = node;\n    while (Objects.nonNull(tmp)) {\n        aws.add(tmp.getData());\n        if (Objects.nonNull(tmp.getRight())) {\n            deque.addLast(tmp.getRight());\n        }\n        if (Objects.nonNull(tmp.getLeft())) {\n            deque.addLast(tmp.getLeft());\n        }\n        tmp = deque.pollLast();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n使用栈来模拟递归的过程，但是要注意是先把右子节点加入栈中，再把左子节点加入栈中，才能实现左子节点先出栈。另外上述代码解决了node为null的情况。\n\n# 中序遍历\n# 递归\nprivate <T> void inTraversalRecursive(BinTreeNode<T> node, List<T> aws) {\n    if (node == null) {\n        return;\n    }\n    inTraversalRecursive(node.getLeft(), aws);\n    aws.add(node.getData());\n    inTraversalRecursive(node.getRight(), aws);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 非递归\nprivate <T> void inTraversalIterative(BinTreeNode<T> node, List<T> aws) {\n    Deque<BinTreeNode<T>> deque = new ArrayDeque<>();\n    BinTreeNode<T> tmp = node;\n    while (deque.size() > 0 || Objects.nonNull(tmp)) {\n        while(Objects.nonNull(tmp)) {\n            deque.addLast(tmp);\n            tmp = tmp.getLeft();\n        }\n        tmp = deque.pollLast();\n        aws.add(tmp.getData());\n        tmp = tmp.getRight();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n同样地，利用栈来模拟递归。对于任何一个非空节点，寻找到最左下角的非空节点，并将沿途所有的节点（包括起点和终点）加入栈中保存。然后在栈不空的情况下，弹出栈顶元素，并保存数据到结果中，然后让指针指向其右子节点。\n\n注意外层while循环的条件，加入Objects.nonNull(tmp)是为了确保根节点的右子树能够被遍历。因为在根节点弹出栈后，栈就空了，不管右子树存不存在，都会结束循环。\n\n# 后序遍历\n# 递归\nprivate <T> void postTraversalRecursive(BinTreeNode<T> node, List<T> aws) {\n    if (node == null) {\n        return;\n    }\n    postTraversalRecursive(node.getLeft(), aws);\n    postTraversalRecursive(node.getRight(), aws);\n    aws.add(node.getData());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 非递归\nprivate <T> void postTraversalIterative(BinTreeNode<T> node, List<T> aws) {\n    Deque<BinTreeNode<T>> deque = new ArrayDeque<>();\n    BinTreeNode<T> tmp = node;\n    while (Objects.nonNull(tmp)) {\n        aws.add(tmp.getData());\n        if (Objects.nonNull(tmp.getLeft())) {\n            deque.addLast(tmp.getLeft());\n        }\n        if (Objects.nonNull(tmp.getRight())) {\n            deque.addLast(tmp.getRight());\n        }\n        tmp = deque.pollLast();\n    }\n    Collections.reverse(aws);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n非递归的后序遍历稍微有些复杂，不过根据逆后序遍历和前序遍历的关系，然后结合前序遍历的思路，就很容易实现后序遍历了。\n\n\n\n上面这颗二叉树的前序遍历为： 12354，后序遍历为：35241。逆后序遍历为：14253。发现逆后序遍历就是在前序遍历的基础上交换了左右子树的遍历顺序得来的。上面非递归的前序遍历还特地强调了左右子树的顺序，此时只需交换两条语句的顺序即可。\n\n# 层序遍历\nprivate <T> void levelTraversal(BinTreeNode<T> node, List<T> aws) {\n    if (Objects.nonNull(node)) {\n        Deque<BinTreeNode<T>> deque1 = new ArrayDeque<>();\n        Deque<BinTreeNode<T>> deque2 = new ArrayDeque<>();\n        deque1.addLast(node);\n        BinTreeNode<T> tmp;\n        while (deque1.size() > 0 || deque2.size() > 0) {\n            if (deque1.size() == 0) {\n                deque1.addAll(deque2);\n                deque2.clear();\n            }\n            tmp = deque1.pollFirst();\n            assert tmp != null;\n            aws.add(tmp.getData());\n            if (Objects.nonNull(tmp.getLeft())) {\n                deque2.addLast(tmp.getLeft());\n            }\n            if (Objects.nonNull(tmp.getRight())) {\n                deque2.addLast(tmp.getRight());\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n使用两个队列deque1和deque2，deque1保存了当前遍历的这一层的节点，然后deque2保存下一层的所有节点，并按照先进先出的顺序。待当前这一层遍历结束时，将deque2保存的值转移到deque1中，然后清空deque2。当deque1和deque2都为空时，遍历结束。",normalizedContent:"本文所有的遍历方式都接受两个参数，数的根节点(node)和保存遍历结果的列表(aws)。\n\n对于前序、中序、后序的非递归遍历方式的思路比较直接，所以不再做文字叙述。\n\n代码中使用到的bintreenode的定义如下：\n\npackage tree;\n\nimport lombok.allargsconstructor;\nimport lombok.getter;\nimport lombok.noargsconstructor;\nimport lombok.setter;\n\n@noargsconstructor\n@allargsconstructor\n@getter\n@setter\npublic class bintreenode<t> {\n    private t data;\n    private bintreenode<t> left;\n    private bintreenode<t> right;\n\n    public bintreenode(t data) {\n        this.data = data;\n    }\n\n    @override\n    public string tostring() {\n        return data.tostring();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n# 前序遍历\n# 递归\nprivate <t> void pretraversalrecursive(bintreenode<t> node, list<t> aws) {\n    if (node == null) {\n        return;\n    }\n    aws.add(node.getdata());\n    pretraversalrecursive(node.getleft(), aws);\n    pretraversalrecursive(node.getright(), aws);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 非递归\nprivate <t> void pretraversaliterative(bintreenode<t> node, list<t> aws) {\n    deque<bintreenode<t>> deque = new arraydeque<>();\n    bintreenode<t> tmp = node;\n    while (objects.nonnull(tmp)) {\n        aws.add(tmp.getdata());\n        if (objects.nonnull(tmp.getright())) {\n            deque.addlast(tmp.getright());\n        }\n        if (objects.nonnull(tmp.getleft())) {\n            deque.addlast(tmp.getleft());\n        }\n        tmp = deque.polllast();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n使用栈来模拟递归的过程，但是要注意是先把右子节点加入栈中，再把左子节点加入栈中，才能实现左子节点先出栈。另外上述代码解决了node为null的情况。\n\n# 中序遍历\n# 递归\nprivate <t> void intraversalrecursive(bintreenode<t> node, list<t> aws) {\n    if (node == null) {\n        return;\n    }\n    intraversalrecursive(node.getleft(), aws);\n    aws.add(node.getdata());\n    intraversalrecursive(node.getright(), aws);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 非递归\nprivate <t> void intraversaliterative(bintreenode<t> node, list<t> aws) {\n    deque<bintreenode<t>> deque = new arraydeque<>();\n    bintreenode<t> tmp = node;\n    while (deque.size() > 0 || objects.nonnull(tmp)) {\n        while(objects.nonnull(tmp)) {\n            deque.addlast(tmp);\n            tmp = tmp.getleft();\n        }\n        tmp = deque.polllast();\n        aws.add(tmp.getdata());\n        tmp = tmp.getright();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n同样地，利用栈来模拟递归。对于任何一个非空节点，寻找到最左下角的非空节点，并将沿途所有的节点（包括起点和终点）加入栈中保存。然后在栈不空的情况下，弹出栈顶元素，并保存数据到结果中，然后让指针指向其右子节点。\n\n注意外层while循环的条件，加入objects.nonnull(tmp)是为了确保根节点的右子树能够被遍历。因为在根节点弹出栈后，栈就空了，不管右子树存不存在，都会结束循环。\n\n# 后序遍历\n# 递归\nprivate <t> void posttraversalrecursive(bintreenode<t> node, list<t> aws) {\n    if (node == null) {\n        return;\n    }\n    posttraversalrecursive(node.getleft(), aws);\n    posttraversalrecursive(node.getright(), aws);\n    aws.add(node.getdata());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 非递归\nprivate <t> void posttraversaliterative(bintreenode<t> node, list<t> aws) {\n    deque<bintreenode<t>> deque = new arraydeque<>();\n    bintreenode<t> tmp = node;\n    while (objects.nonnull(tmp)) {\n        aws.add(tmp.getdata());\n        if (objects.nonnull(tmp.getleft())) {\n            deque.addlast(tmp.getleft());\n        }\n        if (objects.nonnull(tmp.getright())) {\n            deque.addlast(tmp.getright());\n        }\n        tmp = deque.polllast();\n    }\n    collections.reverse(aws);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n非递归的后序遍历稍微有些复杂，不过根据逆后序遍历和前序遍历的关系，然后结合前序遍历的思路，就很容易实现后序遍历了。\n\n\n\n上面这颗二叉树的前序遍历为： 12354，后序遍历为：35241。逆后序遍历为：14253。发现逆后序遍历就是在前序遍历的基础上交换了左右子树的遍历顺序得来的。上面非递归的前序遍历还特地强调了左右子树的顺序，此时只需交换两条语句的顺序即可。\n\n# 层序遍历\nprivate <t> void leveltraversal(bintreenode<t> node, list<t> aws) {\n    if (objects.nonnull(node)) {\n        deque<bintreenode<t>> deque1 = new arraydeque<>();\n        deque<bintreenode<t>> deque2 = new arraydeque<>();\n        deque1.addlast(node);\n        bintreenode<t> tmp;\n        while (deque1.size() > 0 || deque2.size() > 0) {\n            if (deque1.size() == 0) {\n                deque1.addall(deque2);\n                deque2.clear();\n            }\n            tmp = deque1.pollfirst();\n            assert tmp != null;\n            aws.add(tmp.getdata());\n            if (objects.nonnull(tmp.getleft())) {\n                deque2.addlast(tmp.getleft());\n            }\n            if (objects.nonnull(tmp.getright())) {\n                deque2.addlast(tmp.getright());\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n使用两个队列deque1和deque2，deque1保存了当前遍历的这一层的节点，然后deque2保存下一层的所有节点，并按照先进先出的顺序。待当前这一层遍历结束时，将deque2保存的值转移到deque1中，然后清空deque2。当deque1和deque2都为空时，遍历结束。",charsets:{cjk:!0}},{title:"从遍历结果中构建二叉树",frontmatter:{title:"从遍历结果中构建二叉树",categories:["数据结构与算法"],tags:["二叉树"],date:"2020-10-24T00:00:00.000Z",permalink:"/pages/cc0ee9/"},regularPath:"/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/02.%E4%BB%8E%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%E4%B8%AD%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"02.数据结构与算法/02.从遍历结果中构建二叉树.md",key:"v-7dbeb206",path:"/pages/cc0ee9/",headers:[{level:2,title:"前序+中序",slug:"前序-中序",normalizedTitle:"前序+中序",charIndex:36},{level:2,title:"后序+中序",slug:"后序-中序",normalizedTitle:"后序+中序",charIndex:43},{level:2,title:"层序+中序",slug:"层序-中序",normalizedTitle:"层序+中序",charIndex:2432}],excerpt:"<p>在大部分教科书上都说明了前序+后序的遍历结果不能唯一地确定一棵二叉树，而前序+中序以及后序+中序则可以。本文则分析如何用代码来实现，关于为什么能够和不能够不做证明（主要是我太菜了 😂）。</p>\n",lastUpdated:"2020-12-22",headersStr:"前序+中序 后序+中序 层序+中序",content:"在大部分教科书上都说明了前序+后序的遍历结果不能唯一地确定一棵二叉树，而前序+中序以及后序+中序则可以。本文则分析如何用代码来实现，关于为什么能够和不能够不做证明（主要是我太菜了 😂）。\n\n# 前序+中序\n\n\n这棵二叉树的前序，中序分别为：\n\n * 前序：0, 1, 3, 7, 4, 2, 5, 6\n * 中序：7, 3, 1, 4, 0, 5, 2, 6\n\n前序遍历序列的第一个元素为根节点，然后在中序遍历中找到该元素，即可把中序遍历分成两部分，进而也把前序遍历分成两部分，然后递归进行处理。\n\n根据上述的简要分析，可知函数的参数主要为前序遍历序列，中序遍历序列，以及各自的起始和结束下标。进入函数后首先根据下标判断序列是否存在元素，如果不存在，则代表是递归终点，否则则根据上述分析进行处理。\n\n    /**\n     * 参数校验应该在外部完成\n     * @param pre 前序序列\n     * @param a 前序序列开始下标\n     * @param b 前序序列结束下标\n     * @param in 中序序列\n     * @param c 中序序列开始下标\n     * @param d 中序序列结束下标\n     * @return 生成树根节点\n     */\npublic BinTreeNode<T> generateFromPreAndInOrder(List<T> pre, int a, int b, List<T> in, int c, int d) {\n    if (a > b) {\n        return null; // 递归终点\n    } else {\n        int index = c;\n        while (index <= d && !Objects.equals(pre.get(a), in.get(index))) {\n            ++index;\n        }\n        BinTreeNode<T> node = new BinTreeNode<>();\n        node.setData(pre.get(a));\n        // 递归处理左子树\n        node.setLeft(generateFromPreAndInOrder(pre, a + 1, a + (index - c), in, c, index - 1));\n        // 递归处理右子树\n        node.setRight(generateFromPreAndInOrder(pre, a + (index - c) + 1, b, in, index + 1, d));\n        return node;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n上面的函数由于是递归调用的，所有就没有对序列的合法性进行判断，外部调用必须确保前序遍历序列和后序遍历序列要相互对应，否则该函数不能正常运行，下面两类问题的实现也一样。\n\n另外还有一点需要注意，在递归处理左子树时，前序遍历序列的结束下标应该为：a+1+[(index−c)−1]a + 1 + [(index - c) - 1]a+1+[(index−c)−1], 上述代码中为简化后的写法，前面这个式子更好理解一些（下面右子树的参数也可给予上述式子理解）。\n\n# 后序+中序\n对于后序+中序的情况也类似，只不过根节点不是第一个元素，而是最后一个元素。\n\n/**\n     * 参数校验应该在外部完成\n     * @param post 后序序列\n     * @param a 后序序列开始下标\n     * @param b 后序序列结束下标\n     * @param in 中序序列\n     * @param c 中序序列开始下标\n     * @param d 中序序列结束下标\n     * @return 生成树根节点\n     */\npublic BinTreeNode<T> generateFromPostAndInOrder(List<T> post, int a, int b, List<T> in, int c, int d) {\n    if (a > b) {\n        return null;\n    } else {\n        int index = d;\n        while (index >= c && !Objects.equals(post.get(b), in.get(index))) {\n            --index;\n        }\n        BinTreeNode<T> node = new BinTreeNode<>();\n        node.setData(post.get(b));\n        node.setLeft(generateFromPostAndInOrder(post, a, a + (index - c) - 1, in, c, index - 1));\n        node.setRight(generateFromPostAndInOrder(post, a + (index - c), b - 1, in, index + 1, d));\n        return node;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n同样地，需要注意递归时函数参数中的下标的表示。\n\n# 层序+中序\n仍然对于上图中的二叉树，其层序遍历和中序遍历分别是：\n\n * 0, 1, 2, 3, 4, 5, 6, 7\n * 7, 3, 1, 4, 0, 5, 2, 6\n\n层序遍历序列的第一个元素，是当前二叉树的根节点，同样地，在中序遍历中找到该节点的下标，从而可以确定左右子树的中序遍历。如果能够继续求得左右子树的层序遍历就更好了，因为这样就可以利用递归来处理问题。由于左右子树的层序遍历在原始层序遍历中是分散开的，所以不能直接指定下标。但是可以从当前层序遍历中筛选，即正向遍历当前层序遍历，然后判断其是否在当前中序遍历范围内以及是属于左子树还是右子树。最后，类似前面两种情况，递归求解。\n\n/**\n     * 参数校验应该在外部完成\n     * @param layer 层序序列\n     * @param in 中序序列\n     * @param a 中序序列开始下标\n     * @param b 中序序列结束下标\n     * @return 生成树根节点\n     */\npublic BinTreeNode<T> generateFromLayerAndInOrder(List<T> layer, List<T> in, int a, int b) {\n    if (a > b) {\n        return null;\n    }\n    int index = a;\n    while (index <= b && !Objects.equals(layer.get(0), in.get(index))) {\n        ++index;\n    }\n    List<T> leftLayer = new ArrayList<>(index - a);\n    List<T> rightLayer = new ArrayList<>(b - index);\n    boolean isLeft;\n    for (int i = 1; i < layer.size(); ++i) {\n        isLeft = false;\n        for(int j = a; j < index; ++j) {\n            if (Objects.equals(layer.get(i), in.get(j))) {\n                isLeft = true;\n                break;\n            }\n        }\n        if (isLeft) {\n            leftLayer.add(layer.get(i));\n        } else {\n            rightLayer.add(layer.get(i));\n        }\n    }\n    BinTreeNode<T> node = new BinTreeNode<>();\n    node.setData(in.get(index));\n    node.setLeft(generateFromLayerAndInOrder(leftLayer, in, a, index - 1));\n    node.setRight(generateFromLayerAndInOrder(rightLayer, in, index + 1, b));\n    return node;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n注意，递归结束条件的其实也可以使用layer列表的长度来判断，当其长度等于0时，则表示递归结束。\n\n安利一个二叉树画图网站",normalizedContent:"在大部分教科书上都说明了前序+后序的遍历结果不能唯一地确定一棵二叉树，而前序+中序以及后序+中序则可以。本文则分析如何用代码来实现，关于为什么能够和不能够不做证明（主要是我太菜了 😂）。\n\n# 前序+中序\n\n\n这棵二叉树的前序，中序分别为：\n\n * 前序：0, 1, 3, 7, 4, 2, 5, 6\n * 中序：7, 3, 1, 4, 0, 5, 2, 6\n\n前序遍历序列的第一个元素为根节点，然后在中序遍历中找到该元素，即可把中序遍历分成两部分，进而也把前序遍历分成两部分，然后递归进行处理。\n\n根据上述的简要分析，可知函数的参数主要为前序遍历序列，中序遍历序列，以及各自的起始和结束下标。进入函数后首先根据下标判断序列是否存在元素，如果不存在，则代表是递归终点，否则则根据上述分析进行处理。\n\n    /**\n     * 参数校验应该在外部完成\n     * @param pre 前序序列\n     * @param a 前序序列开始下标\n     * @param b 前序序列结束下标\n     * @param in 中序序列\n     * @param c 中序序列开始下标\n     * @param d 中序序列结束下标\n     * @return 生成树根节点\n     */\npublic bintreenode<t> generatefrompreandinorder(list<t> pre, int a, int b, list<t> in, int c, int d) {\n    if (a > b) {\n        return null; // 递归终点\n    } else {\n        int index = c;\n        while (index <= d && !objects.equals(pre.get(a), in.get(index))) {\n            ++index;\n        }\n        bintreenode<t> node = new bintreenode<>();\n        node.setdata(pre.get(a));\n        // 递归处理左子树\n        node.setleft(generatefrompreandinorder(pre, a + 1, a + (index - c), in, c, index - 1));\n        // 递归处理右子树\n        node.setright(generatefrompreandinorder(pre, a + (index - c) + 1, b, in, index + 1, d));\n        return node;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n上面的函数由于是递归调用的，所有就没有对序列的合法性进行判断，外部调用必须确保前序遍历序列和后序遍历序列要相互对应，否则该函数不能正常运行，下面两类问题的实现也一样。\n\n另外还有一点需要注意，在递归处理左子树时，前序遍历序列的结束下标应该为：a+1+[(index−c)−1]a + 1 + [(index - c) - 1]a+1+[(index−c)−1], 上述代码中为简化后的写法，前面这个式子更好理解一些（下面右子树的参数也可给予上述式子理解）。\n\n# 后序+中序\n对于后序+中序的情况也类似，只不过根节点不是第一个元素，而是最后一个元素。\n\n/**\n     * 参数校验应该在外部完成\n     * @param post 后序序列\n     * @param a 后序序列开始下标\n     * @param b 后序序列结束下标\n     * @param in 中序序列\n     * @param c 中序序列开始下标\n     * @param d 中序序列结束下标\n     * @return 生成树根节点\n     */\npublic bintreenode<t> generatefrompostandinorder(list<t> post, int a, int b, list<t> in, int c, int d) {\n    if (a > b) {\n        return null;\n    } else {\n        int index = d;\n        while (index >= c && !objects.equals(post.get(b), in.get(index))) {\n            --index;\n        }\n        bintreenode<t> node = new bintreenode<>();\n        node.setdata(post.get(b));\n        node.setleft(generatefrompostandinorder(post, a, a + (index - c) - 1, in, c, index - 1));\n        node.setright(generatefrompostandinorder(post, a + (index - c), b - 1, in, index + 1, d));\n        return node;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n同样地，需要注意递归时函数参数中的下标的表示。\n\n# 层序+中序\n仍然对于上图中的二叉树，其层序遍历和中序遍历分别是：\n\n * 0, 1, 2, 3, 4, 5, 6, 7\n * 7, 3, 1, 4, 0, 5, 2, 6\n\n层序遍历序列的第一个元素，是当前二叉树的根节点，同样地，在中序遍历中找到该节点的下标，从而可以确定左右子树的中序遍历。如果能够继续求得左右子树的层序遍历就更好了，因为这样就可以利用递归来处理问题。由于左右子树的层序遍历在原始层序遍历中是分散开的，所以不能直接指定下标。但是可以从当前层序遍历中筛选，即正向遍历当前层序遍历，然后判断其是否在当前中序遍历范围内以及是属于左子树还是右子树。最后，类似前面两种情况，递归求解。\n\n/**\n     * 参数校验应该在外部完成\n     * @param layer 层序序列\n     * @param in 中序序列\n     * @param a 中序序列开始下标\n     * @param b 中序序列结束下标\n     * @return 生成树根节点\n     */\npublic bintreenode<t> generatefromlayerandinorder(list<t> layer, list<t> in, int a, int b) {\n    if (a > b) {\n        return null;\n    }\n    int index = a;\n    while (index <= b && !objects.equals(layer.get(0), in.get(index))) {\n        ++index;\n    }\n    list<t> leftlayer = new arraylist<>(index - a);\n    list<t> rightlayer = new arraylist<>(b - index);\n    boolean isleft;\n    for (int i = 1; i < layer.size(); ++i) {\n        isleft = false;\n        for(int j = a; j < index; ++j) {\n            if (objects.equals(layer.get(i), in.get(j))) {\n                isleft = true;\n                break;\n            }\n        }\n        if (isleft) {\n            leftlayer.add(layer.get(i));\n        } else {\n            rightlayer.add(layer.get(i));\n        }\n    }\n    bintreenode<t> node = new bintreenode<>();\n    node.setdata(in.get(index));\n    node.setleft(generatefromlayerandinorder(leftlayer, in, a, index - 1));\n    node.setright(generatefromlayerandinorder(rightlayer, in, index + 1, b));\n    return node;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n注意，递归结束条件的其实也可以使用layer列表的长度来判断，当其长度等于0时，则表示递归结束。\n\n安利一个二叉树画图网站",charsets:{cjk:!0}},{title:"二叉查找树",frontmatter:{title:"二叉查找树",categories:["数据结构与算法"],tags:["二叉树","二叉查找树"],date:"2020-10-31T00:00:00.000Z",permalink:"/pages/3bb416/"},regularPath:"/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/03.%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.html",relativePath:"02.数据结构与算法/03.二叉查找树.md",key:"v-07bf9581",path:"/pages/3bb416/",headers:[{level:2,title:"插入节点",slug:"插入节点",normalizedTitle:"插入节点",charIndex:179},{level:2,title:"构建BST",slug:"构建bst",normalizedTitle:"构建bst",charIndex:170},{level:2,title:"查找节点",slug:"查找节点",normalizedTitle:"查找节点",charIndex:187},{level:2,title:"删除节点",slug:"删除节点",normalizedTitle:"删除节点",charIndex:195},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:5572}],excerpt:"<p>二叉查找树，或二叉搜索树（Binary Search Tree, 简称BST），是一种特殊的二叉树结构，对其任意节点，其左子树中的任一节点的值都小于或等于当前节点的值，其右子树中的任一节点的值都大于或等于当前节点值（对于等于的情况，一般选择保存到任一边）。二叉查找树的中序遍历，是满足升序排列的。</p>\n",lastUpdated:"2020-12-22",headersStr:"插入节点 构建BST 查找节点 删除节点 总结",content:"二叉查找树，或二叉搜索树（Binary Search Tree, 简称BST），是一种特殊的二叉树结构，对其任意节点，其左子树中的任一节点的值都小于或等于当前节点的值，其右子树中的任一节点的值都大于或等于当前节点值（对于等于的情况，一般选择保存到任一边）。二叉查找树的中序遍历，是满足升序排列的。\n\n下面探讨二叉搜索树的一些操作：\n\n * 构建BST\n * 插入节点\n * 查找节点\n * 删除节点\n\n代码中使用到的BinTreeNode的定义请参考这篇博客。\n\n# 插入节点\n在探讨构建之前，先分析一下如何插入节点。插入节点，首先要找到所要插入的位置，通过上面的简述，发现无论如何，插入的节点最终都会成为一个叶子节点。那么可以通过遍历，分别比较当前节点值与待插入节点值，直到叶子节点位置。\n\n具体的代码实现，其实可以用迭代来代替消除递归，设置一个节点指针node指向遍历过程中的节点，初始值为根节点。如果node节点的值大于待插入值，则将node指向node的左子节点，同理，如果大于或等于（这里把等于的情况放在右子树中，放在左子树中也可以），则将node指向node的右子节点。但是注意，在指针指向转移的时候，如果已经遍历到根节点了，则直接创建一个节点挂在当前的节点上。\n\n/**\n * @param root 树的根节点\n * @param value 待插入值\n */\npublic void insert(BinTreeNode<T> root, T value) {\n    assert Objects.nonNull(root);\n    BinTreeNode<T> node = root;\n    BinTreeNode<T> newNode = new BinTreeNode<>(value);\n    while (true) {\n        if (value.compareTo(node.getData()) < 0) {\n            if (Objects.isNull(node.getLeft())) {\n                node.setLeft(newNode);\n                break;\n            } else {\n                node = node.getLeft();\n            }\n        } else {\n            if (Objects.isNull(node.getRight())) {\n                node.setRight(newNode);\n                break;\n            } else {\n                node = node.getRight();\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n上述实现假设root非空，而且不具有返回值，不过可以根据需求对上述代码进行一定的修改。\n\n# 构建BST\n既然实现了插入节点，那么构建一棵BST就不是什么难事了，而且思路很直观，遍历值列表并调用插入节点方法即可。下面的实现其实比较粗糙，可能会导致BST链式化，最好取中位数的元素作为根节点。\n\n/**\n * @param list 构建BST的值列表\n * @return 返回BST的根节点\n */\npublic BinTreeNode<T> build(List<T> list) {\n    if (Objects.nonNull(list) && list.size() > 0) {\n        BinTreeNode<T> root = new BinTreeNode<>(list.get(0));\n        for (int i = 1; i < list.size(); i++) {\n            insert(root, list.get(i));\n        }\n        return root;\n    } else {\n        return null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 查找节点\n根据插入节点的思路，查找节点的思路也很简单，除了插入这一步操作之外，其他都一样。\n\n/**\n * @param root BST的根节点\n * @param target 所需要查找的值\n * @return 返回查找结果，如果查找成功，返回结果，否则返回null\n */\npublic T search(BinTreeNode<T>root, T target) {\n    BinTreeNode<T>node = root;\n    while (Objects.nonNull(node)) {\n        int compare = node.getData().compareTo(target);\n        if (compare == 0) {\n            return node.getData();\n        } else if (compare < 0) {\n            node = node.getRight();\n        } else {\n            node = node.getLeft();\n        }\n    }\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 删除节点\n删除节点比较复杂一些，不过首先仍然需要找到待删除的节点，总体来说，可以分为三种情况：\n\n 1. 待删除节点为叶子节点（左右子树都为空）\n 2. 待删除节点左子树为空或右子树为空（即左右子树不同时为空）\n 3. 待删除节点左右子树都不为空\n\n对于代码实现，需要一个指针（node）指向待删除节点，还需一个指针（parent）指向待删除节点的父节点，以及一个布尔值变量（isLeftChild）表示待删除节点是其父节点的左子节点还是右子节点。node初始化为根节点，parent初始化为null。\n\n 1. 对于第一种情况，如果是根节点，直接返回null；否则，根据isLeftChild从parent上摘掉待删除节点。\n 2. 对于第二种情况，如果是根节点，返回非空的那个子节点；否则，根据isLeftChild将node的非空子节点挂在parent相应的位置上。\n 3. 对于第三种情况，这里不用区分是根节点与否。有两种方式，第一，将被删除节点的左子树的最右边节点替换当前节点并删除，或者是将被删除节点的右子树的最左边节点替换当前节点并删除。这里采用第一种方式，但在查找左子树最右边节点的过程中需要注意判断替换节点是否就是待删除节点的左子节点。\n\n/**\n * @param root BST的根节点\n * @param target 待删除节点\n * @return 返回删除后的BST的根节点\n */\npublic BinTreeNode<T> delete(BinTreeNode<T> root, T target) {\n    BinTreeNode<T> node = root;\n    BinTreeNode<T> parent = null;\n    boolean isLeftChild = false;\n    while (Objects.nonNull(node)) {\n        int compare = node.getData().compareTo(target);\n        // 找到目标节点并准备删除\n        if (compare == 0) {\n            // 当前节点为叶子节点\n            if (Objects.isNull(node.getLeft()) && Objects.isNull(node.getRight())) {\n                // 已排除当前节点为根结点的情况\n                if (Objects.isNull(parent)) { // 当前二叉树只有一个节点，即需要删除根节点\n                    return null;\n                } else if (isLeftChild){\n                    parent.setLeft(null);\n                } else {\n                    parent.setRight(null);\n                }\n            } else if (Objects.isNull(node.getLeft()) || Objects.isNull(node.getRight())) { // 左子节点为空或右子节点为空\n                if (Objects.isNull(parent)) {\n                    return Objects.isNull(node.getLeft()) ? node.getRight() : node.getLeft();\n                }else if (isLeftChild) {\n                    parent.setLeft(Objects.nonNull(node.getRight()) ? node.getRight() : node.getLeft());\n                } else {\n                    parent.setRight(Objects.nonNull(node.getLeft()) ? node.getLeft() : node.getRight());\n                }\n            } else { // 当前节点左右子节点都非空\n                /*\n                    有两种方法，即让当前节点的左子树的最右边节点取代当前节点\n                    或者让当前节点的右子树的最左边节点取代当前节点\n                     */\n                parent = null; // parent记录的外部值以及无效，所以在这里可以复用\n                BinTreeNode<T> tmp = node.getLeft();\n                while (Objects.nonNull(tmp.getRight())) {\n                    parent = tmp;\n                    tmp = tmp.getRight();\n                }\n                // 这里需要判断所要删除节点的左子节点的右子节点是否存在，不同的情况处理方式不同\n                if (Objects.isNull(parent)) { // 被删除节点的左子节点没有右子节点\n                    node.setLeft(tmp.getLeft());\n                } else {\n                    parent.setRight(tmp.getLeft());\n                }\n                node.setData(tmp.getData());\n            }\n            break;\n        } else if (compare < 0) {\n            parent = node;\n            node = node.getRight();\n            isLeftChild = false;\n        } else {\n            parent = node;\n            node = node.getLeft();\n            isLeftChild = true;\n        }\n    }\n    return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n# 总结\n虽然BST在一定程度上提高了查找的效率，但是在一些特殊的情况下，比如当BST成为链式结构时，查找时间复杂度线性化。\n\n本文并没有分析如何查找多个相同的值，不过可以在上面的代码中做一些改进。例如，加入将相同的元素放在右子树中，那么当查找到一个相同的元素后，并不直接返回，而是保存到结果集中，然后继续沿着右子树的查找，直到叶子节点。",normalizedContent:"二叉查找树，或二叉搜索树（binary search tree, 简称bst），是一种特殊的二叉树结构，对其任意节点，其左子树中的任一节点的值都小于或等于当前节点的值，其右子树中的任一节点的值都大于或等于当前节点值（对于等于的情况，一般选择保存到任一边）。二叉查找树的中序遍历，是满足升序排列的。\n\n下面探讨二叉搜索树的一些操作：\n\n * 构建bst\n * 插入节点\n * 查找节点\n * 删除节点\n\n代码中使用到的bintreenode的定义请参考这篇博客。\n\n# 插入节点\n在探讨构建之前，先分析一下如何插入节点。插入节点，首先要找到所要插入的位置，通过上面的简述，发现无论如何，插入的节点最终都会成为一个叶子节点。那么可以通过遍历，分别比较当前节点值与待插入节点值，直到叶子节点位置。\n\n具体的代码实现，其实可以用迭代来代替消除递归，设置一个节点指针node指向遍历过程中的节点，初始值为根节点。如果node节点的值大于待插入值，则将node指向node的左子节点，同理，如果大于或等于（这里把等于的情况放在右子树中，放在左子树中也可以），则将node指向node的右子节点。但是注意，在指针指向转移的时候，如果已经遍历到根节点了，则直接创建一个节点挂在当前的节点上。\n\n/**\n * @param root 树的根节点\n * @param value 待插入值\n */\npublic void insert(bintreenode<t> root, t value) {\n    assert objects.nonnull(root);\n    bintreenode<t> node = root;\n    bintreenode<t> newnode = new bintreenode<>(value);\n    while (true) {\n        if (value.compareto(node.getdata()) < 0) {\n            if (objects.isnull(node.getleft())) {\n                node.setleft(newnode);\n                break;\n            } else {\n                node = node.getleft();\n            }\n        } else {\n            if (objects.isnull(node.getright())) {\n                node.setright(newnode);\n                break;\n            } else {\n                node = node.getright();\n            }\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n上述实现假设root非空，而且不具有返回值，不过可以根据需求对上述代码进行一定的修改。\n\n# 构建bst\n既然实现了插入节点，那么构建一棵bst就不是什么难事了，而且思路很直观，遍历值列表并调用插入节点方法即可。下面的实现其实比较粗糙，可能会导致bst链式化，最好取中位数的元素作为根节点。\n\n/**\n * @param list 构建bst的值列表\n * @return 返回bst的根节点\n */\npublic bintreenode<t> build(list<t> list) {\n    if (objects.nonnull(list) && list.size() > 0) {\n        bintreenode<t> root = new bintreenode<>(list.get(0));\n        for (int i = 1; i < list.size(); i++) {\n            insert(root, list.get(i));\n        }\n        return root;\n    } else {\n        return null;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n# 查找节点\n根据插入节点的思路，查找节点的思路也很简单，除了插入这一步操作之外，其他都一样。\n\n/**\n * @param root bst的根节点\n * @param target 所需要查找的值\n * @return 返回查找结果，如果查找成功，返回结果，否则返回null\n */\npublic t search(bintreenode<t>root, t target) {\n    bintreenode<t>node = root;\n    while (objects.nonnull(node)) {\n        int compare = node.getdata().compareto(target);\n        if (compare == 0) {\n            return node.getdata();\n        } else if (compare < 0) {\n            node = node.getright();\n        } else {\n            node = node.getleft();\n        }\n    }\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 删除节点\n删除节点比较复杂一些，不过首先仍然需要找到待删除的节点，总体来说，可以分为三种情况：\n\n 1. 待删除节点为叶子节点（左右子树都为空）\n 2. 待删除节点左子树为空或右子树为空（即左右子树不同时为空）\n 3. 待删除节点左右子树都不为空\n\n对于代码实现，需要一个指针（node）指向待删除节点，还需一个指针（parent）指向待删除节点的父节点，以及一个布尔值变量（isleftchild）表示待删除节点是其父节点的左子节点还是右子节点。node初始化为根节点，parent初始化为null。\n\n 1. 对于第一种情况，如果是根节点，直接返回null；否则，根据isleftchild从parent上摘掉待删除节点。\n 2. 对于第二种情况，如果是根节点，返回非空的那个子节点；否则，根据isleftchild将node的非空子节点挂在parent相应的位置上。\n 3. 对于第三种情况，这里不用区分是根节点与否。有两种方式，第一，将被删除节点的左子树的最右边节点替换当前节点并删除，或者是将被删除节点的右子树的最左边节点替换当前节点并删除。这里采用第一种方式，但在查找左子树最右边节点的过程中需要注意判断替换节点是否就是待删除节点的左子节点。\n\n/**\n * @param root bst的根节点\n * @param target 待删除节点\n * @return 返回删除后的bst的根节点\n */\npublic bintreenode<t> delete(bintreenode<t> root, t target) {\n    bintreenode<t> node = root;\n    bintreenode<t> parent = null;\n    boolean isleftchild = false;\n    while (objects.nonnull(node)) {\n        int compare = node.getdata().compareto(target);\n        // 找到目标节点并准备删除\n        if (compare == 0) {\n            // 当前节点为叶子节点\n            if (objects.isnull(node.getleft()) && objects.isnull(node.getright())) {\n                // 已排除当前节点为根结点的情况\n                if (objects.isnull(parent)) { // 当前二叉树只有一个节点，即需要删除根节点\n                    return null;\n                } else if (isleftchild){\n                    parent.setleft(null);\n                } else {\n                    parent.setright(null);\n                }\n            } else if (objects.isnull(node.getleft()) || objects.isnull(node.getright())) { // 左子节点为空或右子节点为空\n                if (objects.isnull(parent)) {\n                    return objects.isnull(node.getleft()) ? node.getright() : node.getleft();\n                }else if (isleftchild) {\n                    parent.setleft(objects.nonnull(node.getright()) ? node.getright() : node.getleft());\n                } else {\n                    parent.setright(objects.nonnull(node.getleft()) ? node.getleft() : node.getright());\n                }\n            } else { // 当前节点左右子节点都非空\n                /*\n                    有两种方法，即让当前节点的左子树的最右边节点取代当前节点\n                    或者让当前节点的右子树的最左边节点取代当前节点\n                     */\n                parent = null; // parent记录的外部值以及无效，所以在这里可以复用\n                bintreenode<t> tmp = node.getleft();\n                while (objects.nonnull(tmp.getright())) {\n                    parent = tmp;\n                    tmp = tmp.getright();\n                }\n                // 这里需要判断所要删除节点的左子节点的右子节点是否存在，不同的情况处理方式不同\n                if (objects.isnull(parent)) { // 被删除节点的左子节点没有右子节点\n                    node.setleft(tmp.getleft());\n                } else {\n                    parent.setright(tmp.getleft());\n                }\n                node.setdata(tmp.getdata());\n            }\n            break;\n        } else if (compare < 0) {\n            parent = node;\n            node = node.getright();\n            isleftchild = false;\n        } else {\n            parent = node;\n            node = node.getleft();\n            isleftchild = true;\n        }\n    }\n    return root;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n# 总结\n虽然bst在一定程度上提高了查找的效率，但是在一些特殊的情况下，比如当bst成为链式结构时，查找时间复杂度线性化。\n\n本文并没有分析如何查找多个相同的值，不过可以在上面的代码中做一些改进。例如，加入将相同的元素放在右子树中，那么当查找到一个相同的元素后，并不直接返回，而是保存到结果集中，然后继续沿着右子树的查找，直到叶子节点。",charsets:{cjk:!0}},{title:"判断一棵二叉树是否是平衡二叉树",frontmatter:{title:"判断一棵二叉树是否是平衡二叉树",categories:["数据结构与算法"],tags:["二叉树","平衡二叉树"],date:"2020-10-16T00:00:00.000Z",permalink:"/pages/eca41b/"},regularPath:"/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/04.%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"02.数据结构与算法/04.判断一棵二叉树是否是平衡二叉树.md",key:"v-3d3237bb",path:"/pages/eca41b/",headers:[{level:2,title:"简述",slug:"简述",normalizedTitle:"简述",charIndex:2},{level:2,title:"自顶向下",slug:"自顶向下",normalizedTitle:"自顶向下",charIndex:101},{level:2,title:"自底向上",slug:"自底向上",normalizedTitle:"自底向上",charIndex:106}],excerpt:'<h2 id="简述"><a class="header-anchor" href="#简述">#</a> 简述</h2>\n<p>本题为<a href="https://leetcode-cn.com/problems/balanced-binary-tree/" target="_blank" rel="noopener noreferrer">LeetCode第110题<OutboundLink/></a>。</p>\n<p>根据平衡二叉树的定义，很自然地想到递归每一个子树，判断每一个子树是否是平衡二叉树。对于每一棵树，根据其左右子树的高度差来判断是否满足条件。这里有两种方法，自顶向下和自底向上。</p>\n',lastUpdated:"2020-12-22",headersStr:"简述 自顶向下 自底向上",content:"# 简述\n本题为LeetCode第110题。\n\n根据平衡二叉树的定义，很自然地想到递归每一个子树，判断每一个子树是否是平衡二叉树。对于每一棵树，根据其左右子树的高度差来判断是否满足条件。这里有两种方法，自顶向下和自底向上。\n\n# 自顶向下\n代码如下：\n\nfunc isBalanced(root *TreeNode) bool {\n    if root != nil {\n        return abs(height(root.Left) - height(root.Right)) <= 1 && isBalanced(root.Left) && isBalanced(root.Right)\n    } else {\n        return true\n    }\n}\n\nfunc height(node *TreeNode) int {\n    if node == nil {\n        return 0\n    }\n    return max(height(node.Left), height(node.Right)) + 1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n其中省略了max和abs的定义。\n\n很容易发现，该方法存在的问题。在递归的过程中，计算子树的高度存在重合的情况。\n\n时间复杂度为O(n2n^2n2)，LeetCode上分析的最坏情况为O(n2n^2n2)，即当二叉树为链式结构时。但是个人认为在那种情况下，反而时间复杂度为O(n)了，因为isBalanced函数仅执行一次。\n\n空间复杂度为O(n)，取决于递归的层数。\n\n# 自底向上\n代码如下：\n\nfunc isBalanced(root *TreeNode) bool {\n    return height(root) >= 0\n}\n\nfunc height(node *TreeNode) int {\n    if node == nil {\n        return 0\n    }\n    lh := height(node.Left)\n    rh := height(node.Right)\n    if lh == -1 || rh == -1 || abs(lh - rh) > 1 {\n        return -1\n    } else {\n        return max(lh, rh) + 1\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n其中省略了max和abs的定义。\n\n时间复杂度为O(n)，原因为对于每个节点都需要处理一次。\n\n空间复杂度为O(n)，原因与自顶向下一样。",normalizedContent:"# 简述\n本题为leetcode第110题。\n\n根据平衡二叉树的定义，很自然地想到递归每一个子树，判断每一个子树是否是平衡二叉树。对于每一棵树，根据其左右子树的高度差来判断是否满足条件。这里有两种方法，自顶向下和自底向上。\n\n# 自顶向下\n代码如下：\n\nfunc isbalanced(root *treenode) bool {\n    if root != nil {\n        return abs(height(root.left) - height(root.right)) <= 1 && isbalanced(root.left) && isbalanced(root.right)\n    } else {\n        return true\n    }\n}\n\nfunc height(node *treenode) int {\n    if node == nil {\n        return 0\n    }\n    return max(height(node.left), height(node.right)) + 1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n其中省略了max和abs的定义。\n\n很容易发现，该方法存在的问题。在递归的过程中，计算子树的高度存在重合的情况。\n\n时间复杂度为o(n2n^2n2)，leetcode上分析的最坏情况为o(n2n^2n2)，即当二叉树为链式结构时。但是个人认为在那种情况下，反而时间复杂度为o(n)了，因为isbalanced函数仅执行一次。\n\n空间复杂度为o(n)，取决于递归的层数。\n\n# 自底向上\n代码如下：\n\nfunc isbalanced(root *treenode) bool {\n    return height(root) >= 0\n}\n\nfunc height(node *treenode) int {\n    if node == nil {\n        return 0\n    }\n    lh := height(node.left)\n    rh := height(node.right)\n    if lh == -1 || rh == -1 || abs(lh - rh) > 1 {\n        return -1\n    } else {\n        return max(lh, rh) + 1\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n其中省略了max和abs的定义。\n\n时间复杂度为o(n)，原因为对于每个节点都需要处理一次。\n\n空间复杂度为o(n)，原因与自顶向下一样。",charsets:{cjk:!0}},{title:"将有序数组转化为平衡二叉查找树",frontmatter:{title:"将有序数组转化为平衡二叉查找树",categories:["数据结构与算法"],tags:["二叉树","二叉查找树"],date:"2020-11-01T00:00:00.000Z",publish:!0,lang:"zh-CN",permalink:"/pages/3d68de/"},regularPath:"/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/05.%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E5%8C%96%E4%B8%BA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.html",relativePath:"02.数据结构与算法/05.将有序数组转化为平衡二叉查找树.md",key:"v-3ccab19a",path:"/pages/3d68de/",excerpt:'<p>题对应了<a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/" target="_blank" rel="noopener noreferrer">LeetCode第108题<OutboundLink/></a>。</p>\n<p>该题对应了LeetCode第108题。</p>\n<p>该题容易想偏，很有可能会利用AVL树的创建进行处理，涉及相应的旋转操作，会特别麻烦。由于给定的数组已经有序，可以把该数组看作是某棵二叉搜索树的中序遍历，然后利用此中序遍历构造相应的二叉搜索树。由于只能够确定中序遍历，所以其结果不唯一。</p>\n',lastUpdated:"2020-12-22",headersStr:null,content:"题对应了LeetCode第108题。\n\n该题对应了LeetCode第108题。\n\n该题容易想偏，很有可能会利用AVL树的创建进行处理，涉及相应的旋转操作，会特别麻烦。由于给定的数组已经有序，可以把该数组看作是某棵二叉搜索树的中序遍历，然后利用此中序遍历构造相应的二叉搜索树。由于只能够确定中序遍历，所以其结果不唯一。\n\n代码实现方面，给定的参数为有序数组，由于要求为平衡的二叉树，所以需要取数组的中间那个元素为根节点（取中间的目的是尽量让左右子树节点个数相等，就算不相等，差距也不会超过1，符合平衡的条件），其左子树的节点都位于左半部分，右子树的节点都位于右半部分，基于此特点，可以利用递归处理。\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        return dfs(nums, 0, nums.length - 1);\n    }\n\n    public TreeNode dfs(int[] nums, int a, int b) {\n        if(a <= b) {\n            int index = (a + b) / 2;\n            TreeNode node = new TreeNode(nums[index]);\n            node.left = dfs(nums, a, index - 1);\n            node.right = dfs(nums, index + 1, b);\n            return node;\n        } else {\n            return null;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26",normalizedContent:"题对应了leetcode第108题。\n\n该题对应了leetcode第108题。\n\n该题容易想偏，很有可能会利用avl树的创建进行处理，涉及相应的旋转操作，会特别麻烦。由于给定的数组已经有序，可以把该数组看作是某棵二叉搜索树的中序遍历，然后利用此中序遍历构造相应的二叉搜索树。由于只能够确定中序遍历，所以其结果不唯一。\n\n代码实现方面，给定的参数为有序数组，由于要求为平衡的二叉树，所以需要取数组的中间那个元素为根节点（取中间的目的是尽量让左右子树节点个数相等，就算不相等，差距也不会超过1，符合平衡的条件），其左子树的节点都位于左半部分，右子树的节点都位于右半部分，基于此特点，可以利用递归处理。\n\n/**\n * definition for a binary tree node.\n * public class treenode {\n *     int val;\n *     treenode left;\n *     treenode right;\n *     treenode(int x) { val = x; }\n * }\n */\nclass solution {\n    public treenode sortedarraytobst(int[] nums) {\n        return dfs(nums, 0, nums.length - 1);\n    }\n\n    public treenode dfs(int[] nums, int a, int b) {\n        if(a <= b) {\n            int index = (a + b) / 2;\n            treenode node = new treenode(nums[index]);\n            node.left = dfs(nums, a, index - 1);\n            node.right = dfs(nums, index + 1, b);\n            return node;\n        } else {\n            return null;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26",charsets:{cjk:!0}},{title:"将二叉查找树调整平衡",frontmatter:{title:"将二叉查找树调整平衡",categories:["数据结构与算法"],tags:["二叉树","二叉查找树"],date:"2020-11-01T00:00:00.000Z",permalink:"/pages/cf9f2b/"},regularPath:"/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/06.%E5%B0%86%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%E8%B0%83%E6%95%B4%E5%B9%B3%E8%A1%A1.html",relativePath:"02.数据结构与算法/06.将二叉查找树调整平衡.md",key:"v-1b2b24b9",path:"/pages/cf9f2b/",excerpt:'<p>此题对应了<a href="https://leetcode-cn.com/problems/balance-a-binary-search-tree/" target="_blank" rel="noopener noreferrer">LeetCode第1382题<OutboundLink/></a>。</p>\n<p>另外，此题与第108题十分类似，请参考<a href="https://harrisonlee.net/posts/f3041627/" target="_blank" rel="noopener noreferrer">这篇博客<OutboundLink/></a>。只不过108题是将有序数组转化为平衡二叉搜索树。如果没做过第108题，可能很容易把本题想复杂，比如我最开始想要么新建一棵树（刚好那天复习了一下AVL树的实现方式），要么就地调整。想了一下，重建的做法应该不太高效，就原地调整，我一开始的思路是后序遍历原来的二叉树，然后自底向上调整（旋转）。但最后，这种方法也未能成功地实现，原因是直接照搬AVL树的旋转思路，导致一些情况下不能正确实现。</p>\n',lastUpdated:"2020-12-22",headersStr:null,content:"此题对应了LeetCode第1382题。\n\n另外，此题与第108题十分类似，请参考这篇博客。只不过108题是将有序数组转化为平衡二叉搜索树。如果没做过第108题，可能很容易把本题想复杂，比如我最开始想要么新建一棵树（刚好那天复习了一下AVL树的实现方式），要么就地调整。想了一下，重建的做法应该不太高效，就原地调整，我一开始的思路是后序遍历原来的二叉树，然后自底向上调整（旋转）。但最后，这种方法也未能成功地实现，原因是直接照搬AVL树的旋转思路，导致一些情况下不能正确实现。\n\n本题相比第108题就多了一个求解中序遍历的过程，关于二叉树的遍历问题可以参考这篇博客。\n\nclass Solution {\n    public TreeNode balanceBST(TreeNode root) {\n        List<TreeNode>aws = new ArrayList<>();\n        inOrder(root, aws);\n        return dfs(aws, 0, aws.size() - 1);\n    }\n\n    private void inOrder(TreeNode root, List<TreeNode>aws) {\n        Deque<TreeNode>stack = new ArrayDeque<>();\n        TreeNode tmp = root;\n        while(stack.size() > 0 || tmp != null) {\n            while(tmp != null) {\n                stack.addLast(tmp);\n                tmp = tmp.left;\n            }\n            tmp = stack.pollLast();\n            aws.add(tmp);\n            tmp = tmp.right;\n        }\n    }\n\n    private TreeNode dfs(List<TreeNode> list, int a, int b) {\n        if(a <= b) {\n            int index = (a + b) / 2;\n            TreeNode node = list.get(index);\n            node.left = dfs(list, a, index - 1);\n            node.right = dfs(list, index + 1, b);\n            return node;\n        } else {\n            return null;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33",normalizedContent:"此题对应了leetcode第1382题。\n\n另外，此题与第108题十分类似，请参考这篇博客。只不过108题是将有序数组转化为平衡二叉搜索树。如果没做过第108题，可能很容易把本题想复杂，比如我最开始想要么新建一棵树（刚好那天复习了一下avl树的实现方式），要么就地调整。想了一下，重建的做法应该不太高效，就原地调整，我一开始的思路是后序遍历原来的二叉树，然后自底向上调整（旋转）。但最后，这种方法也未能成功地实现，原因是直接照搬avl树的旋转思路，导致一些情况下不能正确实现。\n\n本题相比第108题就多了一个求解中序遍历的过程，关于二叉树的遍历问题可以参考这篇博客。\n\nclass solution {\n    public treenode balancebst(treenode root) {\n        list<treenode>aws = new arraylist<>();\n        inorder(root, aws);\n        return dfs(aws, 0, aws.size() - 1);\n    }\n\n    private void inorder(treenode root, list<treenode>aws) {\n        deque<treenode>stack = new arraydeque<>();\n        treenode tmp = root;\n        while(stack.size() > 0 || tmp != null) {\n            while(tmp != null) {\n                stack.addlast(tmp);\n                tmp = tmp.left;\n            }\n            tmp = stack.polllast();\n            aws.add(tmp);\n            tmp = tmp.right;\n        }\n    }\n\n    private treenode dfs(list<treenode> list, int a, int b) {\n        if(a <= b) {\n            int index = (a + b) / 2;\n            treenode node = list.get(index);\n            node.left = dfs(list, a, index - 1);\n            node.right = dfs(list, index + 1, b);\n            return node;\n        } else {\n            return null;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33",charsets:{cjk:!0}},{title:"AVL树",frontmatter:{title:"AVL树",categories:["数据结构与算法"],tags:["二叉树","平衡二叉树","AVL树"],date:"2020-11-02T00:00:00.000Z",permalink:"/pages/927005/"},regularPath:"/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/07.AVL%E6%A0%91.html",relativePath:"02.数据结构与算法/07.AVL树.md",key:"v-5cdadc98",path:"/pages/927005/",headers:[{level:2,title:"旋转",slug:"旋转",normalizedTitle:"旋转",charIndex:89},{level:3,title:"LL",slug:"ll",normalizedTitle:"ll",charIndex:149},{level:3,title:"RR",slug:"rr",normalizedTitle:"rr",charIndex:161},{level:3,title:"LR和LR",slug:"lr和lr",normalizedTitle:"lr和lr",charIndex:1439},{level:2,title:"插入节点",slug:"插入节点",normalizedTitle:"插入节点",charIndex:1958},{level:2,title:"删除节点",slug:"删除节点",normalizedTitle:"删除节点",charIndex:111},{level:2,title:"其他相关代码",slug:"其他相关代码",normalizedTitle:"其他相关代码",charIndex:437},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:434}],excerpt:"<p>AVL树是一种平衡二叉树，也可以说是最“严格”的平衡二叉树，因为其要求左右子树高度差不超过1，相比其他的平衡二叉树，该条件更为严苛。平衡二叉树可以解决BST链式化的问题。</p>\n",lastUpdated:"2020-12-22",headersStr:"旋转 LL RR LR和LR 插入节点 删除节点 其他相关代码 参考",content:"AVL树是一种平衡二叉树，也可以说是最“严格”的平衡二叉树，因为其要求左右子树高度差不超过1，相比其他的平衡二叉树，该条件更为严苛。平衡二叉树可以解决BST链式化的问题。\n\n# 旋转\nAVL树中最重要的操作是旋转，即插入和删除节点后，为了让树重新保持平衡，可能需要进行旋转调整。可以总结为四种旋转：LL, LR, RL, RR型，其中L表示左子树的高度比右子树的高度高，R表示右子树的高度比左子树的高度高。所以，在旋转之前，首先需要不平衡子树属于哪种情况。\n\n# LL\n\n\n如上图所示，在调整前以a点为根节点的子树不平衡，原因是其左子树的高度为h+2，而其右子树X高度仅为h。根节点左子树的高度比右子树高度高，且左子树根节点的左子树仍然比其右子树高度高，这种状态称为LL。\n\n调整过程只需要让a的左子节点指向b的右子节点，且b的右子节点指向a，并让b点成为子树的根节点，类似这样的旋转称为右旋。\n\n对应的实现代码如下所示（关于AVLTreeNode的定义以及相关方法请参考~其他相关代码~）：\n\nprivate <T> void R(AVLTreeNode<T> root, AVLTreeNode<T> parent, Boolean isLeftChild) {\n    AVLTreeNode<T> left = (AVLTreeNode<T>) root.getLeft();\n    root.setLeft(left.getRight());\n    left.setRight(root);\n    if (isLeftChild) {\n        parent.setLeft(left);\n    } else {\n        parent.setRight(left);\n    }\n    updateHeight(root); // root已经成为left的右子节点，必须先更新该节点的高度\n    updateHeight(left);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# RR\n\n\n如上图所示，在调整前，a节点的右子树与左子树的高度差为2，而且b节点仍然满足右子树比左子树高（高度差为1），这样的状态称为RR（RR与LL相互对称）。\n\n调整的过程称为左旋，即将a节点的右子节点指向b节点的左子树，然后将b的左子节点指向a。\n\n对应的代码实现如下所示：\n\nprivate <T> void L(AVLTreeNode<T> root, AVLTreeNode<T> parent, Boolean isLeftChild) {\n    AVLTreeNode<T> right = (AVLTreeNode<T>) root.getRight();\n    root.setRight(right.getLeft());\n    right.setLeft(root);\n    if (isLeftChild) {\n        parent.setLeft(right);\n    } else {\n        parent.setRight(right);\n    }\n    updateHeight(root); // root已经成为left的左子节点，必须先更新该节点的高度\n    updateHeight(right);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# LR和LR\n在理解了LL和LR的情况下，理解LR和RL就比较容易了。这里以LR类型为例，RL类型可以类比。\n\n对于LR，需要先对根节点的左子树进行左旋操作，再对当前树做右旋操作。\n\n根据根节点的左子树的右子树的拆分情况，又可以分为A, B, C三类。\n\n\n\n# A\n\n\n这种情况，拆分后的子树左高右低。在以b节点为根节点的子树做了左旋操作过后，得到以c点为根节点的子树，不过此时树仍然不平衡，之后对以a点为根节点的子树进行右旋操作，将c点作为根节点，a点作为c的右子节点，此时树才变为平衡，具体各子树的高度如上图所示。\n\n# B\n\n\n这种情况，拆分后的子树一样高。在以b节点为根节点的子树做了左旋操作过后，得到以c点为根节点的子树，此时该子树处于平衡状态，不过以点a为根节点的子树仍然不平衡，所以继续右旋，最终处于平衡状态，具体子树的高度如上图所示。\n\n# C\n\n\n这种情况，拆分后的子树左低右高。在以b节点为根节点的子树做了左旋操作过后，得到以c点为根节点的子树，此时该子树处于平衡状态，而且不同于前面两种情况，以点a为根节点的子树也已经处于平衡状态，当然，为了实现代码的统一性，继续进行右旋，旋转后树仍然是平衡的。\n\nAVL树的删除和插入节点操作都会进行树的操作，所以在代码中把这一部分逻辑拆离出来，然后在插入或删除后统一地执行该操作。由于插入和删除都要先找到插入点或删除点，在查找的过程中会有一条path，而且发生不平衡的情况只会在该path上，所以在操作插入和删除时，保存该path记录，然后调用进行调整的方法。\n\n下面是进行调整的方法的代码：\n\nprivate <T> AVLTreeNode<T> adjust(Deque<AVLTreeNode<T>> path, Deque<Boolean> lefts) {\n    // chroot为假根，将真实的根节点作为chroot的左孩子\n    AVLTreeNode<T> parent, chroot = new AVLTreeNode<>();\n    chroot.setLeft(path.peekFirst());\n    Boolean isLeftChild;\n    while (path.size() > 0) {\n        parent = path.pollLast();\n        isLeftChild = lefts.pollLast();\n        updateHeight(parent);\n        if (getBalanceFactor(parent) == 2) { // LL or LR\n            if (getBalanceFactor((AVLTreeNode<T>) parent.getLeft()) == -1) { // LR\n                L((AVLTreeNode<T>) parent.getLeft(), parent, true);\n            }\n            // LL型和LR型都需要下面的步骤进行调整\n            R(parent, Objects.nonNull(isLeftChild) ? path.peekLast() : chroot,\n              Objects.nonNull(isLeftChild) ? isLeftChild : true);\n        } else if (getBalanceFactor(parent) == -2) { // RR or RL\n            if (getBalanceFactor((AVLTreeNode<T>) parent.getRight()) == 1) { // RL\n                R((AVLTreeNode<T>) parent.getRight(), parent, false);\n            }\n            // RR型和RL型都需要下面的步骤进行调整\n            L(parent, Objects.nonNull(isLeftChild) ? path.peekLast() : chroot,\n              Objects.nonNull(isLeftChild) ? isLeftChild : true);\n        }\n    }\n    return (AVLTreeNode<T>) chroot.getLeft();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n参数path指的是路径，lefts保存了path中每一个节点（除了第一个外）是其父节点的左孩子（true）还是右孩子（false），在写这篇博客的时候我发现没必要保存lefts，只需在操作节点时动态判断就可以了。\n\n另外，有可能调整过后会改变根节点，然而真实的根节点没有根节点，所以定义了一个变量为假根，其左孩子始终指向真实的根节点。最后返回调整后的真实根节点。\n\n上述代码并没有做优化，这方面我目前还没有分析，~好像只要在中途进行了调整过后，就不用再继续回溯到根节点了~。\n\n对于插入操作和删除操作，与二叉搜索树类似。\n\n# 插入节点\n大体逻辑和BST的插入类似，不过需要将插入节点的父节点到根节点的路径保存下来。\n\npublic <T> AVLTreeNode<T> insert(AVLTreeNode<T> root, T value) {\n    assert Objects.nonNull(value);\n    Deque<AVLTreeNode<T>> path = new ArrayDeque<>();\n    Deque<Boolean> lefts = new ArrayDeque<>();\n    AVLTreeNode<T> node = root;\n    AVLTreeNode<T> newNode = new AVLTreeNode<>(value, 1);\n    while (Objects.nonNull(node)) {\n        path.addLast(node);\n        if (value.compareTo(node.getData()) < 0) {\n            if (Objects.isNull(node.getLeft())) {\n                node.setLeft(newNode);\n                break;\n            } else {\n                node = (AVLTreeNode<T>) node.getLeft();\n                lefts.addLast(true);\n            }\n        } else {\n            if (Objects.isNull(node.getRight())) {\n                node.setRight(newNode);\n                break;\n            } else {\n                node = (AVLTreeNode<T>) node.getRight();\n                lefts.addLast(false);\n            }\n        }\n    }\n    if (path.size() == 0) {\n        return newNode;\n    } else {\n        return adjust(path, lefts);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n# 删除节点\n注意，删除节点时，在第三种情况（左右子树都不为空），要将其节点本身也保存到path栈中。\n\npublic AVLTreeNode<T> remove(AVLTreeNode<T> root, T value) {\n    Deque<AVLTreeNode<T>> path = new ArrayDeque<>();\n    Deque<Boolean> lefts = new ArrayDeque<>();\n    AVLTreeNode<T> node = root;\n    int compare;\n    while (Objects.nonNull(node)) {\n        compare = value.compareTo(node.getData());\n        if (compare == 0) {\n            if (Objects.isNull(node.getLeft()) && Objects.isNull(node.getRight())) {\n                if (node == root) {\n                    return null;\n                } else if (lefts.peekLast()) {\n                    path.peekLast().setLeft(null);\n                } else {\n                    path.peekLast().setRight(null);\n                }\n            } else if (Objects.isNull(node.getLeft()) || Objects.isNull(node.getRight())) {\n                if (node == root) {\n                    return (AVLTreeNode<T>) (Objects.nonNull(node.getLeft()) ? node.getLeft() : node.getRight());\n                } else if (lefts.peekLast()) {\n                    path.peekLast().setLeft(Objects.nonNull(node.getLeft()) ? node.getLeft() : node.getRight());\n                } else {\n                    path.peekLast().setRight(Objects.nonNull(node.getRight()) ? node.getRight() : node.getLeft());\n                }\n            } else {\n                AVLTreeNode<T> parent = node;\n                AVLTreeNode<T> tmp = (AVLTreeNode<T>) node.getLeft();\n                while (Objects.nonNull(tmp.getRight())) {\n                    path.addLast(parent);\n                    parent = tmp;\n                    tmp = (AVLTreeNode<T>) tmp.getRight();\n                }\n                if (tmp == parent.getLeft()) {\n                    parent.setData(tmp.getData());\n                    parent.setLeft(tmp.getLeft());\n                    path.addLast(parent); // 注意这一步\n                } else {\n                    node.setData(tmp.getData());\n                    path.peekLast().setRight(tmp.getLeft());\n                }\n            }\n            node = null;\n        } else if (compare < 0) {\n            path.addLast(node);\n            lefts.addLast(true);\n            node = (AVLTreeNode<T>) node.getLeft();\n        } else {\n            path.addLast(node);\n            lefts.addLast(false);\n            node = (AVLTreeNode<T>) node.getRight();\n        }\n    }\n    return adjust(path, lefts);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n# 其他相关代码\n@Getter\n@Setter\n@ToString\n@NoArgsConstructor\nstatic class AVLTreeNode<T> extends BinTreeNode<T> {\n    int height; // 以当前节点为根节点的子树的高度\n\n    public AVLTreeNode(T value, int height) {\n        super(value);\n        this.height = height;\n    }\n}\n\nprivate int getHeight(AVLTreeNode<T> node) {\n    if (Objects.isNull(node)) {\n        return 0;\n    } else {\n        return node.getHeight();\n    }\n}\n\nprivate void updateHeight(AVLTreeNode<T> node) {\n    assert Objects.nonNull(node);\n    node.setHeight(Math.max(getHeight((AVLTreeNode<T>) node.getLeft()),\n                            getHeight((AVLTreeNode<T>) node.getRight())) + 1);\n}\n\nprivate int getBalanceFactor(AVLTreeNode<T> node) {\n    assert Objects.nonNull(node);\n    return getHeight((AVLTreeNode<T>) node.getLeft()) - getHeight((AVLTreeNode<T>) node.getRight());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n# 参考\n * 天勤数据结构\n * 算法笔记（胡凡等人主编）",normalizedContent:"avl树是一种平衡二叉树，也可以说是最“严格”的平衡二叉树，因为其要求左右子树高度差不超过1，相比其他的平衡二叉树，该条件更为严苛。平衡二叉树可以解决bst链式化的问题。\n\n# 旋转\navl树中最重要的操作是旋转，即插入和删除节点后，为了让树重新保持平衡，可能需要进行旋转调整。可以总结为四种旋转：ll, lr, rl, rr型，其中l表示左子树的高度比右子树的高度高，r表示右子树的高度比左子树的高度高。所以，在旋转之前，首先需要不平衡子树属于哪种情况。\n\n# ll\n\n\n如上图所示，在调整前以a点为根节点的子树不平衡，原因是其左子树的高度为h+2，而其右子树x高度仅为h。根节点左子树的高度比右子树高度高，且左子树根节点的左子树仍然比其右子树高度高，这种状态称为ll。\n\n调整过程只需要让a的左子节点指向b的右子节点，且b的右子节点指向a，并让b点成为子树的根节点，类似这样的旋转称为右旋。\n\n对应的实现代码如下所示（关于avltreenode的定义以及相关方法请参考~其他相关代码~）：\n\nprivate <t> void r(avltreenode<t> root, avltreenode<t> parent, boolean isleftchild) {\n    avltreenode<t> left = (avltreenode<t>) root.getleft();\n    root.setleft(left.getright());\n    left.setright(root);\n    if (isleftchild) {\n        parent.setleft(left);\n    } else {\n        parent.setright(left);\n    }\n    updateheight(root); // root已经成为left的右子节点，必须先更新该节点的高度\n    updateheight(left);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# rr\n\n\n如上图所示，在调整前，a节点的右子树与左子树的高度差为2，而且b节点仍然满足右子树比左子树高（高度差为1），这样的状态称为rr（rr与ll相互对称）。\n\n调整的过程称为左旋，即将a节点的右子节点指向b节点的左子树，然后将b的左子节点指向a。\n\n对应的代码实现如下所示：\n\nprivate <t> void l(avltreenode<t> root, avltreenode<t> parent, boolean isleftchild) {\n    avltreenode<t> right = (avltreenode<t>) root.getright();\n    root.setright(right.getleft());\n    right.setleft(root);\n    if (isleftchild) {\n        parent.setleft(right);\n    } else {\n        parent.setright(right);\n    }\n    updateheight(root); // root已经成为left的左子节点，必须先更新该节点的高度\n    updateheight(right);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# lr和lr\n在理解了ll和lr的情况下，理解lr和rl就比较容易了。这里以lr类型为例，rl类型可以类比。\n\n对于lr，需要先对根节点的左子树进行左旋操作，再对当前树做右旋操作。\n\n根据根节点的左子树的右子树的拆分情况，又可以分为a, b, c三类。\n\n\n\n# a\n\n\n这种情况，拆分后的子树左高右低。在以b节点为根节点的子树做了左旋操作过后，得到以c点为根节点的子树，不过此时树仍然不平衡，之后对以a点为根节点的子树进行右旋操作，将c点作为根节点，a点作为c的右子节点，此时树才变为平衡，具体各子树的高度如上图所示。\n\n# b\n\n\n这种情况，拆分后的子树一样高。在以b节点为根节点的子树做了左旋操作过后，得到以c点为根节点的子树，此时该子树处于平衡状态，不过以点a为根节点的子树仍然不平衡，所以继续右旋，最终处于平衡状态，具体子树的高度如上图所示。\n\n# c\n\n\n这种情况，拆分后的子树左低右高。在以b节点为根节点的子树做了左旋操作过后，得到以c点为根节点的子树，此时该子树处于平衡状态，而且不同于前面两种情况，以点a为根节点的子树也已经处于平衡状态，当然，为了实现代码的统一性，继续进行右旋，旋转后树仍然是平衡的。\n\navl树的删除和插入节点操作都会进行树的操作，所以在代码中把这一部分逻辑拆离出来，然后在插入或删除后统一地执行该操作。由于插入和删除都要先找到插入点或删除点，在查找的过程中会有一条path，而且发生不平衡的情况只会在该path上，所以在操作插入和删除时，保存该path记录，然后调用进行调整的方法。\n\n下面是进行调整的方法的代码：\n\nprivate <t> avltreenode<t> adjust(deque<avltreenode<t>> path, deque<boolean> lefts) {\n    // chroot为假根，将真实的根节点作为chroot的左孩子\n    avltreenode<t> parent, chroot = new avltreenode<>();\n    chroot.setleft(path.peekfirst());\n    boolean isleftchild;\n    while (path.size() > 0) {\n        parent = path.polllast();\n        isleftchild = lefts.polllast();\n        updateheight(parent);\n        if (getbalancefactor(parent) == 2) { // ll or lr\n            if (getbalancefactor((avltreenode<t>) parent.getleft()) == -1) { // lr\n                l((avltreenode<t>) parent.getleft(), parent, true);\n            }\n            // ll型和lr型都需要下面的步骤进行调整\n            r(parent, objects.nonnull(isleftchild) ? path.peeklast() : chroot,\n              objects.nonnull(isleftchild) ? isleftchild : true);\n        } else if (getbalancefactor(parent) == -2) { // rr or rl\n            if (getbalancefactor((avltreenode<t>) parent.getright()) == 1) { // rl\n                r((avltreenode<t>) parent.getright(), parent, false);\n            }\n            // rr型和rl型都需要下面的步骤进行调整\n            l(parent, objects.nonnull(isleftchild) ? path.peeklast() : chroot,\n              objects.nonnull(isleftchild) ? isleftchild : true);\n        }\n    }\n    return (avltreenode<t>) chroot.getleft();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n参数path指的是路径，lefts保存了path中每一个节点（除了第一个外）是其父节点的左孩子（true）还是右孩子（false），在写这篇博客的时候我发现没必要保存lefts，只需在操作节点时动态判断就可以了。\n\n另外，有可能调整过后会改变根节点，然而真实的根节点没有根节点，所以定义了一个变量为假根，其左孩子始终指向真实的根节点。最后返回调整后的真实根节点。\n\n上述代码并没有做优化，这方面我目前还没有分析，~好像只要在中途进行了调整过后，就不用再继续回溯到根节点了~。\n\n对于插入操作和删除操作，与二叉搜索树类似。\n\n# 插入节点\n大体逻辑和bst的插入类似，不过需要将插入节点的父节点到根节点的路径保存下来。\n\npublic <t> avltreenode<t> insert(avltreenode<t> root, t value) {\n    assert objects.nonnull(value);\n    deque<avltreenode<t>> path = new arraydeque<>();\n    deque<boolean> lefts = new arraydeque<>();\n    avltreenode<t> node = root;\n    avltreenode<t> newnode = new avltreenode<>(value, 1);\n    while (objects.nonnull(node)) {\n        path.addlast(node);\n        if (value.compareto(node.getdata()) < 0) {\n            if (objects.isnull(node.getleft())) {\n                node.setleft(newnode);\n                break;\n            } else {\n                node = (avltreenode<t>) node.getleft();\n                lefts.addlast(true);\n            }\n        } else {\n            if (objects.isnull(node.getright())) {\n                node.setright(newnode);\n                break;\n            } else {\n                node = (avltreenode<t>) node.getright();\n                lefts.addlast(false);\n            }\n        }\n    }\n    if (path.size() == 0) {\n        return newnode;\n    } else {\n        return adjust(path, lefts);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n# 删除节点\n注意，删除节点时，在第三种情况（左右子树都不为空），要将其节点本身也保存到path栈中。\n\npublic avltreenode<t> remove(avltreenode<t> root, t value) {\n    deque<avltreenode<t>> path = new arraydeque<>();\n    deque<boolean> lefts = new arraydeque<>();\n    avltreenode<t> node = root;\n    int compare;\n    while (objects.nonnull(node)) {\n        compare = value.compareto(node.getdata());\n        if (compare == 0) {\n            if (objects.isnull(node.getleft()) && objects.isnull(node.getright())) {\n                if (node == root) {\n                    return null;\n                } else if (lefts.peeklast()) {\n                    path.peeklast().setleft(null);\n                } else {\n                    path.peeklast().setright(null);\n                }\n            } else if (objects.isnull(node.getleft()) || objects.isnull(node.getright())) {\n                if (node == root) {\n                    return (avltreenode<t>) (objects.nonnull(node.getleft()) ? node.getleft() : node.getright());\n                } else if (lefts.peeklast()) {\n                    path.peeklast().setleft(objects.nonnull(node.getleft()) ? node.getleft() : node.getright());\n                } else {\n                    path.peeklast().setright(objects.nonnull(node.getright()) ? node.getright() : node.getleft());\n                }\n            } else {\n                avltreenode<t> parent = node;\n                avltreenode<t> tmp = (avltreenode<t>) node.getleft();\n                while (objects.nonnull(tmp.getright())) {\n                    path.addlast(parent);\n                    parent = tmp;\n                    tmp = (avltreenode<t>) tmp.getright();\n                }\n                if (tmp == parent.getleft()) {\n                    parent.setdata(tmp.getdata());\n                    parent.setleft(tmp.getleft());\n                    path.addlast(parent); // 注意这一步\n                } else {\n                    node.setdata(tmp.getdata());\n                    path.peeklast().setright(tmp.getleft());\n                }\n            }\n            node = null;\n        } else if (compare < 0) {\n            path.addlast(node);\n            lefts.addlast(true);\n            node = (avltreenode<t>) node.getleft();\n        } else {\n            path.addlast(node);\n            lefts.addlast(false);\n            node = (avltreenode<t>) node.getright();\n        }\n    }\n    return adjust(path, lefts);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n# 其他相关代码\n@getter\n@setter\n@tostring\n@noargsconstructor\nstatic class avltreenode<t> extends bintreenode<t> {\n    int height; // 以当前节点为根节点的子树的高度\n\n    public avltreenode(t value, int height) {\n        super(value);\n        this.height = height;\n    }\n}\n\nprivate int getheight(avltreenode<t> node) {\n    if (objects.isnull(node)) {\n        return 0;\n    } else {\n        return node.getheight();\n    }\n}\n\nprivate void updateheight(avltreenode<t> node) {\n    assert objects.nonnull(node);\n    node.setheight(math.max(getheight((avltreenode<t>) node.getleft()),\n                            getheight((avltreenode<t>) node.getright())) + 1);\n}\n\nprivate int getbalancefactor(avltreenode<t> node) {\n    assert objects.nonnull(node);\n    return getheight((avltreenode<t>) node.getleft()) - getheight((avltreenode<t>) node.getright());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n# 参考\n * 天勤数据结构\n * 算法笔记（胡凡等人主编）",charsets:{cjk:!0}},{title:"全排列",frontmatter:{title:"全排列",categories:["数据结构与算法"],tags:["全排列"],date:"2020-10-17T00:00:00.000Z",permalink:"/pages/e812d0/"},regularPath:"/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/08.%E5%85%A8%E6%8E%92%E5%88%97.html",relativePath:"02.数据结构与算法/08.全排列.md",key:"v-622dd6e2",path:"/pages/e812d0/",excerpt:'<p>本文讨论的话题对应了<a href="https://leetcode-cn.com/problems/permutations/submissions/" target="_blank" rel="noopener noreferrer">leetcode第46题<OutboundLink/></a>。</p>\n<p>全排列若要深入探究，也是一个比较深入的问题。本文目前只研究字典序法, 实现的算法思想为回溯。</p>\n<p>首先，字典序指按照字典中的顺序进行排序，对于数字，可以按照在数轴上的先后顺序。比如对于n个数的序列{1,2,3...n}，进行字典序全排列，第一个排列为{1,2,3...n}，最后一个排列为{n,n-1,n-1...1}，每一个排列的字典序都比前面排列的字典序大，都比后面排列的字典序小。</p>\n',lastUpdated:"2020-12-22",headersStr:null,content:"本文讨论的话题对应了leetcode第46题。\n\n全排列若要深入探究，也是一个比较深入的问题。本文目前只研究字典序法, 实现的算法思想为回溯。\n\n首先，字典序指按照字典中的顺序进行排序，对于数字，可以按照在数轴上的先后顺序。比如对于n个数的序列{1,2,3...n}，进行字典序全排列，第一个排列为{1,2,3...n}，最后一个排列为{n,n-1,n-1...1}，每一个排列的字典序都比前面排列的字典序大，都比后面排列的字典序小。\n\n上述说法很抽象，可以借助于下图来分析：\n\n\n\n上图是整个全排列的构造过程，所有叶子节点就是最终的全排列结果，所有非叶子节点就是构造的过程。如果先序遍历上述树，那么得到的全排列就是满足字典序的。现在的重点是如何模拟上述树的先序遍历过程。其实可以使用一个栈来模拟上图中括号中的变化，即在down的过程中入栈，up的过程中出栈。当栈满时，说明已经遍历到叶子节点，将栈内的结果拷贝到最终结果中保存，从而实现了回溯的过程。还有一点很重要，就是在入栈的时候，如何选择元素呢？可以用一个数组记录元素的入栈记录，以确保唯一性，每次遍历该数组，取第一个未入栈的元素（置为true），同样地，出栈时，也要保存出栈记录（置为false）。\n\nfunc permute(nums []int) [][]int {\n\tused := make([]bool, len(nums))\n\taws := make([][]int, factorial(len(nums)))\n\tfmt.Println(len(aws))\n\tlist := list.New().Init()\n\tdfs(nums, used, list, aws)\n\treturn aws\n}\n\nfunc dfs(nums []int, used []bool, list *list.List, aws [][]int) {\n\tif list.Len() == len(nums) {\n\t\tcopyList(aws, list)\n\t\treturn\n\t}\n\tfor i := 0; i < len(nums); i++ {\n\t\tif used[i] {\n\t\t\tcontinue\n\t\t}\n\t\tlist.PushBack(nums[i])\n\t\tused[i] = true\n\t\tdfs(nums, used, list, aws)\n\t\tused[i] = false\n\t\tlist.Remove(list.Back())\n\t}\n}\n\nfunc copyList(aws [][]int, list *list.List) {\n\tarr := make([]int, list.Len())\n\tcnt := 0\n\tfor ele := list.Front(); ele != nil; ele = ele.Next() {\n\t\tarr[cnt] = ele.Value.(int)\n\t\tcnt++\n\t}\n\tfor i := 0; i < len(aws); i++ {\n\t\tif aws[i] == nil {\n\t\t\taws[i] = arr\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc factorial(n int) int {\n\tres := 1\n\tfor i := 1; i <= n; i++ {\n\t\tres *= i\n\t}\n\treturn res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n补充一点，由于n个元素的全排列一共有n!中可能的情况，所有在构造最终结果的数组时，先调用factorial计算阶乘。\n\n类似问题还有求一个由字符串中的字符构造成的所有字符串，该问题也是全排列问题，只不过排列的是字符而不是数字。",normalizedContent:"本文讨论的话题对应了leetcode第46题。\n\n全排列若要深入探究，也是一个比较深入的问题。本文目前只研究字典序法, 实现的算法思想为回溯。\n\n首先，字典序指按照字典中的顺序进行排序，对于数字，可以按照在数轴上的先后顺序。比如对于n个数的序列{1,2,3...n}，进行字典序全排列，第一个排列为{1,2,3...n}，最后一个排列为{n,n-1,n-1...1}，每一个排列的字典序都比前面排列的字典序大，都比后面排列的字典序小。\n\n上述说法很抽象，可以借助于下图来分析：\n\n\n\n上图是整个全排列的构造过程，所有叶子节点就是最终的全排列结果，所有非叶子节点就是构造的过程。如果先序遍历上述树，那么得到的全排列就是满足字典序的。现在的重点是如何模拟上述树的先序遍历过程。其实可以使用一个栈来模拟上图中括号中的变化，即在down的过程中入栈，up的过程中出栈。当栈满时，说明已经遍历到叶子节点，将栈内的结果拷贝到最终结果中保存，从而实现了回溯的过程。还有一点很重要，就是在入栈的时候，如何选择元素呢？可以用一个数组记录元素的入栈记录，以确保唯一性，每次遍历该数组，取第一个未入栈的元素（置为true），同样地，出栈时，也要保存出栈记录（置为false）。\n\nfunc permute(nums []int) [][]int {\n\tused := make([]bool, len(nums))\n\taws := make([][]int, factorial(len(nums)))\n\tfmt.println(len(aws))\n\tlist := list.new().init()\n\tdfs(nums, used, list, aws)\n\treturn aws\n}\n\nfunc dfs(nums []int, used []bool, list *list.list, aws [][]int) {\n\tif list.len() == len(nums) {\n\t\tcopylist(aws, list)\n\t\treturn\n\t}\n\tfor i := 0; i < len(nums); i++ {\n\t\tif used[i] {\n\t\t\tcontinue\n\t\t}\n\t\tlist.pushback(nums[i])\n\t\tused[i] = true\n\t\tdfs(nums, used, list, aws)\n\t\tused[i] = false\n\t\tlist.remove(list.back())\n\t}\n}\n\nfunc copylist(aws [][]int, list *list.list) {\n\tarr := make([]int, list.len())\n\tcnt := 0\n\tfor ele := list.front(); ele != nil; ele = ele.next() {\n\t\tarr[cnt] = ele.value.(int)\n\t\tcnt++\n\t}\n\tfor i := 0; i < len(aws); i++ {\n\t\tif aws[i] == nil {\n\t\t\taws[i] = arr\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc factorial(n int) int {\n\tres := 1\n\tfor i := 1; i <= n; i++ {\n\t\tres *= i\n\t}\n\treturn res\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n补充一点，由于n个元素的全排列一共有n!中可能的情况，所有在构造最终结果的数组时，先调用factorial计算阶乘。\n\n类似问题还有求一个由字符串中的字符构造成的所有字符串，该问题也是全排列问题，只不过排列的是字符而不是数字。",charsets:{cjk:!0}},{title:"子集生成",frontmatter:{title:"子集生成",categories:["数据结构与算法"],tags:["子集"],date:"2020-10-19T00:00:00.000Z",permalink:"/pages/a056bd/"},regularPath:"/02.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/09.%E5%AD%90%E9%9B%86%E7%94%9F%E6%88%90.html",relativePath:"02.数据结构与算法/09.子集生成.md",key:"v-4b50a00a",path:"/pages/a056bd/",headers:[{level:2,title:"简述",slug:"简述",normalizedTitle:"简述",charIndex:2},{level:2,title:"增量构造法",slug:"增量构造法",normalizedTitle:"增量构造法",charIndex:175},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1947}],excerpt:'<h2 id="简述"><a class="header-anchor" href="#简述">#</a> 简述</h2>\n<p>对于一个不具有重复元素的集合(Set)，如何求得所有的子集呢？</p>\n<p>一个具有n个元素的集合，那么有<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">2^n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></eq>个子集，其中包括一个空集和其本身，所以其具有<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></eq>个非空子集，具有个<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{n-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span></span></span></span></eq>真子集，具有个<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>2</mn></mrow></msup></mrow><annotation encoding="application/x-tex">2^{n-2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></eq>非空真子集。</p>\n<p>对于该问题，目前我所了解到有三种方法：</p>\n<ul>\n<li>增量构造法</li>\n<li>位向量法</li>\n<li>二进制法</li>\n</ul>\n',lastUpdated:"2020-12-22",headersStr:"简述 增量构造法 参考",content:"# 简述\n对于一个不具有重复元素的集合(Set)，如何求得所有的子集呢？\n\n一个具有n个元素的集合，那么有2n2^n2n个子集，其中包括一个空集和其本身，所以其具有2n−12^{n-1}2n−1个非空子集，具有个2n−12^{n-1}2n−1真子集，具有个2n−22^{n-2}2n−2非空真子集。\n\n对于该问题，目前我所了解到有三种方法：\n\n * 增量构造法\n * 位向量法\n * 二进制法\n\n首先来看第一种，增量构造法，对于后面两种方法，再做补充。\n\n# 增量构造法\n“增量”的含义为每次从原始集合中选出一个剩下还未被添加的元素。可以通过下图来理解：\n\n\n\n上图展示了对于集合[1, 2]增量构造的过程，所有的叶子节点表示的就是所求的子集。定义一个存储容器为workList，保存中间值。最初，该容器的初始值为空集，对应根节点位置。除了最下一层的每一层表示从原始集合中取一个数进行处理，取的时候可以按照原始相对顺序来取，比如从前到后，这样可以避免产生重复的集合（比如[1, 2]和[2, 1]）。由于原始集合中不存在重复元素，所以在每一层，从上一层得到的临时集合都是不相同的，当前被处理的元素分别执行添加和不添加到上一层处理后的每一个临时集合中，这样可以覆盖所有的情况。\n\n该方法的关键之处为：\n\n * 如何确保不求出重复子集\n * 如何确保求出了所有的子集\n\n对于代码，使用递归处理上述每一层，当递归到最下面一层，则终止递归，不像之前分析过的全排列的递归过程，这里需要一个变量来显示表示当前递归到的层数（全排列中每一层得到的中间结果的长度都是一样的，所以可以用该长度来确定层数；但是此问题中，所有中间得到的临时集合都是长短不一的，所以需要其他方法来确定）。还需要一个保存临时集合的变量（上述分析中提到的workList），对应树中所有的非叶子节点，首先复制一份当前临时集合，此时两份集合分别记为A和B，该复制操作必须在进行下一轮遍历之前进行，否则结果会大相径庭。然后将当前被处理元素添加进任一集合（比如A），然后分别将A和B作为临时集合进行下一轮递归，直到所有元素都被处理，此时该临时集合就成为了最终所求的子集，然后保存到最后的结果中。\n\npublic class Subset {\n    public static void main(String[] args) {\n        List<Integer> nums = Arrays.asList(1, 2, 3, 4);\n        List<List<Integer>> aws = new ArrayList<>();\n        dfs(nums, 0, new ArrayList<>(), aws);\n        aws.forEach(l -> System.out.println(l.toString())); // print out the result\n    }\n    public static void dfs(List<Integer>nums, int index, List<Integer> workList, List<List<Integer>> aws) {\n        if (index == nums.size()) {\n            aws.add(workList);\n            return;\n        }\n        List<Integer> nextList = new ArrayList<>(workList);\n        dfs(nums, index + 1, workList, aws);\n        nextList.add(nums.get(index));\n        dfs(nums, index + 1, nextList, aws);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n上述代码执行后的结果如下：\n\n[]\n[4]\n[3]\n[3, 4]\n[2]\n[2, 4]\n[2, 3]\n[2, 3, 4]\n[1]\n[1, 4]\n[1, 3]\n[1, 3, 4]\n[1, 2]\n[1, 2, 4]\n[1, 2, 3]\n[1, 2, 3, 4]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n可以发现，除了第一个空子集，其他都是字典序降序的。而且在每一组开头元素相同的子集中，长度是依次增加的（当然也可以依次减少，这是由代码中先递归上述分析中提到的集合A还是B决定的）。\n\n# 参考\n * 《算法竞赛入门经典（第二版）》刘汝佳\n * CSDojo，视频，对于增量构造法的讲解",normalizedContent:"# 简述\n对于一个不具有重复元素的集合(set)，如何求得所有的子集呢？\n\n一个具有n个元素的集合，那么有2n2^n2n个子集，其中包括一个空集和其本身，所以其具有2n−12^{n-1}2n−1个非空子集，具有个2n−12^{n-1}2n−1真子集，具有个2n−22^{n-2}2n−2非空真子集。\n\n对于该问题，目前我所了解到有三种方法：\n\n * 增量构造法\n * 位向量法\n * 二进制法\n\n首先来看第一种，增量构造法，对于后面两种方法，再做补充。\n\n# 增量构造法\n“增量”的含义为每次从原始集合中选出一个剩下还未被添加的元素。可以通过下图来理解：\n\n\n\n上图展示了对于集合[1, 2]增量构造的过程，所有的叶子节点表示的就是所求的子集。定义一个存储容器为worklist，保存中间值。最初，该容器的初始值为空集，对应根节点位置。除了最下一层的每一层表示从原始集合中取一个数进行处理，取的时候可以按照原始相对顺序来取，比如从前到后，这样可以避免产生重复的集合（比如[1, 2]和[2, 1]）。由于原始集合中不存在重复元素，所以在每一层，从上一层得到的临时集合都是不相同的，当前被处理的元素分别执行添加和不添加到上一层处理后的每一个临时集合中，这样可以覆盖所有的情况。\n\n该方法的关键之处为：\n\n * 如何确保不求出重复子集\n * 如何确保求出了所有的子集\n\n对于代码，使用递归处理上述每一层，当递归到最下面一层，则终止递归，不像之前分析过的全排列的递归过程，这里需要一个变量来显示表示当前递归到的层数（全排列中每一层得到的中间结果的长度都是一样的，所以可以用该长度来确定层数；但是此问题中，所有中间得到的临时集合都是长短不一的，所以需要其他方法来确定）。还需要一个保存临时集合的变量（上述分析中提到的worklist），对应树中所有的非叶子节点，首先复制一份当前临时集合，此时两份集合分别记为a和b，该复制操作必须在进行下一轮遍历之前进行，否则结果会大相径庭。然后将当前被处理元素添加进任一集合（比如a），然后分别将a和b作为临时集合进行下一轮递归，直到所有元素都被处理，此时该临时集合就成为了最终所求的子集，然后保存到最后的结果中。\n\npublic class subset {\n    public static void main(string[] args) {\n        list<integer> nums = arrays.aslist(1, 2, 3, 4);\n        list<list<integer>> aws = new arraylist<>();\n        dfs(nums, 0, new arraylist<>(), aws);\n        aws.foreach(l -> system.out.println(l.tostring())); // print out the result\n    }\n    public static void dfs(list<integer>nums, int index, list<integer> worklist, list<list<integer>> aws) {\n        if (index == nums.size()) {\n            aws.add(worklist);\n            return;\n        }\n        list<integer> nextlist = new arraylist<>(worklist);\n        dfs(nums, index + 1, worklist, aws);\n        nextlist.add(nums.get(index));\n        dfs(nums, index + 1, nextlist, aws);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n上述代码执行后的结果如下：\n\n[]\n[4]\n[3]\n[3, 4]\n[2]\n[2, 4]\n[2, 3]\n[2, 3, 4]\n[1]\n[1, 4]\n[1, 3]\n[1, 3, 4]\n[1, 2]\n[1, 2, 4]\n[1, 2, 3]\n[1, 2, 3, 4]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n可以发现，除了第一个空子集，其他都是字典序降序的。而且在每一组开头元素相同的子集中，长度是依次增加的（当然也可以依次减少，这是由代码中先递归上述分析中提到的集合a还是b决定的）。\n\n# 参考\n * 《算法竞赛入门经典（第二版）》刘汝佳\n * csdojo，视频，对于增量构造法的讲解",charsets:{cjk:!0}},{title:"CPU缓存的基础架构",frontmatter:{title:"CPU缓存的基础架构",categories:["计算机体系结构"],tags:["Cache"],date:"2020-12-13T22:49:00.000Z",lang:"zh-CN",permalink:"/pages/4e8b73/"},regularPath:"/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/01.%E7%BC%93%E5%AD%98/01.CPU%E7%BC%93%E5%AD%98%E7%9A%84%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84.html",relativePath:"03.计算机体系结构/01.缓存/01.CPU缓存的基础架构.md",key:"v-03e359ac",path:"/pages/4e8b73/",headers:[{level:2,title:"缓存结构",slug:"缓存结构",normalizedTitle:"缓存结构",charIndex:2},{level:2,title:"缓存读取",slug:"缓存读取",normalizedTitle:"缓存读取",charIndex:468},{level:2,title:"缓存替换",slug:"缓存替换",normalizedTitle:"缓存替换",charIndex:1293},{level:2,title:"缓存写出",slug:"缓存写出",normalizedTitle:"缓存写出",charIndex:1558},{level:2,title:"多级缓存的包含策略",slug:"多级缓存的包含策略",normalizedTitle:"多级缓存的包含策略",charIndex:2177},{level:2,title:"缓存寻址和地址转换后备缓冲区",slug:"缓存寻址和地址转换后备缓冲区",normalizedTitle:"缓存寻址和地址转换后备缓冲区",charIndex:3510},{level:2,title:"非阻塞缓存",slug:"非阻塞缓存",normalizedTitle:"非阻塞缓存",charIndex:3719},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:3915}],excerpt:'<h2 id="缓存结构"><a class="header-anchor" href="#缓存结构">#</a> 缓存结构</h2>\n<p>一般情况下，缓存空间分为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span></eq>个组，每个组又分为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>E</mi></mrow><annotation encoding="application/x-tex">E</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span></span></span></span></eq>行，在每一行中，存储了<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi></mrow><annotation encoding="application/x-tex">B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></eq>字节（经过工业界的实践，目前缓存块一般为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>64</mn><mi>B</mi></mrow><annotation encoding="application/x-tex">64B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">6</span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></eq>）的块（有效数据）以及有效位和标记位（元数据），所有缓存块的总大小为<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>C</mi><mo>=</mo><mi>S</mi><mo>×</mo><mi>E</mi><mo>×</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">C=S \\times E \\times B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span></eq>个字节，元数据不包括在缓存空间大小内。</p>\n',lastUpdated:"2021-01-19",headersStr:"缓存结构 缓存读取 缓存替换 缓存写出 多级缓存的包含策略 缓存寻址和地址转换后备缓冲区 非阻塞缓存 参考",content:"# 缓存结构\n一般情况下，缓存空间分为SSS个组，每个组又分为EEE行，在每一行中，存储了BBB字节（经过工业界的实践，目前缓存块一般为64B64B64B）的块（有效数据）以及有效位和标记位（元数据），所有缓存块的总大小为C=S×E×BC=S \\times E \\times BC=S×E×B个字节，元数据不包括在缓存空间大小内。\n\n内存地址被划分为三个部分，标记，组索引和块偏移：\n\n * 标记：在每个组内唯一地标识缓存块，注意，在所有缓存块中该标识不唯一。\n * 组索引：确定该缓存块存放于哪个组中。\n * 块偏移：表示该地址在缓存块中的偏移地址。\n\n根据组中所包含的行的数量，大体可以把映射关系分为三类：\n\n * 直接映射（direct-mapped）：每个组只有一行。\n * 全相联（fully-associative）：整个缓存中只有一个组，组中包含所有的行。\n * 组相联（set-associative）：即上图中所示的情况，分为SSS个组，每个组有EEE行。\n\n因为平衡直接映射和全相联的极端，组相联被广泛使用。\n\n# 缓存读取\n下图是CPU读取二路组相联缓存的过程示意图：\n\n上图中一共列举了7个步骤。\n\n 1. 根据目标地址求得缓存块应在的组索引。\n    \n    \n 2. 根据组索引在tag数组中获取相应组的标记。\n    \n    \n 3. 从目标地址中求得标识，然后在SA（sensor amplifier，读出放大器）中与第2步中取得的标记进行比较，目的是确认目标地址是否在缓存中。如果存在匹配，那么缓存命中（cache hit），否则，缓存未命中（cache miss）。\n    \n    \n 4. 在执行第2步和第3步的同时，从data数组中读取相应的缓存块。\n    \n    \n 5. 如果在第3步中存在匹配，那么取出对应的缓存块。\n    \n    \n 6. 根据地址中的缓存偏移（block offset）从第5步中取出的缓存块中读取数据。\n    \n    \n 7. 将第6步中读取的数据递交给CPU。\n    \n    \n\n以上7个步骤只是一般过程，在一些高性能的缓存中，上述步骤可能采用流水线来提高缓存读取吞吐量，从而可以处理多个缓存读取请求。而且在现实中为了满足各种需求，整个过程会十分复杂。比如步骤1，步骤2和步骤4可能被线性或并行执行。\n\n * 线性执行的优势是在确定缓存命中后，只需要读取data数组中同一组中对应的缓存块即可，如果缓存未命中，则不需要从data数组中读取数据。\n   \n   \n * 并行执行的优势是在确定缓存命中或未命中时，相应的数据块已经被读取到了，接下来仅需要做的是找到对应的数据块以及块中对应的数据，该方法在缓存命中时会更快，但是效率却不高（在缓存未命中时尤为明显），因为同一组中的数据块都被读取了。\n   \n   \n\n在某些设计中，L1L1L1缓存采用并行执行，而L2L2L2和L3L3L3缓存采用线性执行，因为L1L1L1缓存所要求达到的缓存命中率要更高，大部分情况下，步骤四不是徒劳的。\n\n# 缓存替换\n由于缓存空间远远小于主存空间，那么某些情况可能导致缓存满了，则需要进行缓存淘汰。具体的算法有下面几种：\n\n * 最佳淘汰算法（OPT）： 该算法是理想化的，实际不能被实现。其指淘汰未来最久之后才使用的缓存块，由于不能确定未来的情况，所以该算法不能被实现，但是能够为其他算法的优劣提供评判依据。\n * 最近最少使用（LRU）： 该算法被广为使用，其指淘汰过去一段时间内最少使用的缓存块。但是该算法在循坏访问同一组中的缓存块时（其单次循环读取的缓存块数量大于每组容纳的数量），会导致性能下降（因为会不断地进行替换）。\n\n# 缓存写出\n当CPU修改了缓存的值，何时写出到外围存储器（可能是次级缓存也可能是主存）中是个重要的问题。主要有两种实现：\n\n * 写通（write through）：指缓存中的任何修改都会被立即写出到主存中。\n * 写回（write back）：指只有在缓存在被替换时，被修改过的缓存块才会被写出到外层存储器中，所以CPU的缓存行中需要一个比特位来标记该缓存行是否被更改过。\n\n芯片最外层缓存通常会采用写回策略，因为写通会占用更多的总线带宽。\n\n另外，两者在容错性方面存在差异，由于某些软故障，可能会导致某些比特的值更改，从而使缓存块的值无效。写通策略的容错性更高一些，因为其有效数据已经被写到外围存储中了。采用写回策略的画，不仅需要错误探测，还需要错误纠正，通常采用纠错码（error correcting code [ECC]），但是ECC具有计算开销。因此，在很多实现中，L1L1L1缓存采用写通策略，L2L2L2缓存采用写回策略并用ECC加以保护数据。\n\n如果CPU所写的数据不在缓存中，那么也有两种实现：\n\n * 写分配：在写之前，先从外层存储器中读取对应的缓存块，然后再修改。\n * 写不分配：直接写出到对外层存储器中。\n\n如果所写内容所在的缓存块在将来不需要被读或写，那么采用写不分配会更佳，尤其是在内层缓存空间较小的情况下。反之，写分配更佳。写通策略既可以使用写分配也可以使用写不分配，而写回策略只有使用写分配策略。\n\n# 多级缓存的包含策略\n在多级缓存中，内层缓存的内容是否同时需要在外层缓存中存在，这就引入了一个缓存包含问题。\n\n * 如果外围缓存包含内层缓存的数据，那么则称为包含（inclusive）。\n * 如果外围缓存不包含内层缓存的数据，那么则称为排斥（exclusive）。\n * inclusive和exclusive都需要某些协议来实现，如果没有协议支持，则可以实现既不包含也不排斥策略（non-inclusive non-exclusive [NINE]）。\n\n这里使用L1L1L1（内层）和L2L2L2（外层）缓存来举例，假设最开始，L2L2L2缓存具有Z，L1L1L1缓存为空。\n\n首先L1L1L1缓存未命中X和Y，L2中也没有，那么则需要从主存中获取，这一步的状态如下图所示：\n\n\n\n可见，在inclusive和NINE策略下，外层缓存保存了内层缓存的内容，则exclusive策略下，外层缓存则没有保存。\n\n接下来在L1L1L1缓存淘汰X，这一步的状态如下图所示：\n\n\n\n可见，在exclusive策略下，外层缓存“收留”了被淘汰的数据。对于另外两种策略，其外层缓存中肯定存在副本，所以内层缓存直接淘汰即可。\n\n接下来在L2L2L2缓存中淘汰Y，这一步的状态如下图所示：\n\n\n\n在inclusive模式下，外层缓存中数据淘汰导致内层缓存也跟着淘汰（向上失效）。在NINE策略下，则仅仅淘汰外层缓存的数据。这也是NINE和inclusive策略的区别。\n\n最后，在L1L1L1未命中Z时，这一步的状态如下图所示：\n\n\n\n在inclusive和NINE模式下，外层缓存都将数据拷贝到内层缓存中。而exclusive模式下，外层缓存在拷贝后将其淘汰掉。\n\n除了上面对三种策略的基本定义之外，还有更多特性：\n\n * inclusive策略：内层缓存所包含的数据一定在外层缓存中，外层缓存中没有的数据在内层缓存中一定没有。在某些核芯独享的缓存中遇到未命中的情况时，需要在其他核芯的缓存中去找，如果核芯数量多了，查找成本会很高，如果使用inclusive策略则不必去其他核芯中找，直接到外层缓存中找即可。\n   \n   \n * NINE策略：内层缓存所包含的数据，外层缓存一定有；外层缓存没有的数据，内层缓存仍然可能有。\n   \n   \n * exclusive策略：内存缓存所包含的数据，外层缓存一定没有，外层缓存包含的数据，内层缓存一定没有。\n   \n   \n * inclusive策略下，缓存未命中延迟更短，而另外两种则更长些。就算所有的缓存中都没有数据，那么inclusive策略下，也会更快地向主存中获取数据。\n   \n   \n * inclusive策略下，对外层缓存的利用率不高，尤其是在外层缓存的容量不大的情况下。\n   \n   \n * exclusive策略下，整体上缓存能够存放更多不同的缓存块，同时也会导致频繁地填充新的缓存块（内层缓存每次淘汰的外层缓存都会进行“收留”）。\n   \n   \n * NINE策略下，不保证缓存块的不存在。\n   \n   \n\n综上所述，设计者应该根据具体的缓存空间大小计算整体的缓存利用率来决定使用哪一种策略。\n\n# 缓存寻址和地址转换后备缓冲区\nCPU根据指令进行寻址，然而寻址操作的操作数是进程的虚拟地址空间地址，而不是真实物理内存的地址。而缓存中是根据物理内存地址来存储缓存块的，所以在寻址之前，CPU需要先将虚拟地址空间转换为物理内存的地址。进程的页表是存放在主存中的，而CPU在访问缓存之前就要译址，所以CPU也考虑将页表缓存到缓冲区中，这就是TLB（translation lookaside buffer）的由来。\n\n# 非阻塞缓存\n在早期处理器中，当缓存未命中时，CPU一直等到缓存块被读取到缓存中为止，这严重降低了性能。所以现代处理器引入了未命中状态处理寄存器（miss status handling registers [MSHRs]）。当缓存未命中时，为该次未命中分配一个该寄存器来跟踪获取情况，当读取到缓存时，在回收掉该寄存器。当寄存器分配后，即可处理下一个缓存查找的任务，从而大大提升了效率。\n\n# 参考\n * 《深入理解计算机系统（第三版）》\n * Fundamentals of Parallel Multicore Architecture",normalizedContent:"# 缓存结构\n一般情况下，缓存空间分为sss个组，每个组又分为eee行，在每一行中，存储了bbb字节（经过工业界的实践，目前缓存块一般为64b64b64b）的块（有效数据）以及有效位和标记位（元数据），所有缓存块的总大小为c=s×e×bc=s \\times e \\times bc=s×e×b个字节，元数据不包括在缓存空间大小内。\n\n内存地址被划分为三个部分，标记，组索引和块偏移：\n\n * 标记：在每个组内唯一地标识缓存块，注意，在所有缓存块中该标识不唯一。\n * 组索引：确定该缓存块存放于哪个组中。\n * 块偏移：表示该地址在缓存块中的偏移地址。\n\n根据组中所包含的行的数量，大体可以把映射关系分为三类：\n\n * 直接映射（direct-mapped）：每个组只有一行。\n * 全相联（fully-associative）：整个缓存中只有一个组，组中包含所有的行。\n * 组相联（set-associative）：即上图中所示的情况，分为sss个组，每个组有eee行。\n\n因为平衡直接映射和全相联的极端，组相联被广泛使用。\n\n# 缓存读取\n下图是cpu读取二路组相联缓存的过程示意图：\n\n上图中一共列举了7个步骤。\n\n 1. 根据目标地址求得缓存块应在的组索引。\n    \n    \n 2. 根据组索引在tag数组中获取相应组的标记。\n    \n    \n 3. 从目标地址中求得标识，然后在sa（sensor amplifier，读出放大器）中与第2步中取得的标记进行比较，目的是确认目标地址是否在缓存中。如果存在匹配，那么缓存命中（cache hit），否则，缓存未命中（cache miss）。\n    \n    \n 4. 在执行第2步和第3步的同时，从data数组中读取相应的缓存块。\n    \n    \n 5. 如果在第3步中存在匹配，那么取出对应的缓存块。\n    \n    \n 6. 根据地址中的缓存偏移（block offset）从第5步中取出的缓存块中读取数据。\n    \n    \n 7. 将第6步中读取的数据递交给cpu。\n    \n    \n\n以上7个步骤只是一般过程，在一些高性能的缓存中，上述步骤可能采用流水线来提高缓存读取吞吐量，从而可以处理多个缓存读取请求。而且在现实中为了满足各种需求，整个过程会十分复杂。比如步骤1，步骤2和步骤4可能被线性或并行执行。\n\n * 线性执行的优势是在确定缓存命中后，只需要读取data数组中同一组中对应的缓存块即可，如果缓存未命中，则不需要从data数组中读取数据。\n   \n   \n * 并行执行的优势是在确定缓存命中或未命中时，相应的数据块已经被读取到了，接下来仅需要做的是找到对应的数据块以及块中对应的数据，该方法在缓存命中时会更快，但是效率却不高（在缓存未命中时尤为明显），因为同一组中的数据块都被读取了。\n   \n   \n\n在某些设计中，l1l1l1缓存采用并行执行，而l2l2l2和l3l3l3缓存采用线性执行，因为l1l1l1缓存所要求达到的缓存命中率要更高，大部分情况下，步骤四不是徒劳的。\n\n# 缓存替换\n由于缓存空间远远小于主存空间，那么某些情况可能导致缓存满了，则需要进行缓存淘汰。具体的算法有下面几种：\n\n * 最佳淘汰算法（opt）： 该算法是理想化的，实际不能被实现。其指淘汰未来最久之后才使用的缓存块，由于不能确定未来的情况，所以该算法不能被实现，但是能够为其他算法的优劣提供评判依据。\n * 最近最少使用（lru）： 该算法被广为使用，其指淘汰过去一段时间内最少使用的缓存块。但是该算法在循坏访问同一组中的缓存块时（其单次循环读取的缓存块数量大于每组容纳的数量），会导致性能下降（因为会不断地进行替换）。\n\n# 缓存写出\n当cpu修改了缓存的值，何时写出到外围存储器（可能是次级缓存也可能是主存）中是个重要的问题。主要有两种实现：\n\n * 写通（write through）：指缓存中的任何修改都会被立即写出到主存中。\n * 写回（write back）：指只有在缓存在被替换时，被修改过的缓存块才会被写出到外层存储器中，所以cpu的缓存行中需要一个比特位来标记该缓存行是否被更改过。\n\n芯片最外层缓存通常会采用写回策略，因为写通会占用更多的总线带宽。\n\n另外，两者在容错性方面存在差异，由于某些软故障，可能会导致某些比特的值更改，从而使缓存块的值无效。写通策略的容错性更高一些，因为其有效数据已经被写到外围存储中了。采用写回策略的画，不仅需要错误探测，还需要错误纠正，通常采用纠错码（error correcting code [ecc]），但是ecc具有计算开销。因此，在很多实现中，l1l1l1缓存采用写通策略，l2l2l2缓存采用写回策略并用ecc加以保护数据。\n\n如果cpu所写的数据不在缓存中，那么也有两种实现：\n\n * 写分配：在写之前，先从外层存储器中读取对应的缓存块，然后再修改。\n * 写不分配：直接写出到对外层存储器中。\n\n如果所写内容所在的缓存块在将来不需要被读或写，那么采用写不分配会更佳，尤其是在内层缓存空间较小的情况下。反之，写分配更佳。写通策略既可以使用写分配也可以使用写不分配，而写回策略只有使用写分配策略。\n\n# 多级缓存的包含策略\n在多级缓存中，内层缓存的内容是否同时需要在外层缓存中存在，这就引入了一个缓存包含问题。\n\n * 如果外围缓存包含内层缓存的数据，那么则称为包含（inclusive）。\n * 如果外围缓存不包含内层缓存的数据，那么则称为排斥（exclusive）。\n * inclusive和exclusive都需要某些协议来实现，如果没有协议支持，则可以实现既不包含也不排斥策略（non-inclusive non-exclusive [nine]）。\n\n这里使用l1l1l1（内层）和l2l2l2（外层）缓存来举例，假设最开始，l2l2l2缓存具有z，l1l1l1缓存为空。\n\n首先l1l1l1缓存未命中x和y，l2中也没有，那么则需要从主存中获取，这一步的状态如下图所示：\n\n\n\n可见，在inclusive和nine策略下，外层缓存保存了内层缓存的内容，则exclusive策略下，外层缓存则没有保存。\n\n接下来在l1l1l1缓存淘汰x，这一步的状态如下图所示：\n\n\n\n可见，在exclusive策略下，外层缓存“收留”了被淘汰的数据。对于另外两种策略，其外层缓存中肯定存在副本，所以内层缓存直接淘汰即可。\n\n接下来在l2l2l2缓存中淘汰y，这一步的状态如下图所示：\n\n\n\n在inclusive模式下，外层缓存中数据淘汰导致内层缓存也跟着淘汰（向上失效）。在nine策略下，则仅仅淘汰外层缓存的数据。这也是nine和inclusive策略的区别。\n\n最后，在l1l1l1未命中z时，这一步的状态如下图所示：\n\n\n\n在inclusive和nine模式下，外层缓存都将数据拷贝到内层缓存中。而exclusive模式下，外层缓存在拷贝后将其淘汰掉。\n\n除了上面对三种策略的基本定义之外，还有更多特性：\n\n * inclusive策略：内层缓存所包含的数据一定在外层缓存中，外层缓存中没有的数据在内层缓存中一定没有。在某些核芯独享的缓存中遇到未命中的情况时，需要在其他核芯的缓存中去找，如果核芯数量多了，查找成本会很高，如果使用inclusive策略则不必去其他核芯中找，直接到外层缓存中找即可。\n   \n   \n * nine策略：内层缓存所包含的数据，外层缓存一定有；外层缓存没有的数据，内层缓存仍然可能有。\n   \n   \n * exclusive策略：内存缓存所包含的数据，外层缓存一定没有，外层缓存包含的数据，内层缓存一定没有。\n   \n   \n * inclusive策略下，缓存未命中延迟更短，而另外两种则更长些。就算所有的缓存中都没有数据，那么inclusive策略下，也会更快地向主存中获取数据。\n   \n   \n * inclusive策略下，对外层缓存的利用率不高，尤其是在外层缓存的容量不大的情况下。\n   \n   \n * exclusive策略下，整体上缓存能够存放更多不同的缓存块，同时也会导致频繁地填充新的缓存块（内层缓存每次淘汰的外层缓存都会进行“收留”）。\n   \n   \n * nine策略下，不保证缓存块的不存在。\n   \n   \n\n综上所述，设计者应该根据具体的缓存空间大小计算整体的缓存利用率来决定使用哪一种策略。\n\n# 缓存寻址和地址转换后备缓冲区\ncpu根据指令进行寻址，然而寻址操作的操作数是进程的虚拟地址空间地址，而不是真实物理内存的地址。而缓存中是根据物理内存地址来存储缓存块的，所以在寻址之前，cpu需要先将虚拟地址空间转换为物理内存的地址。进程的页表是存放在主存中的，而cpu在访问缓存之前就要译址，所以cpu也考虑将页表缓存到缓冲区中，这就是tlb（translation lookaside buffer）的由来。\n\n# 非阻塞缓存\n在早期处理器中，当缓存未命中时，cpu一直等到缓存块被读取到缓存中为止，这严重降低了性能。所以现代处理器引入了未命中状态处理寄存器（miss status handling registers [mshrs]）。当缓存未命中时，为该次未命中分配一个该寄存器来跟踪获取情况，当读取到缓存时，在回收掉该寄存器。当寄存器分配后，即可处理下一个缓存查找的任务，从而大大提升了效率。\n\n# 参考\n * 《深入理解计算机系统（第三版）》\n * fundamentals of parallel multicore architecture",charsets:{cjk:!0}},{title:"CPU缓存一致性协议概述",frontmatter:{title:"CPU缓存一致性协议概述",categories:["计算机体系结构"],tags:["Cache"],date:"2020-12-19T13:22:10.000Z",permalink:"/pages/856225/"},regularPath:"/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/01.%E7%BC%93%E5%AD%98/02.CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%E6%A6%82%E8%BF%B0.html",relativePath:"03.计算机体系结构/01.缓存/02.CPU缓存一致性协议概述.md",key:"v-8b35246c",path:"/pages/856225/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:172},{level:2,title:"总线嗅探",slug:"总线嗅探",normalizedTitle:"总线嗅探",charIndex:815},{level:2,title:"采用写通的缓存一致性协议",slug:"采用写通的缓存一致性协议",normalizedTitle:"采用写通的缓存一致性协议",charIndex:1497},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2630}],excerpt:'<p>多核CPU真正实现了程序的并行，然而现实中很多常见的CPU拥有多级缓存架构，某些处理器架构（如intel skylake）中的缓存就分为三层，其中<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>1</mn></mrow><annotation encoding="application/x-tex">L1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">1</span></span></span></span></eq>和<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">L2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">2</span></span></span></span></eq>为核芯独享，<eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>L</mi><mn>3</mn></mrow><annotation encoding="application/x-tex">L3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault">L</span><span class="mord">3</span></span></span></span></eq>为所有核芯共享。虽然缓存大大提升了处理器的效率，但是当访问共享内存的多个线程在不同的核芯上执行时，可能会导致一个很严重的问题--缓存一致性。</p>\n',lastUpdated:"2021-01-19",headersStr:"概述 总线嗅探 采用写通的缓存一致性协议 参考",content:"多核CPU真正实现了程序的并行，然而现实中很多常见的CPU拥有多级缓存架构，某些处理器架构（如intel skylake）中的缓存就分为三层，其中L1L1L1和L2L2L2为核芯独享，L3L3L3为所有核芯共享。虽然缓存大大提升了处理器的效率，但是当访问共享内存的多个线程在不同的核芯上执行时，可能会导致一个很严重的问题--缓存一致性。\n\n# 概述\n提示\n\nCPU核芯之间如何组织以及如何互联对设计缓存一致性协议有非常大的影响。本文目前仅对基于总线的架构进行讨论，例如其他点对点（point-to-point）的架构暂时不讨论。\n\n导致缓存一致性的原因是多个核芯的私有缓存中有同样的缓存块，而其中某个缓存块被修改了，但是其他的核芯对此毫无察觉（就算核芯采用写通策略，也无法让其他核芯感知），继续读取到其私有缓存中的脏数据。\n\n解决上述问题也就是实现缓存一致性需要保证两点：\n\n * 写传播：即让核芯感知到其他核芯内的数据修改。\n * 事务串行化：多个核芯同一段时间内对同一缓存块的修改的先后顺序在其他所有核芯看来是一致的。\n\n写传播有两种方式来实现，写失效和写更新：\n\n * 写失效（write invalidate）：在核芯准备更新缓存时，通知其他的核芯让其内部的该缓存块失效。当需要多次修改时，这种方法比较高效（后序修改不用再让其他缓存块失效）。\n * 写更新（write update）：在核芯准备更新缓存时，通知其他的核芯修改其内部对应的数据。当修改完后，其他核芯需要读数据时，该方法比较高效。\n\n如果是基于总线实现缓存一致性的话，那么天然支持事务串行化，因为多个设备要使用总线，首先要经过总线仲裁，由仲裁器来决定使用的先后顺序。注意，总线不一定是同步的，即不一定是先读完某个缓存块后再写某个缓存块，有可能是在发起读取请求后，就开始写操作了，这样的总线称作为异步总线。异步总线相比同步总线的优点是吞吐量大，效率高。\n\n# 总线嗅探\n基于总线的缓存一致性重点是如何实现写传播，本文来分析广播/嗅探（broadcast/snoop）机制。\n\n提示\n\n广播/嗅探机制是实现写传播的方式中的一种，除此之外，还有目录（directory）机制。前者的优点是实现简单，缺点是可扩展性差。后者的优点是可扩展性高，缺点是需要额外的存储空间。\n\n注意\n\n在具体讨论该机制前，首先说明一下：上面也说到了，三级缓存中L1L1L1和L2L2L2都是核芯私有的，而L3L3L3是多个核芯共享的。下述讨论中，把L1L1L1和L2L2L2看成一级缓存，同时把L3L3L3看作是主存。至于L3如何把数据同步到真实的主存中暂时不讨论。\n\n由于CPU的架构“千奇百怪”，不可能把所有的情况都讨论完，本文只讨论一些常见的，然后在写程序时心里有底就行了。\n\n连接缓存总线的各方都有一个一致性控制器，其示意图如下：\n\n\n\n * 事务表（Outstanding Transaction Table）：保存由当前核芯发起的未完成的总线事务表。\n * 总线嗅探器（snooper）：监听总线上的事务。当其接收到信号时，控制器检测缓存内的tag是否需要响应该总线事务。\n * 有限状态机（FSM）：判断缓存块的状态如何改变。后面分析缓存一致性协议的时候会讲到。\n * 写回缓存区（write back buffer）：所有需要写回的缓存块先保存到该缓存区中。\n\n对于不同的写传播方式，其一致性控制器的行为是不一样的，而且真实情况下，其控制器的构造也可能和上述图示如出一辙，但是其作用是类似的。（我们不是CPU设计者，不用太纠结）\n\n# 采用写通的缓存一致性协议\n提示\n\n现实中，该方案很少被使用，但是分析该案例有利于理解后面的各种协议。这里假设采用的是写不分配和写失效策略。\n\n该协议定义了缓存块具有两个状态：\n\n * Valid：该缓存块有效（该缓存块在整个存储系统中的所有副本的值都一致）。\n * Invalid：该缓存块无效，读取该缓存块时会导致缓存未命中。\n\n因此，该协议又简称为VI。在分析问题之前，先约定一些简称如下：\n\n处理器端：\n\n * PrRd：处理器端请求读一个缓存块。\n * PrWr：处理器端请求写一个缓存块。\n\n嗅探器端：\n\n * BusRd：监听其他核芯发起的读请求事件。\n * BusWr：监听其他核芯发起的写请求事件。\n\n注意，由于是写通，那么核芯私有缓存内的数据会被写到主存中。\n\n缓存块的状态转换过程如下图所示（处理器端的请求对应图中左半部分，嗅探器端对应右半部分）：\n\n\n\n处理器端：\n\n * 处理器读（同时产生总线读）会导致缓存块由无效状态转变为有效状态。这里的I状态表示了两种情况，一是缓存块不在缓存中，二是缓存块确实是无效状态。\n * 当缓存有效时，处理器写后仍然有效（同时也会更新缓存块），由于是写通，所以会导致总线写。\n * 当缓存无效时，如果缓存块不存在，由于是写不分配，所以写后还是无效状态。因为是写通和写不分配，所以不会在缓存中保存缓存块，所以最终还是保持无效记录。\n\n嗅探器端：\n\n * 如果缓存块有效，当监听到总线读（说明其他核芯在读）时，由于应该从主存中读取，所以一致性控制器不做任何操作，其状态仍然是有效。\n * 如果缓存块无效，不管监听到总线读还是总线写，一致性控制器都不做任何操作，所以器状态仍然是无效。\n * 如果缓存块有效，且监听到了总线写（说明其他核芯在写），那么一致性控制器将其状态更改为无效。当处理器再读时，发生缓存未命中，从而从主存中读取，又因为总线仲裁器不会允许同一缓存块的读写操作并行（不同块的读写操作可以并行），所以读取到的只能是最新的值（因为是先写后读），从而保证了缓存一致性。\n\nVI协议可以保证缓存一致性，虽然简单，但是占用总线带宽以及效率不高，在上述分析中处理器端的第三点讲到：缓存块无效时，都会产生总线写（占用大量总线带宽）；同时当下次读时，又会从主存中读（效率不高）。**究其原因，是因为采用了写通策略。**如果采用写回，就可以避免该问题，但是会引入更多的状态，使得整个协议变得复杂，所以如果采用了写回策略，那么VI协议就不再是VI协议了。如果采用写分配策略，那么在无效状态时，需要先读取，然后再多级写，导致时延大大增加，所以这种方法也不太好。\n\n关于采用写回策略的其他协议，在后序文章中进行分析。\n\n# 参考\n * Fundamentals of Parallel Multicore Architecture\n   \n   \n * 卡内基梅隆大学的课件\n   \n   \n * 伍斯特理工学院的课件\n   \n   \n * 犹他州立大学的课件",normalizedContent:"多核cpu真正实现了程序的并行，然而现实中很多常见的cpu拥有多级缓存架构，某些处理器架构（如intel skylake）中的缓存就分为三层，其中l1l1l1和l2l2l2为核芯独享，l3l3l3为所有核芯共享。虽然缓存大大提升了处理器的效率，但是当访问共享内存的多个线程在不同的核芯上执行时，可能会导致一个很严重的问题--缓存一致性。\n\n# 概述\n提示\n\ncpu核芯之间如何组织以及如何互联对设计缓存一致性协议有非常大的影响。本文目前仅对基于总线的架构进行讨论，例如其他点对点（point-to-point）的架构暂时不讨论。\n\n导致缓存一致性的原因是多个核芯的私有缓存中有同样的缓存块，而其中某个缓存块被修改了，但是其他的核芯对此毫无察觉（就算核芯采用写通策略，也无法让其他核芯感知），继续读取到其私有缓存中的脏数据。\n\n解决上述问题也就是实现缓存一致性需要保证两点：\n\n * 写传播：即让核芯感知到其他核芯内的数据修改。\n * 事务串行化：多个核芯同一段时间内对同一缓存块的修改的先后顺序在其他所有核芯看来是一致的。\n\n写传播有两种方式来实现，写失效和写更新：\n\n * 写失效（write invalidate）：在核芯准备更新缓存时，通知其他的核芯让其内部的该缓存块失效。当需要多次修改时，这种方法比较高效（后序修改不用再让其他缓存块失效）。\n * 写更新（write update）：在核芯准备更新缓存时，通知其他的核芯修改其内部对应的数据。当修改完后，其他核芯需要读数据时，该方法比较高效。\n\n如果是基于总线实现缓存一致性的话，那么天然支持事务串行化，因为多个设备要使用总线，首先要经过总线仲裁，由仲裁器来决定使用的先后顺序。注意，总线不一定是同步的，即不一定是先读完某个缓存块后再写某个缓存块，有可能是在发起读取请求后，就开始写操作了，这样的总线称作为异步总线。异步总线相比同步总线的优点是吞吐量大，效率高。\n\n# 总线嗅探\n基于总线的缓存一致性重点是如何实现写传播，本文来分析广播/嗅探（broadcast/snoop）机制。\n\n提示\n\n广播/嗅探机制是实现写传播的方式中的一种，除此之外，还有目录（directory）机制。前者的优点是实现简单，缺点是可扩展性差。后者的优点是可扩展性高，缺点是需要额外的存储空间。\n\n注意\n\n在具体讨论该机制前，首先说明一下：上面也说到了，三级缓存中l1l1l1和l2l2l2都是核芯私有的，而l3l3l3是多个核芯共享的。下述讨论中，把l1l1l1和l2l2l2看成一级缓存，同时把l3l3l3看作是主存。至于l3如何把数据同步到真实的主存中暂时不讨论。\n\n由于cpu的架构“千奇百怪”，不可能把所有的情况都讨论完，本文只讨论一些常见的，然后在写程序时心里有底就行了。\n\n连接缓存总线的各方都有一个一致性控制器，其示意图如下：\n\n\n\n * 事务表（outstanding transaction table）：保存由当前核芯发起的未完成的总线事务表。\n * 总线嗅探器（snooper）：监听总线上的事务。当其接收到信号时，控制器检测缓存内的tag是否需要响应该总线事务。\n * 有限状态机（fsm）：判断缓存块的状态如何改变。后面分析缓存一致性协议的时候会讲到。\n * 写回缓存区（write back buffer）：所有需要写回的缓存块先保存到该缓存区中。\n\n对于不同的写传播方式，其一致性控制器的行为是不一样的，而且真实情况下，其控制器的构造也可能和上述图示如出一辙，但是其作用是类似的。（我们不是cpu设计者，不用太纠结）\n\n# 采用写通的缓存一致性协议\n提示\n\n现实中，该方案很少被使用，但是分析该案例有利于理解后面的各种协议。这里假设采用的是写不分配和写失效策略。\n\n该协议定义了缓存块具有两个状态：\n\n * valid：该缓存块有效（该缓存块在整个存储系统中的所有副本的值都一致）。\n * invalid：该缓存块无效，读取该缓存块时会导致缓存未命中。\n\n因此，该协议又简称为vi。在分析问题之前，先约定一些简称如下：\n\n处理器端：\n\n * prrd：处理器端请求读一个缓存块。\n * prwr：处理器端请求写一个缓存块。\n\n嗅探器端：\n\n * busrd：监听其他核芯发起的读请求事件。\n * buswr：监听其他核芯发起的写请求事件。\n\n注意，由于是写通，那么核芯私有缓存内的数据会被写到主存中。\n\n缓存块的状态转换过程如下图所示（处理器端的请求对应图中左半部分，嗅探器端对应右半部分）：\n\n\n\n处理器端：\n\n * 处理器读（同时产生总线读）会导致缓存块由无效状态转变为有效状态。这里的i状态表示了两种情况，一是缓存块不在缓存中，二是缓存块确实是无效状态。\n * 当缓存有效时，处理器写后仍然有效（同时也会更新缓存块），由于是写通，所以会导致总线写。\n * 当缓存无效时，如果缓存块不存在，由于是写不分配，所以写后还是无效状态。因为是写通和写不分配，所以不会在缓存中保存缓存块，所以最终还是保持无效记录。\n\n嗅探器端：\n\n * 如果缓存块有效，当监听到总线读（说明其他核芯在读）时，由于应该从主存中读取，所以一致性控制器不做任何操作，其状态仍然是有效。\n * 如果缓存块无效，不管监听到总线读还是总线写，一致性控制器都不做任何操作，所以器状态仍然是无效。\n * 如果缓存块有效，且监听到了总线写（说明其他核芯在写），那么一致性控制器将其状态更改为无效。当处理器再读时，发生缓存未命中，从而从主存中读取，又因为总线仲裁器不会允许同一缓存块的读写操作并行（不同块的读写操作可以并行），所以读取到的只能是最新的值（因为是先写后读），从而保证了缓存一致性。\n\nvi协议可以保证缓存一致性，虽然简单，但是占用总线带宽以及效率不高，在上述分析中处理器端的第三点讲到：缓存块无效时，都会产生总线写（占用大量总线带宽）；同时当下次读时，又会从主存中读（效率不高）。**究其原因，是因为采用了写通策略。**如果采用写回，就可以避免该问题，但是会引入更多的状态，使得整个协议变得复杂，所以如果采用了写回策略，那么vi协议就不再是vi协议了。如果采用写分配策略，那么在无效状态时，需要先读取，然后再多级写，导致时延大大增加，所以这种方法也不太好。\n\n关于采用写回策略的其他协议，在后序文章中进行分析。\n\n# 参考\n * fundamentals of parallel multicore architecture\n   \n   \n * 卡内基梅隆大学的课件\n   \n   \n * 伍斯特理工学院的课件\n   \n   \n * 犹他州立大学的课件",charsets:{cjk:!0}},{title:"CPU缓存一致性协议之MSI",frontmatter:{title:"CPU缓存一致性协议之MSI",categories:["计算机体系结构"],tags:["Cache"],date:"2020-12-20T11:59:28.000Z",permalink:"/pages/35e881/"},regularPath:"/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/01.%E7%BC%93%E5%AD%98/03.CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%E4%B9%8BMSI.html",relativePath:"03.计算机体系结构/01.缓存/03.CPU缓存一致性协议之MSI.md",key:"v-b2e55526",path:"/pages/35e881/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:155},{level:2,title:"缓存块的状态转换",slug:"缓存块的状态转换",normalizedTitle:"缓存块的状态转换",charIndex:490},{level:3,title:"处理器端引起的状态转换",slug:"处理器端引起的状态转换",normalizedTitle:"处理器端引起的状态转换",charIndex:543},{level:3,title:"嗅探器端引起的状态转换",slug:"嗅探器端引起的状态转换",normalizedTitle:"嗅探器端引起的状态转换",charIndex:870},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1492},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1755}],excerpt:'<p>在<a href="https://harrisonlee.net/pages/856225/" target="_blank" rel="noopener noreferrer">上一篇文章<OutboundLink/></a>中，讨论了缓存一致性的概念以及VI协议，本文讨论的MSI协议可以很好地解决VI协议需要高总线带宽，效率不高的缺点。而且导致VI协议有这样缺点的原因是因为其采用了写通策略，所以本文讨论的MSI协议采用写回策略。</p>\n',lastUpdated:"2021-01-19",headersStr:"概述 缓存块的状态转换 处理器端引起的状态转换 嗅探器端引起的状态转换 总结 参考",content:"在上一篇文章中，讨论了缓存一致性的概念以及VI协议，本文讨论的MSI协议可以很好地解决VI协议需要高总线带宽，效率不高的缺点。而且导致VI协议有这样缺点的原因是因为其采用了写通策略，所以本文讨论的MSI协议采用写回策略。\n\n注意\n\n同样地，本文的讨论也是基于总线架构的嗅探机制，采用写分配和写失效策略。\n\n# 概述\n首先，MSI协议中定义缓存块有三种状态：\n\n * 已修改（Modified）：该缓存块仅在一个核芯内有效，且被修改过，其值可能不同于主存中的值，可以被读和写。\n * 共享（Shared）：该缓存块有效，可能只被一个核芯所独享，也可能被多个核芯所共享（在此协议中不进行区分），可以被读，但是不能被写。\n * 无效（Invalid）：该缓存块无效，不可以被读和写。\n\n为了便于下面讨论，现规定一些操作及其术语：\n\n处理器端的请求：\n\n * PrRd：处理器端的读。\n * PrWr：处理器端的写。\n\n总线端的事务（嗅探器所要监听的事务）：\n\n * BusRd：总线读事务。\n * BusRdX：总线排他读事务。\n * Flush：总线刷新事务，将数据写入主存。\n\n# 缓存块的状态转换\nMSI协议的有限状态机如下图所示（左半部分是处理器端，右半部分是嗅探器端）：\n\n\n\n# 处理器端引起的状态转换\n当缓存块的状态为无效时（可能是该缓存块不存在或该缓存块存在且其状态为无效）：\n\n * 当处理器读时，同时会产生总线读，然后将其状态设置为Shared。\n * 当处理器写时，先产生一个总线排他读事务，读取到最新数据，然后处理器进行写操作，最后其状态为Modified。\n\n当缓存块的的状态为共享时：\n\n * 处理器读，缓存命中，所以不会产生总线读事务，状态不变。\n * 处理器写时，先进行总线排他读，让其他副本失效，然后再写，最后其状态为Modified。\n\n当缓存块的状态为已修改时：\n\n * 处理器的读/写请求均不会导致总线事务，也不会导致其状态改变（因为所有缓存中仅有当前一份副本，所以无论怎么修改，都不会改变状态）。\n\n# 嗅探器端引起的状态转换\n当缓存块的状态为无效时：\n\n * 当嗅探器监听到关于此缓存块的总线读或总线排他读时，一致性控制器不做任何操作。\n\n当缓存块的状态为共享态时：\n\n * 当嗅探器监听到总线读时，说明其他核芯发生缓存未命中，由于是主存提供数据，所以一致性控制器不做任何操作。\n * 当嗅探器监听到总线排他读时，说明其他核芯准备写，一致性控制器将其内部对应的缓存块置为无效。\n\n当缓存块的状态为已修改时：\n\n * 当嗅探器监听到总线读时，此时一致性控制器必须将已修改的数据刷新回主存，否则其他核芯会读取到脏数据，最后的状态为Shared。主存会在所有一致性控制器响应后再完成请求，所以主存先接收到刷新请求，然后再响应，所以确保了读取到的数据是最新的。\n * 当嗅探器监听到排他读时，此时一致性控制器必须将已修改的数据刷新回主存，并将对应的缓存块置为无效。这里刷新看似多余，因为其他核芯进行的是写操作，就算读到了最新的数据，但是立马又被覆盖了。（这的确是一个容易被忽略的点）其实不然，比如核芯1修改了缓存块A的第1个字和第3个字的数据，而核芯2也要修改第1个字的数据，但是修改完后要读取第3个字的数据，如果写之前读取不到最新的数据，那么会导致读取到的第3个字为脏数据。\n\n笔记\n\n当发起排他读请求的核芯监听到刷新请求时，可以将其读取到自己所属的缓存中，就不用等主存响应了，从而提升了效率。同时，主存仍然要监听刷新请求，以更新主存中的数据。\n\n# 总结\n可以发现，状态的转换一定会通过总线事务，而总线事务不一定会导致状态的转换。写失效是通过总线排他读实现的，当嗅探器监听到该事务，使其内部的缓存块失效（状态为共享时）或者是刷新（状态为已更新时）。\n\nMSI协议采用了写回而不是写通，所以降低了总线带宽的负荷。但是会导致发起更多的总线事务，比如修改状态为共享的缓存块，无论其他缓存中是否有该缓存块，都要发起总线排他读让其他副本失效，如果其他缓存中都没有该缓存块，那么该请求就是多余的。所以，MSI中shared状态还可以进一步分解，具体细节请看下回关于MESI的分析。\n\n# 参考\n * Fundamentals of Parallel Multicore Architecture",normalizedContent:"在上一篇文章中，讨论了缓存一致性的概念以及vi协议，本文讨论的msi协议可以很好地解决vi协议需要高总线带宽，效率不高的缺点。而且导致vi协议有这样缺点的原因是因为其采用了写通策略，所以本文讨论的msi协议采用写回策略。\n\n注意\n\n同样地，本文的讨论也是基于总线架构的嗅探机制，采用写分配和写失效策略。\n\n# 概述\n首先，msi协议中定义缓存块有三种状态：\n\n * 已修改（modified）：该缓存块仅在一个核芯内有效，且被修改过，其值可能不同于主存中的值，可以被读和写。\n * 共享（shared）：该缓存块有效，可能只被一个核芯所独享，也可能被多个核芯所共享（在此协议中不进行区分），可以被读，但是不能被写。\n * 无效（invalid）：该缓存块无效，不可以被读和写。\n\n为了便于下面讨论，现规定一些操作及其术语：\n\n处理器端的请求：\n\n * prrd：处理器端的读。\n * prwr：处理器端的写。\n\n总线端的事务（嗅探器所要监听的事务）：\n\n * busrd：总线读事务。\n * busrdx：总线排他读事务。\n * flush：总线刷新事务，将数据写入主存。\n\n# 缓存块的状态转换\nmsi协议的有限状态机如下图所示（左半部分是处理器端，右半部分是嗅探器端）：\n\n\n\n# 处理器端引起的状态转换\n当缓存块的状态为无效时（可能是该缓存块不存在或该缓存块存在且其状态为无效）：\n\n * 当处理器读时，同时会产生总线读，然后将其状态设置为shared。\n * 当处理器写时，先产生一个总线排他读事务，读取到最新数据，然后处理器进行写操作，最后其状态为modified。\n\n当缓存块的的状态为共享时：\n\n * 处理器读，缓存命中，所以不会产生总线读事务，状态不变。\n * 处理器写时，先进行总线排他读，让其他副本失效，然后再写，最后其状态为modified。\n\n当缓存块的状态为已修改时：\n\n * 处理器的读/写请求均不会导致总线事务，也不会导致其状态改变（因为所有缓存中仅有当前一份副本，所以无论怎么修改，都不会改变状态）。\n\n# 嗅探器端引起的状态转换\n当缓存块的状态为无效时：\n\n * 当嗅探器监听到关于此缓存块的总线读或总线排他读时，一致性控制器不做任何操作。\n\n当缓存块的状态为共享态时：\n\n * 当嗅探器监听到总线读时，说明其他核芯发生缓存未命中，由于是主存提供数据，所以一致性控制器不做任何操作。\n * 当嗅探器监听到总线排他读时，说明其他核芯准备写，一致性控制器将其内部对应的缓存块置为无效。\n\n当缓存块的状态为已修改时：\n\n * 当嗅探器监听到总线读时，此时一致性控制器必须将已修改的数据刷新回主存，否则其他核芯会读取到脏数据，最后的状态为shared。主存会在所有一致性控制器响应后再完成请求，所以主存先接收到刷新请求，然后再响应，所以确保了读取到的数据是最新的。\n * 当嗅探器监听到排他读时，此时一致性控制器必须将已修改的数据刷新回主存，并将对应的缓存块置为无效。这里刷新看似多余，因为其他核芯进行的是写操作，就算读到了最新的数据，但是立马又被覆盖了。（这的确是一个容易被忽略的点）其实不然，比如核芯1修改了缓存块a的第1个字和第3个字的数据，而核芯2也要修改第1个字的数据，但是修改完后要读取第3个字的数据，如果写之前读取不到最新的数据，那么会导致读取到的第3个字为脏数据。\n\n笔记\n\n当发起排他读请求的核芯监听到刷新请求时，可以将其读取到自己所属的缓存中，就不用等主存响应了，从而提升了效率。同时，主存仍然要监听刷新请求，以更新主存中的数据。\n\n# 总结\n可以发现，状态的转换一定会通过总线事务，而总线事务不一定会导致状态的转换。写失效是通过总线排他读实现的，当嗅探器监听到该事务，使其内部的缓存块失效（状态为共享时）或者是刷新（状态为已更新时）。\n\nmsi协议采用了写回而不是写通，所以降低了总线带宽的负荷。但是会导致发起更多的总线事务，比如修改状态为共享的缓存块，无论其他缓存中是否有该缓存块，都要发起总线排他读让其他副本失效，如果其他缓存中都没有该缓存块，那么该请求就是多余的。所以，msi中shared状态还可以进一步分解，具体细节请看下回关于mesi的分析。\n\n# 参考\n * fundamentals of parallel multicore architecture",charsets:{cjk:!0}},{title:"CPU缓存一致性协议之MESI",frontmatter:{title:"CPU缓存一致性协议之MESI",categories:["计算机体系结构"],tags:["Cache"],date:"2021-01-06T11:28:05.000Z",permalink:"/pages/5709ee/"},regularPath:"/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/01.%E7%BC%93%E5%AD%98/04.CPU%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E5%8D%8F%E8%AE%AE%E4%B9%8BMESI.html",relativePath:"03.计算机体系结构/01.缓存/04.CPU缓存一致性协议之MESI.md",key:"v-66d7ae3e",path:"/pages/5709ee/",headers:[{level:2,title:"MESI协议定义的状态",slug:"mesi协议定义的状态",normalizedTitle:"mesi协议定义的状态",charIndex:219},{level:2,title:"MESI协议消息",slug:"mesi协议消息",normalizedTitle:"mesi协议消息",charIndex:480},{level:2,title:"MESI状态转换",slug:"mesi状态转换",normalizedTitle:"mesi状态转换",charIndex:944},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2437}],excerpt:'<p>在之前的<a href="https://harrisonlee.net/pages/35e881/" target="_blank" rel="noopener noreferrer">这篇文章<OutboundLink/></a>中，探讨了MSI协议，在文末提到了MSI协议效率不高的问题，原因是因为不严格区分缓存块在多个私有缓存中共享和独享的情况，导致在实际独享的情况下修改缓存，也发出让其他缓存失效缓存的信号。</p>\n<p>本文探讨的MESI协议就引入了独享状态，从而可以解决上述问题。</p>\n',lastUpdated:"2021-01-19",headersStr:"MESI协议定义的状态 MESI协议消息 MESI状态转换 参考",content:'在之前的这篇文章中，探讨了MSI协议，在文末提到了MSI协议效率不高的问题，原因是因为不严格区分缓存块在多个私有缓存中共享和独享的情况，导致在实际独享的情况下修改缓存，也发出让其他缓存失效缓存的信号。\n\n本文探讨的MESI协议就引入了独享状态，从而可以解决上述问题。\n\n提示\n\n本文翻译自Memory Barriers: a Hardware View for Software Hackers一文的部分章节，同时相对原文有删改。\n\n# MESI协议定义的状态\nMESI分别是四个状态的首字母：\n\n * Modified：表示缓存块最近被修改过，与内存中的数据不一致，同时在所有私有缓存中只有一份数据。\n * Exclusive：与Modified状态类似，唯一区别在于该缓存块没有被修改过，所以与内存中的数据一致。当CPU要修改该状态的缓存块时，不用与其他CPU协商。\n * Shared：表示至少在其他CPU中存在一份副本，所以当CPU修改该状态的缓存块时，需要先通知其他CPU。\n * Invalid：表示该缓存块无效，当读取时，发生缓存未命中。\n\n# MESI协议消息\n因为一个CPU内缓存块状态的变换需要通知其他的CPU，所以MESI定义了下面几种消息类型：\n\n * Read：该消息包含了所有读取的缓存块的物理地址，表示CPU读取某个缓存块。\n * Read Message：该消息表示对Read消息的响应，该响应可能来自主存，也有可能来自其他CPU。如果其他CPU存在缓存的有效副本，那么该消息一般是来自其他的CPU的。\n * Invalidate：该消息包含了所要失效的缓存块的物理地址，所有其他的CPU比如失效该地址所表示的缓存块。\n * Invalidate Acknowledge：该消息表示CPU接收到"invalidate"消息后的响应消息。\n * Read Invalidate：该消息是"Read"和"Invalidate"的组合，其他CPU必须让其私有缓存中的对应缓存块失效，该消息必须接收到"Read Response"和"Invalidate Acknowledge"消息作为响应。\n * Writeback：该消息表示缓存内的数据写回到主存。\n\n# MESI状态转换\nMESI状态转换如下图所示：\n\n\n\n * Transition a：缓存行被写回主存，但是CPU仍然保留该缓存。该转换产生一个Writeback消息。\n * Transition b：CPU修改缓存行，由于CPU独享该缓存行，所以不会产生任何的消息。\n * Transition c：CPU接收到关于已修改缓存块的Read Invalidate消息，那么CPU必须将本地相应的缓存块失效，同时发送一个Read Response消息和一个Invalidate Acknowledge消息。\n * Transition d：CPU执行修改操作，但是本地缓存中没有所要读取的数据，所以CPU发起Read消息，然后通过Read Response响应获取数据，注意CPU在接收到Invalidate Response后方能完成状态转换。\n * Transition e：CPU执行修改操作，但是相应的本地缓存被共享，所以CPU必须发出Invalidate，然后再等待Invalidate Acknowledge消息才能够完成状态转换。\n * Transition f：其他CPU读取了当前CPU本地缓存中状态为已修改的缓存块，其他CPU发出Read消息，当前CPU接收到后响应Read Response消息，并提供对应的缓存块（该缓存块可能被写回主存）。\n * Transition g：其他CPU发出Read消息，当前CPU响应Read Response消息，并提供对应的缓存块。\n * Transition h：当前CPU意识到接下来会修改某些共享的缓存块，所以发送Invalidate消息，**注意CPU必须在接收到Invalidation Response消息后方能完成状态转换。\n * Transition i：其他CPU执行修改操作，发出Read Invalidate消息，当前CPU将本地缓存中的相应数据失效，同时响应Read Response和Invalidate Acknowledge消息。\n * Transition j：当前CPU后面可能需要执行修改操作，所以先获取到独占权，但是本地缓存中没有有效数据，所以发出Read Invalidate消息，直到接收到Read Response相应消息后方能完成状态转换。\n * Transition k：当前CPU读取本地缓存中没有的缓存块，发出Read消息，接收到Read Response响应消息从而获取到数据。\n * Transition l：其他CPU发出Invalidate或Read Invalidate消息，当前CPU必须将本地对应的共享缓存置为无效，同时返回Invalidate Acknowledge消息。\n\nMESI协议引入Exclusive状态后，相比MSI协议提高了效率。因为修改Exclusive状态的缓存块不会发送任何消息（对应图中状态转化b），在MSI中修改的话对应图中状态转换e。\n\n虽然MESI协议相比MSI协议效率更高，但是很多状态转换必须接收到响应消息后才能完成，比如CPU0修改CPU1中存在的数据，那么必须等到CPU1发出的Invalidate Acknowledge消息才能完成，但是CPU0没必要等待这么久，因为是否接收到响应也不会影响CPU0所修改的值，只要CPU1将自己的本地缓存中对应的缓存块置为无效就可以保证一致性。\n\n所以硬件工程师们为了进一步提高CPU的效率，又设计出了其他的优化方案，后面再写文介绍。\n\n有一个MESI协议如何工作的可视化网页。\n\n# 参考\nMemory Barriers: a Hardware View for Software Hackers',normalizedContent:'在之前的这篇文章中，探讨了msi协议，在文末提到了msi协议效率不高的问题，原因是因为不严格区分缓存块在多个私有缓存中共享和独享的情况，导致在实际独享的情况下修改缓存，也发出让其他缓存失效缓存的信号。\n\n本文探讨的mesi协议就引入了独享状态，从而可以解决上述问题。\n\n提示\n\n本文翻译自memory barriers: a hardware view for software hackers一文的部分章节，同时相对原文有删改。\n\n# mesi协议定义的状态\nmesi分别是四个状态的首字母：\n\n * modified：表示缓存块最近被修改过，与内存中的数据不一致，同时在所有私有缓存中只有一份数据。\n * exclusive：与modified状态类似，唯一区别在于该缓存块没有被修改过，所以与内存中的数据一致。当cpu要修改该状态的缓存块时，不用与其他cpu协商。\n * shared：表示至少在其他cpu中存在一份副本，所以当cpu修改该状态的缓存块时，需要先通知其他cpu。\n * invalid：表示该缓存块无效，当读取时，发生缓存未命中。\n\n# mesi协议消息\n因为一个cpu内缓存块状态的变换需要通知其他的cpu，所以mesi定义了下面几种消息类型：\n\n * read：该消息包含了所有读取的缓存块的物理地址，表示cpu读取某个缓存块。\n * read message：该消息表示对read消息的响应，该响应可能来自主存，也有可能来自其他cpu。如果其他cpu存在缓存的有效副本，那么该消息一般是来自其他的cpu的。\n * invalidate：该消息包含了所要失效的缓存块的物理地址，所有其他的cpu比如失效该地址所表示的缓存块。\n * invalidate acknowledge：该消息表示cpu接收到"invalidate"消息后的响应消息。\n * read invalidate：该消息是"read"和"invalidate"的组合，其他cpu必须让其私有缓存中的对应缓存块失效，该消息必须接收到"read response"和"invalidate acknowledge"消息作为响应。\n * writeback：该消息表示缓存内的数据写回到主存。\n\n# mesi状态转换\nmesi状态转换如下图所示：\n\n\n\n * transition a：缓存行被写回主存，但是cpu仍然保留该缓存。该转换产生一个writeback消息。\n * transition b：cpu修改缓存行，由于cpu独享该缓存行，所以不会产生任何的消息。\n * transition c：cpu接收到关于已修改缓存块的read invalidate消息，那么cpu必须将本地相应的缓存块失效，同时发送一个read response消息和一个invalidate acknowledge消息。\n * transition d：cpu执行修改操作，但是本地缓存中没有所要读取的数据，所以cpu发起read消息，然后通过read response响应获取数据，注意cpu在接收到invalidate response后方能完成状态转换。\n * transition e：cpu执行修改操作，但是相应的本地缓存被共享，所以cpu必须发出invalidate，然后再等待invalidate acknowledge消息才能够完成状态转换。\n * transition f：其他cpu读取了当前cpu本地缓存中状态为已修改的缓存块，其他cpu发出read消息，当前cpu接收到后响应read response消息，并提供对应的缓存块（该缓存块可能被写回主存）。\n * transition g：其他cpu发出read消息，当前cpu响应read response消息，并提供对应的缓存块。\n * transition h：当前cpu意识到接下来会修改某些共享的缓存块，所以发送invalidate消息，**注意cpu必须在接收到invalidation response消息后方能完成状态转换。\n * transition i：其他cpu执行修改操作，发出read invalidate消息，当前cpu将本地缓存中的相应数据失效，同时响应read response和invalidate acknowledge消息。\n * transition j：当前cpu后面可能需要执行修改操作，所以先获取到独占权，但是本地缓存中没有有效数据，所以发出read invalidate消息，直到接收到read response相应消息后方能完成状态转换。\n * transition k：当前cpu读取本地缓存中没有的缓存块，发出read消息，接收到read response响应消息从而获取到数据。\n * transition l：其他cpu发出invalidate或read invalidate消息，当前cpu必须将本地对应的共享缓存置为无效，同时返回invalidate acknowledge消息。\n\nmesi协议引入exclusive状态后，相比msi协议提高了效率。因为修改exclusive状态的缓存块不会发送任何消息（对应图中状态转化b），在msi中修改的话对应图中状态转换e。\n\n虽然mesi协议相比msi协议效率更高，但是很多状态转换必须接收到响应消息后才能完成，比如cpu0修改cpu1中存在的数据，那么必须等到cpu1发出的invalidate acknowledge消息才能完成，但是cpu0没必要等待这么久，因为是否接收到响应也不会影响cpu0所修改的值，只要cpu1将自己的本地缓存中对应的缓存块置为无效就可以保证一致性。\n\n所以硬件工程师们为了进一步提高cpu的效率，又设计出了其他的优化方案，后面再写文介绍。\n\n有一个mesi协议如何工作的可视化网页。\n\n# 参考\nmemory barriers: a hardware view for software hackers',charsets:{cjk:!0}},{title:"CPU中的Store Buffers",frontmatter:{title:"CPU中的Store Buffers",categories:["计算机体系结构"],tags:["Cache"],date:"2021-01-18T16:22:42.000Z",permalink:"/pages/b770ae/"},regularPath:"/03.%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/01.%E7%BC%93%E5%AD%98/05.CPU%E4%B8%AD%E7%9A%84StoreBuffers.html",relativePath:"03.计算机体系结构/01.缓存/05.CPU中的StoreBuffers.md",key:"v-0f156278",path:"/pages/b770ae/",headers:[{level:2,title:"Store Buffers",slug:"store-buffers",normalizedTitle:"store buffers",charIndex:181},{level:2,title:"内存屏障",slug:"内存屏障",normalizedTitle:"内存屏障",charIndex:1500},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:3257}],excerpt:'<p>在之前的那篇关于MESI的<a href="https://harrisonlee.net/pages/5709ee/" target="_blank" rel="noopener noreferrer">博客<OutboundLink/></a>中，我们讲到了MESI协议在MSI协议的基础上新加入了一个状态E，能够提高维护缓存一致性的效率。但是硬件工程师们发现在MESI协议中，比如某个CPU要修改一个当前缓存中不存在的变量，那么需要发出&quot;read invalidate&quot;消息，待收到其他CPU的确认消息后才能进行修改操作。这显然是不必要的等待，所以为了解决这个问题，又引入了Store Buffers。</p>\n',lastUpdated:"2021-01-19",headersStr:"Store Buffers 内存屏障 总结",content:'在之前的那篇关于MESI的博客中，我们讲到了MESI协议在MSI协议的基础上新加入了一个状态E，能够提高维护缓存一致性的效率。但是硬件工程师们发现在MESI协议中，比如某个CPU要修改一个当前缓存中不存在的变量，那么需要发出"read invalidate"消息，待收到其他CPU的确认消息后才能进行修改操作。这显然是不必要的等待，所以为了解决这个问题，又引入了Store Buffers。\n\n提示\n\n本文翻译自Memory Barriers: a Hardware View for Software Hackers一文的部分章节，同时相对原文有删改。\n\n# Store Buffers\n引入Store Buffers后，CPU中的结构大体如下图所示：\n\n\n\n但是引入Store Buffers后，会导致破坏全局内存顺序，下面以一个例子来说明问题。\n\n对于下来代码：\n\nvoid foo(void)\n{\n    a = 1;\n    b = 1;\n}\n\nvoid bar(void)\n{\n    while(b == 0) continue;\n    assert(a == 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n假设CPU 0执行foo()，CPU 1执行bar()，而且一开始变量a只存在CPU 1的缓存中，变量b只存在于CPU 0的缓存中。整个执行流程可能如下所述：\n\n 1. CPU 0 执行a = 1;，变量a所在的缓存行并不在CPU 0的缓存中，所以CPU 0将赋予变量a的值放入Store Buffers中，并发出“read invalidate”消息。\n 2. CPU 1执行while(b == 0) continue;，但是变量b所在的缓存行并不在CPU 1中的缓存中，所以CPU 1发出“read”消息。\n 3. CPU 0执行b = 1;，它已经拥有包含变量b的缓存行了（M或E状态），所以直接将变量b的新值写入缓存行中。\n 4. CPU 0接收到“read”消息后（第2步CPU 1发出的），CPU 0响应该消息，并把变量b所在缓存行的状态改为S。\n 5. CPU 1接收到包含b的缓存行，并放入自己的缓存中。\n 6. CPU 1现在可以结束执行while(b == 0) continue;，因为它发现变量b的值为1了，不满足循环条件。\n 7. CPU 1执行assert(a == 1)，因为CPU 1保存有变量a所在的缓存行，但是变量a的值是脏数据，所以断言失败。\n 8. CPU 1接收到“read invalidate”消息（第1步CPU 0发出的），并且把包含变量a的值传给CPU 0，并且CPU 1将自己缓存中的该缓存行标记为无效（I）。但是这太迟了。\n 9. CPU 0接收到包含变量a的缓存行，并放置在自己的缓存中，并把Store Buffers中a的值写入缓存行中。\n\n提示\n\n上面9步流程及其相对顺序符合原文，但是个人认为把第1步和第2步调换了顺序更好理解一些。即CPU 1先发出“read”消息，而CPU 0后发出“read invalidate”消息，即CPU 1先获得总线使用权。\n\n可以看出，整个执行流程就像是把foo()中两条语句调换了顺序一样。如果按照原顺序执行的话，是不可能导致断言失败的，因为a = 1;早于b = 1;执行，那么while(b == 0) continue;结束时，变量a的值已经是1了。这算是由于引入Store Buffers而导致的指令重排序问题，而这种重排序会导致可见性问题。\n\n# 内存屏障\n对于上述问题，硬件工程师们无法提出自动维护一致性的解决方案，因为CPU无法知道哪些变量之间存在关联关系，更不必说是如何关联的。因此硬件工程师引入了内存屏障，软件工程师可以用内存屏障指令告诉CPU这种关联关系。\n\n仍然对于上述代码，只需要做如下修改，即可解决问题。\n\nvoid foo(void)\n{\n    a = 1;\n    smp_mb();\n    b = 1;\n}\n\nvoid bar(void)\n{\n    while(b == 0) continue;\n    assert(a == 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n内存屏障smp_mb();会导致CPU在之后的存储操作之前必须刷新它的Store Buffers。CPU要么暂停直到Store Buffers被清空，要么把后序的存储操作涉及的数据也存储到Store Buffers中，直到先存入Store Buffers的项被处理。\n\n对于后一种方法，可能的执行序列如下所述：\n\n 1.  CPU 0执行a = 1;，包含变量a的缓存行不在CPU 0的缓存行中，因此CPU 0将变量a的新值放入Store Buffers中，并发出“read invalidate”消息。\n 2.  CPU 1执行while(b == 0) continue;，但是包含变量b的缓存行不在CPU 1的缓存中，所以发出“read”消息。\n 3.  CPU 0执行smp_mb();，并标记当前Store Buffers中所有的项。\n 4.  CPU 0执行b = 1;，CPU 0已经拥有包含变量b的缓存行了（M或E状态），但是在Store Buffers中有标记项，因此并不会直接把变量b的新值写入到缓存行中，而是将它放入Store Buffers中（但是不标记）。\n 5.  CPU 0接收到“read”消息后（上面第2步CPU 1发出的），CPU 0将包含b的缓存行（包含旧值）传给CPU 1，并将缓存行状态设置为S。\n 6.  CPU 1接收到关于b的缓存行并放置在自己的缓存中。\n 7.  CPU 1现在可以加载变量b了，但是它发现变量b的值仍然是0（CPU 0传过来的旧值），所以继续循环。因为变量b的新值还放在Store Buffers中的。\n 8.  CPU 1接收到“read invalidate”消息（上面第1步）后，将包含变量a的缓存行传给CPU 0并将其设置为无效态（I）。\n 9.  CPU 0接收到包含变量a的缓存行后，并将Store Buffers中变量a的新值写入该缓存行。\n 10. 因为Store Buffers中的变量被标记了（上面第3步），由于当前例子中变量a是Store Buffers是唯一被标记的项，所以CPU 0也可以选择把变量b的新值写入缓存行中。\n 11. 因为目前变量b所在缓存行的状态为S，所以CPU 0发出“invalidate”消息给CPU 1（因为上面第10步）。\n 12. CPU 1接收到“invalidate”消息后，将包含变量b的缓存行失效，并向CPU 0发送确认消息。\n 13. CPU 1执行while(b == 0) continue;，但是包含变量b的缓存行不在其缓存内，所以发出“read”信息。\n 14. CPU 0接收到确认消息后（上面第12步），将包含变量b的缓存行的状态设置为E，CPU 0将变量b的新值写入缓存行中。\n 15. CPU 0接收到“read”消息，将包含变量b的缓存行传给CPU 1，并将其状态设置为S。\n 16. CPU 1接收到包含变量b的缓存行并放置在缓存中。\n 17. CPU 1现在加载变量b的值，发现b的值为1，所以退出while循环。\n 18. CPU 1执行assert(a == 1);，但是包含变量a的缓存行不在缓存中（因为上面第8步），所以从CPU 0中请求数据，此时将会得到变量a的最新值，并且断言成功。\n\n正如你所看见的，整个步骤比之前多了很多。仔细回顾上面的过程，就可以发现是通过将变量b的值也写入Store Buffers中而不是直接写回到缓存行中而避免了类似指令的重排序的。\n\n# 总结\n为了提高MESI协议的效率，所以引入了Store Buffers，但是这会导致类似指令重排序的效果，为了解决这个带来的新问题，所以又引入内存屏障。关于内存屏障，后面写文再详细分析。',normalizedContent:'在之前的那篇关于mesi的博客中，我们讲到了mesi协议在msi协议的基础上新加入了一个状态e，能够提高维护缓存一致性的效率。但是硬件工程师们发现在mesi协议中，比如某个cpu要修改一个当前缓存中不存在的变量，那么需要发出"read invalidate"消息，待收到其他cpu的确认消息后才能进行修改操作。这显然是不必要的等待，所以为了解决这个问题，又引入了store buffers。\n\n提示\n\n本文翻译自memory barriers: a hardware view for software hackers一文的部分章节，同时相对原文有删改。\n\n# store buffers\n引入store buffers后，cpu中的结构大体如下图所示：\n\n\n\n但是引入store buffers后，会导致破坏全局内存顺序，下面以一个例子来说明问题。\n\n对于下来代码：\n\nvoid foo(void)\n{\n    a = 1;\n    b = 1;\n}\n\nvoid bar(void)\n{\n    while(b == 0) continue;\n    assert(a == 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n假设cpu 0执行foo()，cpu 1执行bar()，而且一开始变量a只存在cpu 1的缓存中，变量b只存在于cpu 0的缓存中。整个执行流程可能如下所述：\n\n 1. cpu 0 执行a = 1;，变量a所在的缓存行并不在cpu 0的缓存中，所以cpu 0将赋予变量a的值放入store buffers中，并发出“read invalidate”消息。\n 2. cpu 1执行while(b == 0) continue;，但是变量b所在的缓存行并不在cpu 1中的缓存中，所以cpu 1发出“read”消息。\n 3. cpu 0执行b = 1;，它已经拥有包含变量b的缓存行了（m或e状态），所以直接将变量b的新值写入缓存行中。\n 4. cpu 0接收到“read”消息后（第2步cpu 1发出的），cpu 0响应该消息，并把变量b所在缓存行的状态改为s。\n 5. cpu 1接收到包含b的缓存行，并放入自己的缓存中。\n 6. cpu 1现在可以结束执行while(b == 0) continue;，因为它发现变量b的值为1了，不满足循环条件。\n 7. cpu 1执行assert(a == 1)，因为cpu 1保存有变量a所在的缓存行，但是变量a的值是脏数据，所以断言失败。\n 8. cpu 1接收到“read invalidate”消息（第1步cpu 0发出的），并且把包含变量a的值传给cpu 0，并且cpu 1将自己缓存中的该缓存行标记为无效（i）。但是这太迟了。\n 9. cpu 0接收到包含变量a的缓存行，并放置在自己的缓存中，并把store buffers中a的值写入缓存行中。\n\n提示\n\n上面9步流程及其相对顺序符合原文，但是个人认为把第1步和第2步调换了顺序更好理解一些。即cpu 1先发出“read”消息，而cpu 0后发出“read invalidate”消息，即cpu 1先获得总线使用权。\n\n可以看出，整个执行流程就像是把foo()中两条语句调换了顺序一样。如果按照原顺序执行的话，是不可能导致断言失败的，因为a = 1;早于b = 1;执行，那么while(b == 0) continue;结束时，变量a的值已经是1了。这算是由于引入store buffers而导致的指令重排序问题，而这种重排序会导致可见性问题。\n\n# 内存屏障\n对于上述问题，硬件工程师们无法提出自动维护一致性的解决方案，因为cpu无法知道哪些变量之间存在关联关系，更不必说是如何关联的。因此硬件工程师引入了内存屏障，软件工程师可以用内存屏障指令告诉cpu这种关联关系。\n\n仍然对于上述代码，只需要做如下修改，即可解决问题。\n\nvoid foo(void)\n{\n    a = 1;\n    smp_mb();\n    b = 1;\n}\n\nvoid bar(void)\n{\n    while(b == 0) continue;\n    assert(a == 1);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n内存屏障smp_mb();会导致cpu在之后的存储操作之前必须刷新它的store buffers。cpu要么暂停直到store buffers被清空，要么把后序的存储操作涉及的数据也存储到store buffers中，直到先存入store buffers的项被处理。\n\n对于后一种方法，可能的执行序列如下所述：\n\n 1.  cpu 0执行a = 1;，包含变量a的缓存行不在cpu 0的缓存行中，因此cpu 0将变量a的新值放入store buffers中，并发出“read invalidate”消息。\n 2.  cpu 1执行while(b == 0) continue;，但是包含变量b的缓存行不在cpu 1的缓存中，所以发出“read”消息。\n 3.  cpu 0执行smp_mb();，并标记当前store buffers中所有的项。\n 4.  cpu 0执行b = 1;，cpu 0已经拥有包含变量b的缓存行了（m或e状态），但是在store buffers中有标记项，因此并不会直接把变量b的新值写入到缓存行中，而是将它放入store buffers中（但是不标记）。\n 5.  cpu 0接收到“read”消息后（上面第2步cpu 1发出的），cpu 0将包含b的缓存行（包含旧值）传给cpu 1，并将缓存行状态设置为s。\n 6.  cpu 1接收到关于b的缓存行并放置在自己的缓存中。\n 7.  cpu 1现在可以加载变量b了，但是它发现变量b的值仍然是0（cpu 0传过来的旧值），所以继续循环。因为变量b的新值还放在store buffers中的。\n 8.  cpu 1接收到“read invalidate”消息（上面第1步）后，将包含变量a的缓存行传给cpu 0并将其设置为无效态（i）。\n 9.  cpu 0接收到包含变量a的缓存行后，并将store buffers中变量a的新值写入该缓存行。\n 10. 因为store buffers中的变量被标记了（上面第3步），由于当前例子中变量a是store buffers是唯一被标记的项，所以cpu 0也可以选择把变量b的新值写入缓存行中。\n 11. 因为目前变量b所在缓存行的状态为s，所以cpu 0发出“invalidate”消息给cpu 1（因为上面第10步）。\n 12. cpu 1接收到“invalidate”消息后，将包含变量b的缓存行失效，并向cpu 0发送确认消息。\n 13. cpu 1执行while(b == 0) continue;，但是包含变量b的缓存行不在其缓存内，所以发出“read”信息。\n 14. cpu 0接收到确认消息后（上面第12步），将包含变量b的缓存行的状态设置为e，cpu 0将变量b的新值写入缓存行中。\n 15. cpu 0接收到“read”消息，将包含变量b的缓存行传给cpu 1，并将其状态设置为s。\n 16. cpu 1接收到包含变量b的缓存行并放置在缓存中。\n 17. cpu 1现在加载变量b的值，发现b的值为1，所以退出while循环。\n 18. cpu 1执行assert(a == 1);，但是包含变量a的缓存行不在缓存中（因为上面第8步），所以从cpu 0中请求数据，此时将会得到变量a的最新值，并且断言成功。\n\n正如你所看见的，整个步骤比之前多了很多。仔细回顾上面的过程，就可以发现是通过将变量b的值也写入store buffers中而不是直接写回到缓存行中而避免了类似指令的重排序的。\n\n# 总结\n为了提高mesi协议的效率，所以引入了store buffers，但是这会导致类似指令重排序的效果，为了解决这个带来的新问题，所以又引入内存屏障。关于内存屏障，后面写文再详细分析。',charsets:{cjk:!0}},{title:"数据链路层概述",frontmatter:{title:"数据链路层概述",categories:["计算机网络与安全"],tags:["以太网"],date:"2021-01-13T19:15:50.000Z",permalink:"/pages/1f274f/"},regularPath:"/04.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/02.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/01.%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E6%A6%82%E8%BF%B0.html",relativePath:"04.计算机网络与安全/02.数据链路层/01.数据链路层概述.md",key:"v-3353134e",path:"/pages/1f274f/",headers:[{level:2,title:"三个问题",slug:"三个问题",normalizedTitle:"三个问题",charIndex:204},{level:3,title:"封装成帧",slug:"封装成帧",normalizedTitle:"封装成帧",charIndex:220},{level:3,title:"透明传输",slug:"透明传输",normalizedTitle:"透明传输",charIndex:503},{level:3,title:"差错控制",slug:"差错控制",normalizedTitle:"差错控制",charIndex:1001},{level:2,title:"相关协议",slug:"相关协议",normalizedTitle:"相关协议",charIndex:1435},{level:2,title:"以太网",slug:"以太网",normalizedTitle:"以太网",charIndex:475},{level:2,title:"相关设备",slug:"相关设备",normalizedTitle:"相关设备",charIndex:2066},{level:3,title:"适配器",slug:"适配器",normalizedTitle:"适配器",charIndex:2073},{level:3,title:"中继器",slug:"中继器",normalizedTitle:"中继器",charIndex:2342},{level:3,title:"集线器",slug:"集线器",normalizedTitle:"集线器",charIndex:2366},{level:3,title:"网桥",slug:"网桥",normalizedTitle:"网桥",charIndex:2634},{level:3,title:"交换机",slug:"交换机",normalizedTitle:"交换机",charIndex:2824},{level:3,title:"光电转换器",slug:"光电转换器",normalizedTitle:"光电转换器",charIndex:3104},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:3181}],excerpt:"<p>数据链路层作为经典五层模型中的第二层，负责将网络层中的数据发送到传输介质（物理层）中。首先要搞清楚链路和数据链路的区别：链路是指从一个节点到相邻节点的一段物理信道（有线或无线），而中间没有任何交换节点；数据链路则是另一个概念，这是因为在链路上传送数据时还要有一些必要的通信协议来控制这些数据的传输。目前数据链路层的信道类型有两种：点对点信道和广播信道。</p>\n",lastUpdated:"2021-01-18",headersStr:"三个问题 封装成帧 透明传输 差错控制 相关协议 以太网 相关设备 适配器 中继器 集线器 网桥 交换机 光电转换器 参考",content:"数据链路层作为经典五层模型中的第二层，负责将网络层中的数据发送到传输介质（物理层）中。首先要搞清楚链路和数据链路的区别：链路是指从一个节点到相邻节点的一段物理信道（有线或无线），而中间没有任何交换节点；数据链路则是另一个概念，这是因为在链路上传送数据时还要有一些必要的通信协议来控制这些数据的传输。目前数据链路层的信道类型有两种：点对点信道和广播信道。\n\n数据链路层协议有很多种，但是几乎每种协议都要解决下面三个问题。\n\n# 三个问题\n# 封装成帧\n数据链路层把上层网络层的数据（简称为数据报，分组或包）分成很多块，在每个块前后分别加上首部和尾部数据，这三部分数据共同形成了数据链路层帧（frame）。之所以引入帧的概念，是为了控制数据传送的开始和结束，否则接收方将一直从链路上获取信号，导致无法正确识别有效数据。\n\n\n\n另外，帧定义了数据的最大传输单元（MTU），如果长度太大将会分成多个数据片多次传送，避免了因数据错误导致重传整个数据包。\n\n数据链路层协议定义了帧首部和帧尾部以及MTU的长度，通常不同的协议都不太一样，甚至有些协议没有帧尾部（如以太网），所以一定要搞清楚每种协议是怎么规定的。\n\n# 透明传输\n透明传输问题是为了解决封装成帧产生的衍生问题。\n\n由于需要某些数据来表示帧的开始和结束，如果所要传输的数据中刚好包含了这样的数据，那么会导致接受方产生帧定界错误。透明传输是指不管所要传输的数据是什么，都不会导致帧定界错误。 由于所要传输的数据中可能出现任何表示帧开始和结束的数据，所以我们最好固定帧定界数据，去修改所要传送的数据。同样地，具体怎么做由协议说了算。\n\n透明传输的实现方式有以下几种：\n\n * 字符计数法：在帧头部中使用一个计数字段来表明帧内的字符数。\n * 字符填充的首尾定界法：采用一些特定的字符来定界一帧的开始与结束，如果数据中也出现同样的字符，那么则插入转义字符，接受方收到后就知道这是普通数据，而不是帧定界数据。\n * 零比特填充法：使用一个特定的比特模式，如01111110（例如PPP协议就使用这样的比特模式同时作为帧的开始结束标志）来标志一个帧的开始和结束，为了防止数据中也出现这样的比特模式，当数据中每连续出现5个连续的1时，将自动在后面插入一个0比特，接受方做该过程的逆操作即可。\n * 违规编码法\n\n目前使用的较多的是零比特填充发和违规编码法。\n\n# 差错控制\n由于链路的不确定性，信号很可能收到干扰，导致数据错误。链路上的接收者接收到错误帧时，应该丢弃掉，通常我们需要经过多条链路通信，如果接收者不丢弃掉，继续转发，可能导致转发目的地错误，就算转发正确，也浪费了资源。\n\n协议可以使用检错编码和纠错编码的方式计算帧校验序列（FCS）。FCS和普通数据一起发送给接收方的，产生了冗余（具体实现细节请查阅其他资料）。\n\n * 检错校验码包括奇偶校验码和循环冗余码。\n   \n   \n * 常见的纠错编码是海明码，不但能发现错误，还能自动纠错。\n   \n   \n\n另外，在早期通信质量不是很好时，大多数协议在差错控制的基础上增加了可靠传输，即收到正确的帧要进行确认。但是现如今通信质量已经大大提高了，所以现在的协议一般采用了区分对待的方法。对通信质量不好的链路，协议采用确认和重传机制；对于通信质量良好的链路，协议只是确保当前帧的数据正确，而不会提供可靠性保证，即不会保证帧的数量完整性以及帧之间的相对顺序保持一致。\n\n# 相关协议\n * PPP协议：一般在点对点链路上使用。\n * Ethernet V2：DIX制定的以太网协议\n * Frame Relay：帧中继协议\n * HLDL：高级数据链路协议\n * ......\n\n关于每种协议的细节，后面单独写文章总结。\n\n# 以太网\n以太网是一种局域网通信的技术标准，取代了其他局域网技术如令牌环，FDDI等，现如今局域网中基本上都使用以太网了。以太网有两个标准，一个是DIX Ethernet V2，另一个是IEEE 802.3。这两个标准很相似，但是随着发展，DIX Ethernet V2标准被广泛使用，所以现在又将以太网称为符合DIX Ethernet V2标准的局域网（尽管以太网是指标准而非局域网）。\n\n以太网标准中采用了CSMA/CD（和CSMA/CA）技术，有时又称为协议（按理说以太网才是协议，只是以太网使用了CSMA/CD而已）。\n\n以太网协议中没有帧结束定界符，因为其规定了在物理层使用曼彻斯特编码，接收端接收帧过程只要发现没有信号跳变，就认为帧结束。\n\n\n\n前8个字节为帧首部，包括7位为前导码，1位帧开始符。由于没有尾部，剩下的全部为帧中的数据（由以太网帧头部，网络层数据和FCS组成）。因为以太网帧数据部分最少要有64个字节，所以64减去以太网头部（14字节）和FCS（4字节），剩下就是46字节。如果网络层数据不够46字节，则需要填充，不用担心会扰乱网络层，因为网络层头部中保存了数据的有效长度。\n\n# 相关设备\n# 适配器\n通俗一点说，适配器就是指的设备中的网卡（网络适配器），处于链路的端点。每个适配器出厂时带有一个MAC地址，48位二进制表示，一般情况下，该地址是不会变化的（但是可以在操作系统层面修改，让操作系统使用指定的MAC地址）。根据ARP协议可以解析到其他主机的MAC地址。\n\n当网卡接收到广播帧时（目标MAC地址全是1），网卡需要处理数据。\n\n适配器发送数据时，根据协议，封装成帧；接收到数据时，根据协议，去掉帧头部和帧尾部，然后将数据发送到操作系统中交给协议栈处理，这也是为什么抓包工具不能抓取数据链路层的帧首部和帧尾部的原因。\n\n# 中继器\n一种较老的设备，功能是增强信号。\n\n# 集线器\n在使用普通总线型广播链路时（直接一个电缆连接所有设备），每个设备采用T型接口连接到总线上。该方式虽然简单，但是很容易出问题，导致通信质量不太好，为了解决该问题，引入了集线器（hub）。所有设备连接到集线器上，形成了星型拓扑结构，逻辑上仍然是总线型，即也可以把集线器看成网线。集线器的链路仍然是广播型链路，其中一个设备发送信号给集线器，集线器会转发该信号到所有的其他设备。如果多个集线器组网，会导致冲突与也增大，导致效率低下。使用集线器是单双工模式，不能同时收发，因为以太网采用了CSMA/CD，如果同时发则导致了冲突了。\n\n# 网桥\n网桥是为了解决集线器带来的冲突域增大。其内部有一个MAC地址表，保存了每一项MAC地址域端口。当网桥端口接收到信号时，其会判断目标MAC是否域源MAC在同一端口范围内，如果是，则不会转发到其他端口中，从而不会与其他主机的通信之间产生碰撞。如果MAC地址表中没有目标MAC地址，也会转发到所有的端口，当目标设备响应时，网桥会记录下MAC与端口，从而形成一个自学习过程。\n\n# 交换机\n其实，可以把交换机看成网口更多的网桥，现在交换机基本淘汰掉网桥了。对于单播帧，交换机仍然只会将帧转换到目标主机所在的主机；对于广播帧，才会转发到所有的端口，所以交换机组网又称为一个广播域（采用路由器来隔绝广播）。交换机工作模式可以是全双工，则不再使用CSMA/CD，因为使用双绞线可以同时收发。交换机的端口独享带宽，而且不同端口速率可以不一致，但集线器不行，因为集线器本质上是网线，各个端口速度都一致。尽管全双工模式下的交换机不再使用CSMA/CD技术，但是组成的网络仍然以太网，因为帧格式仍然是以太网的帧格式。\n\n链路层交换机没有MAC地址。\n\n# 光电转换器\n光信号适合远距离传输，所以两个远距离的局域网之间通信可以采用光电转换器，将信号在电信号和光信号之间转换。光电转换器我们一般称之为光猫。\n\n# 参考\n * 《计算机网络（第七版）》谢希仁\n * 《王道2021考研计算机网络》",normalizedContent:"数据链路层作为经典五层模型中的第二层，负责将网络层中的数据发送到传输介质（物理层）中。首先要搞清楚链路和数据链路的区别：链路是指从一个节点到相邻节点的一段物理信道（有线或无线），而中间没有任何交换节点；数据链路则是另一个概念，这是因为在链路上传送数据时还要有一些必要的通信协议来控制这些数据的传输。目前数据链路层的信道类型有两种：点对点信道和广播信道。\n\n数据链路层协议有很多种，但是几乎每种协议都要解决下面三个问题。\n\n# 三个问题\n# 封装成帧\n数据链路层把上层网络层的数据（简称为数据报，分组或包）分成很多块，在每个块前后分别加上首部和尾部数据，这三部分数据共同形成了数据链路层帧（frame）。之所以引入帧的概念，是为了控制数据传送的开始和结束，否则接收方将一直从链路上获取信号，导致无法正确识别有效数据。\n\n\n\n另外，帧定义了数据的最大传输单元（mtu），如果长度太大将会分成多个数据片多次传送，避免了因数据错误导致重传整个数据包。\n\n数据链路层协议定义了帧首部和帧尾部以及mtu的长度，通常不同的协议都不太一样，甚至有些协议没有帧尾部（如以太网），所以一定要搞清楚每种协议是怎么规定的。\n\n# 透明传输\n透明传输问题是为了解决封装成帧产生的衍生问题。\n\n由于需要某些数据来表示帧的开始和结束，如果所要传输的数据中刚好包含了这样的数据，那么会导致接受方产生帧定界错误。透明传输是指不管所要传输的数据是什么，都不会导致帧定界错误。 由于所要传输的数据中可能出现任何表示帧开始和结束的数据，所以我们最好固定帧定界数据，去修改所要传送的数据。同样地，具体怎么做由协议说了算。\n\n透明传输的实现方式有以下几种：\n\n * 字符计数法：在帧头部中使用一个计数字段来表明帧内的字符数。\n * 字符填充的首尾定界法：采用一些特定的字符来定界一帧的开始与结束，如果数据中也出现同样的字符，那么则插入转义字符，接受方收到后就知道这是普通数据，而不是帧定界数据。\n * 零比特填充法：使用一个特定的比特模式，如01111110（例如ppp协议就使用这样的比特模式同时作为帧的开始结束标志）来标志一个帧的开始和结束，为了防止数据中也出现这样的比特模式，当数据中每连续出现5个连续的1时，将自动在后面插入一个0比特，接受方做该过程的逆操作即可。\n * 违规编码法\n\n目前使用的较多的是零比特填充发和违规编码法。\n\n# 差错控制\n由于链路的不确定性，信号很可能收到干扰，导致数据错误。链路上的接收者接收到错误帧时，应该丢弃掉，通常我们需要经过多条链路通信，如果接收者不丢弃掉，继续转发，可能导致转发目的地错误，就算转发正确，也浪费了资源。\n\n协议可以使用检错编码和纠错编码的方式计算帧校验序列（fcs）。fcs和普通数据一起发送给接收方的，产生了冗余（具体实现细节请查阅其他资料）。\n\n * 检错校验码包括奇偶校验码和循环冗余码。\n   \n   \n * 常见的纠错编码是海明码，不但能发现错误，还能自动纠错。\n   \n   \n\n另外，在早期通信质量不是很好时，大多数协议在差错控制的基础上增加了可靠传输，即收到正确的帧要进行确认。但是现如今通信质量已经大大提高了，所以现在的协议一般采用了区分对待的方法。对通信质量不好的链路，协议采用确认和重传机制；对于通信质量良好的链路，协议只是确保当前帧的数据正确，而不会提供可靠性保证，即不会保证帧的数量完整性以及帧之间的相对顺序保持一致。\n\n# 相关协议\n * ppp协议：一般在点对点链路上使用。\n * ethernet v2：dix制定的以太网协议\n * frame relay：帧中继协议\n * hldl：高级数据链路协议\n * ......\n\n关于每种协议的细节，后面单独写文章总结。\n\n# 以太网\n以太网是一种局域网通信的技术标准，取代了其他局域网技术如令牌环，fddi等，现如今局域网中基本上都使用以太网了。以太网有两个标准，一个是dix ethernet v2，另一个是ieee 802.3。这两个标准很相似，但是随着发展，dix ethernet v2标准被广泛使用，所以现在又将以太网称为符合dix ethernet v2标准的局域网（尽管以太网是指标准而非局域网）。\n\n以太网标准中采用了csma/cd（和csma/ca）技术，有时又称为协议（按理说以太网才是协议，只是以太网使用了csma/cd而已）。\n\n以太网协议中没有帧结束定界符，因为其规定了在物理层使用曼彻斯特编码，接收端接收帧过程只要发现没有信号跳变，就认为帧结束。\n\n\n\n前8个字节为帧首部，包括7位为前导码，1位帧开始符。由于没有尾部，剩下的全部为帧中的数据（由以太网帧头部，网络层数据和fcs组成）。因为以太网帧数据部分最少要有64个字节，所以64减去以太网头部（14字节）和fcs（4字节），剩下就是46字节。如果网络层数据不够46字节，则需要填充，不用担心会扰乱网络层，因为网络层头部中保存了数据的有效长度。\n\n# 相关设备\n# 适配器\n通俗一点说，适配器就是指的设备中的网卡（网络适配器），处于链路的端点。每个适配器出厂时带有一个mac地址，48位二进制表示，一般情况下，该地址是不会变化的（但是可以在操作系统层面修改，让操作系统使用指定的mac地址）。根据arp协议可以解析到其他主机的mac地址。\n\n当网卡接收到广播帧时（目标mac地址全是1），网卡需要处理数据。\n\n适配器发送数据时，根据协议，封装成帧；接收到数据时，根据协议，去掉帧头部和帧尾部，然后将数据发送到操作系统中交给协议栈处理，这也是为什么抓包工具不能抓取数据链路层的帧首部和帧尾部的原因。\n\n# 中继器\n一种较老的设备，功能是增强信号。\n\n# 集线器\n在使用普通总线型广播链路时（直接一个电缆连接所有设备），每个设备采用t型接口连接到总线上。该方式虽然简单，但是很容易出问题，导致通信质量不太好，为了解决该问题，引入了集线器（hub）。所有设备连接到集线器上，形成了星型拓扑结构，逻辑上仍然是总线型，即也可以把集线器看成网线。集线器的链路仍然是广播型链路，其中一个设备发送信号给集线器，集线器会转发该信号到所有的其他设备。如果多个集线器组网，会导致冲突与也增大，导致效率低下。使用集线器是单双工模式，不能同时收发，因为以太网采用了csma/cd，如果同时发则导致了冲突了。\n\n# 网桥\n网桥是为了解决集线器带来的冲突域增大。其内部有一个mac地址表，保存了每一项mac地址域端口。当网桥端口接收到信号时，其会判断目标mac是否域源mac在同一端口范围内，如果是，则不会转发到其他端口中，从而不会与其他主机的通信之间产生碰撞。如果mac地址表中没有目标mac地址，也会转发到所有的端口，当目标设备响应时，网桥会记录下mac与端口，从而形成一个自学习过程。\n\n# 交换机\n其实，可以把交换机看成网口更多的网桥，现在交换机基本淘汰掉网桥了。对于单播帧，交换机仍然只会将帧转换到目标主机所在的主机；对于广播帧，才会转发到所有的端口，所以交换机组网又称为一个广播域（采用路由器来隔绝广播）。交换机工作模式可以是全双工，则不再使用csma/cd，因为使用双绞线可以同时收发。交换机的端口独享带宽，而且不同端口速率可以不一致，但集线器不行，因为集线器本质上是网线，各个端口速度都一致。尽管全双工模式下的交换机不再使用csma/cd技术，但是组成的网络仍然以太网，因为帧格式仍然是以太网的帧格式。\n\n链路层交换机没有mac地址。\n\n# 光电转换器\n光信号适合远距离传输，所以两个远距离的局域网之间通信可以采用光电转换器，将信号在电信号和光信号之间转换。光电转换器我们一般称之为光猫。\n\n# 参考\n * 《计算机网络（第七版）》谢希仁\n * 《王道2021考研计算机网络》",charsets:{cjk:!0}},{title:"网络层概述",frontmatter:{title:"网络层概述",categories:["计算机网络与安全"],tags:["IPv4","ICMP"],date:"2021-01-17T19:53:57.000Z",permalink:"/pages/548a38/"},regularPath:"/04.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/03.%E7%BD%91%E7%BB%9C%E5%B1%82/01.%E7%BD%91%E7%BB%9C%E5%B1%82%E6%A6%82%E8%BF%B0.html",relativePath:"04.计算机网络与安全/03.网络层/01.网络层概述.md",key:"v-373d1524",path:"/pages/548a38/",headers:[{level:2,title:"IP地址",slug:"ip地址",normalizedTitle:"ip地址",charIndex:165},{level:3,title:"IPv4地址",slug:"ipv4地址",normalizedTitle:"ipv4地址",charIndex:373},{level:3,title:"IPv6地址",slug:"ipv6地址",normalizedTitle:"ipv6地址",charIndex:380},{level:2,title:"相关协议",slug:"相关协议",normalizedTitle:"相关协议",charIndex:1019},{level:3,title:"IPv4报文格式",slug:"ipv4报文格式",normalizedTitle:"ipv4报文格式",charIndex:1085},{level:3,title:"ICMP报文格式",slug:"icmp报文格式",normalizedTitle:"icmp报文格式",charIndex:2139},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2986}],excerpt:"<p>网络层位于经典计算机网络分层的第三层，封装传输层的数据然后递交给数据链路层进行处理。在数据链路层中，不管是集线器还是交换机，面对广播帧时，都会转发到所有的端口。如果所有的设备都运行在这样的网络中，估计数据链路上传送的全是广播帧了，可见这样的效率是非常低的。所以，可以使用路由器来隔绝广播，从而形成多个不同的广播域（子网）。</p>\n",lastUpdated:"2021-01-18",headersStr:"IP地址 IPv4地址 IPv6地址 相关协议 IPv4报文格式 ICMP报文格式 总结",content:"网络层位于经典计算机网络分层的第三层，封装传输层的数据然后递交给数据链路层进行处理。在数据链路层中，不管是集线器还是交换机，面对广播帧时，都会转发到所有的端口。如果所有的设备都运行在这样的网络中，估计数据链路上传送的全是广播帧了，可见这样的效率是非常低的。所以，可以使用路由器来隔绝广播，从而形成多个不同的广播域（子网）。\n\n# IP地址\n路由器可以连接多个子网，则需要一种机制来表示与哪个子网进行通信，目前采用的这种机制就是IP地址。当设备之间进行通信时，在网络层使用IP地址，发送方先判断接受方是否在同一个网络内，如果是，则直接发送给目标接收方；如果不是，则需要发送给网关。设备也需要一种策略来判断目标IP地址是否属于同一个网络，这种策略叫做子网掩码。\n\n注意\n\n很多路由器除了拥有路由功能，同时扮演着链路层交换机的角色。\n\n目前IP地址分为IPv4地址和IPv6地址，分别由IPv4协议和IPv6协议使用。\n\n# IPv4地址\nIPv4地址由32位二进制组成，一般人类使用点分十进制来表示，即将32位等分为4部分，每部分采用十进制来表示，如192.168.0.1。IP地址由网络部分（网络号）和主机部分（主机号）组成。子网掩码的作用就是计算IP地址的网络号。当发送方发送数据时，首先根据子网掩码计算目标IP的主机号，然后再计算自己IP的主机号（将IP和子网掩码做逻辑与运算），若两者一致，说明接收方在同一个网络内，直接发送；否则，发送方发送给网关。\n\nIPv4地址的分配由IANA机构管理，在早期将所有的IP地址分为A~E 5类，如下图所示：\n\n\n\n下面讨论一下特殊的IP地址：\n\n * 主机号全是0的地址，特指某个网段，不能用该IP表示某个设备。主机号全是1的地址，特指该网段的全部主机，用于广播，也不能用该IP表示某个设备。\n   \n   \n * 对于A类地址，网络号全是0表示“本网络”；网络号十进制为127表示本地环回测试，所以这两类地址也不会使用来表示某个设备。\n   \n   \n\n分类地址是早期的决定，后来发现这种方式不是很灵活，很多公司申请了地址后，没有完全使用这些地址；同时，导致整个地址空间很快就使用完了。所以后来使用一种无分类地址（CIDR）了，如128.14.35.7/20，20表示网络号部分是前20位。无分类地址同样使用子网掩码，只不过称作变长子网掩码（VLSM）。\n\n# IPv6地址\n后面补充。\n\n# 相关协议\n网络层协议包括IPv4，IPv6，ARP，ICMP，IGMP等，在进行抓包分析时，要对各种协议的报文格式非常熟悉。\n\n# IPv4报文格式\nIPv4数据报的格式如下图所示：\n\n\n\n和以太网帧格式类似，IP数据报也分为首部和数据部分。本文主要分析数据包的首部，对于每个数据包，必须设置固定的20个字节的首部，另外可以根据需求添加最多40字节的其他首部数据，所以首部最多60个字节。下面分析固定部分的各个字段的含义：\n\n * 版本：占4位，表示IP协议的版本。其他大多网络层协议报文头部中也有版本字段，IPv4报文头中该字段值为4，IPv6的为6。\n   \n   \n * 首部长度：占4位，可表示的最大值为15。但是请注意，该字段的单位为4个字节，即最多可以表示60个字节，同时也说明IPv4的头部长度是4的倍数，如果不是则需要进行填充。\n   \n   \n * 区分服务：占8位，用来区分服务类型。\n   \n   \n * 总长度：占16位，指该数据报的首部加上数据部分的长度之和，可表示的最大长度为65535字节。但是注意，对于底层以太网协议，规定了MTU为1500字节，所以如果网络层数据长度超过了此长度，需要进行分片处理。\n   \n   \n * 标识：占16位，该标识作为相同报文的标识符，当一个IP数据报进行分片后，这些分片的该标识值都一样，接收方才知道这些都属于同一个IP数据报。（书上说不是序号，但确实没看懂解释）\n   \n   \n * 标志：占3位，目前只使用后两位。最低位标记为MF（More Fragment），值为1表示后面还有报文分片，否则表示这是若干数据报中的最后一个。中间一位为DF（Don't Fragment），表示不能分片，只有当DF=0时才能分片。对于数据长度超过了链路层的MTU而DF值为1的数据报，链路层协议在处理这种报文时应该直接丢弃。\n   \n   \n * 片偏移：占13位，表示当前报文中数据的第一个字节在原始报文数据中的字节偏移量。千万别误认为是第几个分片了。\n   \n   \n * 生存时间（TTL）：占8位，表示该数据报在网络中最多能被转发多少次，每当被转发一次，TTL值减1，当路由器收到TTL为0的报文时就丢弃该数据报。\n   \n   \n * 协议：占8位，表示该数据报携带的数据使用的哪种协议，以便IP层知道应该将数据部分上交给哪个协议处理。常用协议和对应的协议字段值如下图所示：\n   \n   \n   \n   \n * 首部检验和：占16位，这个字段只检验数据报的首部。\n   \n   \n * 源和目的地址：分别占32位。\n   \n   \n\n暂时不讨论可变部分的首部字段。\n\n# ICMP报文格式\nICMP协议允许主机或路由器报告差错情况和提供有关异常情况的报告。尽管ICMP报文被封装在IP数据报中，但是它不是高层协议。ICMP报文作为IP层数据报的数据，加上IP数据报的首部，组成IP数据报，ICMP报文格式如下图所示：\n\n\n\nICMP报文种类有两种，即ICMP差错报告报文和ICMP询问报文。ICMP报文的前4个字节是固定的，后面四个字节的内容与ICMP的类型有关，最后是数据部分。下表是几种常见的ICMP报文类型：\n\n\n\nICMP标准在不断更新，说不定不久的将来上图中的类型就会发生变化。下面解释一下几种差错报告的含义：\n\n * 当路由器收到生存时间（TTL）为0的的数据包时，除了丢弃该数据报以外，还要向源点发送时间超过报文。以及当重点在预先规定的时间内不能收到一个数据报的全部数据报时，就把迟到到达的数据报片都丢弃，并向源点发送时间超过报文。\n   \n   \n * 参数问题是指数据报的首部中的字段值存在不正确的情况，需要丢弃该数据报并回发参数问题报文。\n   \n   \n * 改变路由是指路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器。\n   \n   \n\n假如现在要对IP数据报A进行差错报告，那么所要报告的ICMP报文的内容包括A数据报的首部以及A数据报内容的前8个字节。\n\n下面是几种不再发送差错报告的情况：\n\n * 对ICMP差错报文报告不再发送ICMP差错报告。\n * 对第一个分片的数据报片的所有后序数据报片，都不发送ICMP差错报告报文。\n * 对具有多播地址的数据报，都不发送ICMP差错报告报文。\n * 对具有特殊地址的数据报，不发送ICMP差错报告报文。\n\n下面解释一下询问类型的ICMP数据报：\n\n * ICMP回送请求报文是主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送ICMP会送回答报文。\n * ICMP时间戳请求报文是请某台主机或路由器回答当前的日期和时间。\n\n# 总结\n对于常见的网络层数据报的格式要十分请求，对每种报文的首部字段要熟记于心，这样才能在抓包分析时得心应手。",normalizedContent:"网络层位于经典计算机网络分层的第三层，封装传输层的数据然后递交给数据链路层进行处理。在数据链路层中，不管是集线器还是交换机，面对广播帧时，都会转发到所有的端口。如果所有的设备都运行在这样的网络中，估计数据链路上传送的全是广播帧了，可见这样的效率是非常低的。所以，可以使用路由器来隔绝广播，从而形成多个不同的广播域（子网）。\n\n# ip地址\n路由器可以连接多个子网，则需要一种机制来表示与哪个子网进行通信，目前采用的这种机制就是ip地址。当设备之间进行通信时，在网络层使用ip地址，发送方先判断接受方是否在同一个网络内，如果是，则直接发送给目标接收方；如果不是，则需要发送给网关。设备也需要一种策略来判断目标ip地址是否属于同一个网络，这种策略叫做子网掩码。\n\n注意\n\n很多路由器除了拥有路由功能，同时扮演着链路层交换机的角色。\n\n目前ip地址分为ipv4地址和ipv6地址，分别由ipv4协议和ipv6协议使用。\n\n# ipv4地址\nipv4地址由32位二进制组成，一般人类使用点分十进制来表示，即将32位等分为4部分，每部分采用十进制来表示，如192.168.0.1。ip地址由网络部分（网络号）和主机部分（主机号）组成。子网掩码的作用就是计算ip地址的网络号。当发送方发送数据时，首先根据子网掩码计算目标ip的主机号，然后再计算自己ip的主机号（将ip和子网掩码做逻辑与运算），若两者一致，说明接收方在同一个网络内，直接发送；否则，发送方发送给网关。\n\nipv4地址的分配由iana机构管理，在早期将所有的ip地址分为a~e 5类，如下图所示：\n\n\n\n下面讨论一下特殊的ip地址：\n\n * 主机号全是0的地址，特指某个网段，不能用该ip表示某个设备。主机号全是1的地址，特指该网段的全部主机，用于广播，也不能用该ip表示某个设备。\n   \n   \n * 对于a类地址，网络号全是0表示“本网络”；网络号十进制为127表示本地环回测试，所以这两类地址也不会使用来表示某个设备。\n   \n   \n\n分类地址是早期的决定，后来发现这种方式不是很灵活，很多公司申请了地址后，没有完全使用这些地址；同时，导致整个地址空间很快就使用完了。所以后来使用一种无分类地址（cidr）了，如128.14.35.7/20，20表示网络号部分是前20位。无分类地址同样使用子网掩码，只不过称作变长子网掩码（vlsm）。\n\n# ipv6地址\n后面补充。\n\n# 相关协议\n网络层协议包括ipv4，ipv6，arp，icmp，igmp等，在进行抓包分析时，要对各种协议的报文格式非常熟悉。\n\n# ipv4报文格式\nipv4数据报的格式如下图所示：\n\n\n\n和以太网帧格式类似，ip数据报也分为首部和数据部分。本文主要分析数据包的首部，对于每个数据包，必须设置固定的20个字节的首部，另外可以根据需求添加最多40字节的其他首部数据，所以首部最多60个字节。下面分析固定部分的各个字段的含义：\n\n * 版本：占4位，表示ip协议的版本。其他大多网络层协议报文头部中也有版本字段，ipv4报文头中该字段值为4，ipv6的为6。\n   \n   \n * 首部长度：占4位，可表示的最大值为15。但是请注意，该字段的单位为4个字节，即最多可以表示60个字节，同时也说明ipv4的头部长度是4的倍数，如果不是则需要进行填充。\n   \n   \n * 区分服务：占8位，用来区分服务类型。\n   \n   \n * 总长度：占16位，指该数据报的首部加上数据部分的长度之和，可表示的最大长度为65535字节。但是注意，对于底层以太网协议，规定了mtu为1500字节，所以如果网络层数据长度超过了此长度，需要进行分片处理。\n   \n   \n * 标识：占16位，该标识作为相同报文的标识符，当一个ip数据报进行分片后，这些分片的该标识值都一样，接收方才知道这些都属于同一个ip数据报。（书上说不是序号，但确实没看懂解释）\n   \n   \n * 标志：占3位，目前只使用后两位。最低位标记为mf（more fragment），值为1表示后面还有报文分片，否则表示这是若干数据报中的最后一个。中间一位为df（don't fragment），表示不能分片，只有当df=0时才能分片。对于数据长度超过了链路层的mtu而df值为1的数据报，链路层协议在处理这种报文时应该直接丢弃。\n   \n   \n * 片偏移：占13位，表示当前报文中数据的第一个字节在原始报文数据中的字节偏移量。千万别误认为是第几个分片了。\n   \n   \n * 生存时间（ttl）：占8位，表示该数据报在网络中最多能被转发多少次，每当被转发一次，ttl值减1，当路由器收到ttl为0的报文时就丢弃该数据报。\n   \n   \n * 协议：占8位，表示该数据报携带的数据使用的哪种协议，以便ip层知道应该将数据部分上交给哪个协议处理。常用协议和对应的协议字段值如下图所示：\n   \n   \n   \n   \n * 首部检验和：占16位，这个字段只检验数据报的首部。\n   \n   \n * 源和目的地址：分别占32位。\n   \n   \n\n暂时不讨论可变部分的首部字段。\n\n# icmp报文格式\nicmp协议允许主机或路由器报告差错情况和提供有关异常情况的报告。尽管icmp报文被封装在ip数据报中，但是它不是高层协议。icmp报文作为ip层数据报的数据，加上ip数据报的首部，组成ip数据报，icmp报文格式如下图所示：\n\n\n\nicmp报文种类有两种，即icmp差错报告报文和icmp询问报文。icmp报文的前4个字节是固定的，后面四个字节的内容与icmp的类型有关，最后是数据部分。下表是几种常见的icmp报文类型：\n\n\n\nicmp标准在不断更新，说不定不久的将来上图中的类型就会发生变化。下面解释一下几种差错报告的含义：\n\n * 当路由器收到生存时间（ttl）为0的的数据包时，除了丢弃该数据报以外，还要向源点发送时间超过报文。以及当重点在预先规定的时间内不能收到一个数据报的全部数据报时，就把迟到到达的数据报片都丢弃，并向源点发送时间超过报文。\n   \n   \n * 参数问题是指数据报的首部中的字段值存在不正确的情况，需要丢弃该数据报并回发参数问题报文。\n   \n   \n * 改变路由是指路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器。\n   \n   \n\n假如现在要对ip数据报a进行差错报告，那么所要报告的icmp报文的内容包括a数据报的首部以及a数据报内容的前8个字节。\n\n下面是几种不再发送差错报告的情况：\n\n * 对icmp差错报文报告不再发送icmp差错报告。\n * 对第一个分片的数据报片的所有后序数据报片，都不发送icmp差错报告报文。\n * 对具有多播地址的数据报，都不发送icmp差错报告报文。\n * 对具有特殊地址的数据报，不发送icmp差错报告报文。\n\n下面解释一下询问类型的icmp数据报：\n\n * icmp回送请求报文是主机或路由器向一个特定的目的主机发出的询问。收到此报文的主机必须给源主机或路由器发送icmp会送回答报文。\n * icmp时间戳请求报文是请某台主机或路由器回答当前的日期和时间。\n\n# 总结\n对于常见的网络层数据报的格式要十分请求，对每种报文的首部字段要熟记于心，这样才能在抓包分析时得心应手。",charsets:{cjk:!0}},{title:"UDP概述",frontmatter:{title:"UDP概述",categories:["计算机网络与安全"],tags:["UDP"],date:"2021-01-20T01:23:34.000Z",permalink:"/pages/81b034/"},regularPath:"/04.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E5%AE%89%E5%85%A8/04.%E4%BC%A0%E8%BE%93%E5%B1%82/01.UDP%E6%A6%82%E8%BF%B0.html",relativePath:"04.计算机网络与安全/04.传输层/01.UDP概述.md",key:"v-0f580052",path:"/pages/81b034/",headers:[{level:2,title:"UDP概述",slug:"udp概述",normalizedTitle:"udp概述",charIndex:186},{level:2,title:"UDP报文首部",slug:"udp报文首部",normalizedTitle:"udp报文首部",charIndex:603}],excerpt:"<p>UDP属于传输层协议。根据定义，UDP是无连接的不可靠传输协议，只在IP数据报服务之上增加了很少一点的功能。既然UDP也是不可靠的，为什么不直接使用IP呢？每台主机上都运行着很多进程，虽然IP协议能够将数据报交给目标主机，但是如果仅靠IP协议，目标主机是不知道将解析后的数据报交给谁处理。所以通信的真正端点并不是主机而是主机中的进程，传输层使用端口来标识这些进程。</p>\n",lastUpdated:"2021-01-21",headersStr:"UDP概述 UDP报文首部",content:"UDP属于传输层协议。根据定义，UDP是无连接的不可靠传输协议，只在IP数据报服务之上增加了很少一点的功能。既然UDP也是不可靠的，为什么不直接使用IP呢？每台主机上都运行着很多进程，虽然IP协议能够将数据报交给目标主机，但是如果仅靠IP协议，目标主机是不知道将解析后的数据报交给谁处理。所以通信的真正端点并不是主机而是主机中的进程，传输层使用端口来标识这些进程。\n\n# UDP概述\n由于IP协议是不可靠的，可能会出现丢包等，所谓不可靠不一定就是“不好的”，可靠不一定就是“好的”。可靠传输是要付出额外代价的，当这种代价太大时，可能进行不可靠传输更好一些。所以，为了不同的需求，传输层同时提供可靠与不可靠的协议，如UDP就是不可靠协议，TCP是可靠的协议。\n\nUDP有下面几个特点：\n\n * UDP是无连接的，关于这个“连接”如何理解，后面讲TCP的文章中再分析。\n * UDP使用尽最大努力交付，即不可靠交互。\n * UDP是面向报文的，发送方对应用程序交下来的报文既不合并，也不拆分，就交给IP层了，保留了数据边界；同样地，接收方协议栈解析IP数据报后就包UDP报文交给上层应用了。所以，一般IP层的分片是对UDP的大报文进行处理。\n * UDP没有拥塞控制，关于拥塞控制也参考后面TCP的文章。\n * UDP支持一对一，一对多，多对一和多对多的通信。\n * UDP的首部开销小，只有8个字节。\n\n# UDP报文首部\nUDP的首部格式如下图所示：\n\n\n\nUDP报文首部很简单，就四个字段：\n\n * 源端口：在需要对方回信时使用，不需要时可用全0。\n * 目的端口：报文交付时使用，当接收方发现UDP发现收到的报文中的目的端口号不正确（即不存在对应端口号的应用进程），就丢弃该报文。并由ICMP协议发送端口不可达差错报文给发送方。\n * 长度：最小值为8，即只有首部。\n * 检验和：检测UDP用户数据报在传输过程中是否有错，有错就丢弃。\n\n注意，上图中有一个伪首部。所谓的伪首部，是因为这部分数据并不是UDP真正的首部，是为了计算校验和，临时添加在UDP用户数据报前面，得到一个临时的UDP用户数据报。注意，这个伪首部，既不向上递送也不向下递交，而仅仅是为了计算校验和。",normalizedContent:"udp属于传输层协议。根据定义，udp是无连接的不可靠传输协议，只在ip数据报服务之上增加了很少一点的功能。既然udp也是不可靠的，为什么不直接使用ip呢？每台主机上都运行着很多进程，虽然ip协议能够将数据报交给目标主机，但是如果仅靠ip协议，目标主机是不知道将解析后的数据报交给谁处理。所以通信的真正端点并不是主机而是主机中的进程，传输层使用端口来标识这些进程。\n\n# udp概述\n由于ip协议是不可靠的，可能会出现丢包等，所谓不可靠不一定就是“不好的”，可靠不一定就是“好的”。可靠传输是要付出额外代价的，当这种代价太大时，可能进行不可靠传输更好一些。所以，为了不同的需求，传输层同时提供可靠与不可靠的协议，如udp就是不可靠协议，tcp是可靠的协议。\n\nudp有下面几个特点：\n\n * udp是无连接的，关于这个“连接”如何理解，后面讲tcp的文章中再分析。\n * udp使用尽最大努力交付，即不可靠交互。\n * udp是面向报文的，发送方对应用程序交下来的报文既不合并，也不拆分，就交给ip层了，保留了数据边界；同样地，接收方协议栈解析ip数据报后就包udp报文交给上层应用了。所以，一般ip层的分片是对udp的大报文进行处理。\n * udp没有拥塞控制，关于拥塞控制也参考后面tcp的文章。\n * udp支持一对一，一对多，多对一和多对多的通信。\n * udp的首部开销小，只有8个字节。\n\n# udp报文首部\nudp的首部格式如下图所示：\n\n\n\nudp报文首部很简单，就四个字段：\n\n * 源端口：在需要对方回信时使用，不需要时可用全0。\n * 目的端口：报文交付时使用，当接收方发现udp发现收到的报文中的目的端口号不正确（即不存在对应端口号的应用进程），就丢弃该报文。并由icmp协议发送端口不可达差错报文给发送方。\n * 长度：最小值为8，即只有首部。\n * 检验和：检测udp用户数据报在传输过程中是否有错，有错就丢弃。\n\n注意，上图中有一个伪首部。所谓的伪首部，是因为这部分数据并不是udp真正的首部，是为了计算校验和，临时添加在udp用户数据报前面，得到一个临时的udp用户数据报。注意，这个伪首部，既不向上递送也不向下递交，而仅仅是为了计算校验和。",charsets:{cjk:!0}},{title:"网站",frontmatter:{title:"网站",permalink:"/collections/websites",date:"2020-12-12 22:25:04 +0800",article:!1,comment:!1},regularPath:"/102.%E6%94%B6%E8%97%8F%E5%A4%B9/01.%E7%BD%91%E7%AB%99.html",relativePath:"102.收藏夹/01.网站.md",key:"v-562e8b1e",path:"/collections/websites/",headers:[{level:2,title:"博客",slug:"博客",normalizedTitle:"博客",charIndex:2},{level:2,title:"操作系统",slug:"操作系统",normalizedTitle:"操作系统",charIndex:153},{level:3,title:"Linux",slug:"linux",normalizedTitle:"linux",charIndex:160},{level:2,title:"后端开发(Backend Development)",slug:"后端开发-backend-development",normalizedTitle:"后端开发(backend development)",charIndex:220},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:248},{level:3,title:"框架和类库",slug:"框架和类库",normalizedTitle:"框架和类库",charIndex:287},{level:3,title:"汇编",slug:"汇编",normalizedTitle:"汇编",charIndex:374},{level:2,title:"前端开发",slug:"前端开发",normalizedTitle:"前端开发",charIndex:429},{level:3,title:"Vue",slug:"vue",normalizedTitle:"vue",charIndex:436},{level:3,title:"设计",slug:"设计",normalizedTitle:"设计",charIndex:486},{level:3,title:"开发工具",slug:"开发工具",normalizedTitle:"开发工具",charIndex:567},{level:2,title:"常用工具(common tools)",slug:"常用工具-common-tools",normalizedTitle:"常用工具(common tools)",charIndex:587},{level:2,title:"书籍勘误(Errata of Book)",slug:"书籍勘误-errata-of-book",normalizedTitle:"书籍勘误(errata of book)",charIndex:908},{level:2,title:"关于人生",slug:"关于人生",normalizedTitle:"关于人生",charIndex:1026}],lastUpdated:"2021-03-21",headersStr:"博客 操作系统 Linux 后端开发(Backend Development) Java 框架和类库 汇编 前端开发 Vue 设计 开发工具 常用工具(common tools) 书籍勘误(Errata of Book) 关于人生",content:"# 博客\n * javadoop\n * crazymakercircle\n * mybird\n * 程序猿DD\n * 云风的Blog\n * HollisChuang's Blog\n * throwx\n * 陈皓-CoolShell\n * 陶辉笔记\n * smcdef：关于linux内核的文章不错。\n\n# 操作系统\n# Linux\n * 鸟哥的Linux私房菜\n   \n   \n * Linux阅码场原创精华文章汇总\n   \n   \n\n# 后端开发(Backend Development)\n# Java\n * theserverside\n * Java World\n\n# 框架和类库\n * Spring全家桶\n   \n   \n * baeldung关于Jackson的教程\n   \n   \n\n# 开源项目\n微人事文档\n\nEasyExcel\n\n# 汇编\n * NASM（eg. version: 2.15.05）\n * linux x86汇编系统调用\n\n# 前端开发\n# Vue\n * Vue 3.0文档\n * Vue-CLI\n * Vite文档\n * Vutur\n\n# 设计\n * codepen.io\n * neumorphism.io\n * alteredqualia.com\n * coolbackgrounds.io\n\n# 开发工具\n * yarn常用命令\n\n# 常用工具(common tools)\n * Gitee极速下载\n * Katex Support\n * Vim Plugins Searcher\n * 在线图片压缩\n * 在线抠图\n * logo制作\n * tmux * User Guide\n    * shortcuts\n   \n   \n * color picker * flatuicolors\n    * vanschneider\n    * uigradient（gradient color）\n   \n   \n * Solutions for C++ Primer 5th Answer\n * IDEA Helper\n * Intel Developer Mannual\n\n# 书籍勘误(Errata of Book)\n * The Linux Programming Interface\n * Professional JavaScript Programming\n * 深入理解Java虚拟机（第三版）\n\n# 关于人生\n * 程序员的十年工作创业血泪史，万字长文，仔细读完，受益匪浅",normalizedContent:"# 博客\n * javadoop\n * crazymakercircle\n * mybird\n * 程序猿dd\n * 云风的blog\n * hollischuang's blog\n * throwx\n * 陈皓-coolshell\n * 陶辉笔记\n * smcdef：关于linux内核的文章不错。\n\n# 操作系统\n# linux\n * 鸟哥的linux私房菜\n   \n   \n * linux阅码场原创精华文章汇总\n   \n   \n\n# 后端开发(backend development)\n# java\n * theserverside\n * java world\n\n# 框架和类库\n * spring全家桶\n   \n   \n * baeldung关于jackson的教程\n   \n   \n\n# 开源项目\n微人事文档\n\neasyexcel\n\n# 汇编\n * nasm（eg. version: 2.15.05）\n * linux x86汇编系统调用\n\n# 前端开发\n# vue\n * vue 3.0文档\n * vue-cli\n * vite文档\n * vutur\n\n# 设计\n * codepen.io\n * neumorphism.io\n * alteredqualia.com\n * coolbackgrounds.io\n\n# 开发工具\n * yarn常用命令\n\n# 常用工具(common tools)\n * gitee极速下载\n * katex support\n * vim plugins searcher\n * 在线图片压缩\n * 在线抠图\n * logo制作\n * tmux * user guide\n    * shortcuts\n   \n   \n * color picker * flatuicolors\n    * vanschneider\n    * uigradient（gradient color）\n   \n   \n * solutions for c++ primer 5th answer\n * idea helper\n * intel developer mannual\n\n# 书籍勘误(errata of book)\n * the linux programming interface\n * professional javascript programming\n * 深入理解java虚拟机（第三版）\n\n# 关于人生\n * 程序员的十年工作创业血泪史，万字长文，仔细读完，受益匪浅",charsets:{cjk:!0}},{title:"书籍",frontmatter:{title:"书籍",permalink:"/collections/books",date:"2020-12-12 22:25:04 +0800",article:!1,comment:!1},regularPath:"/102.%E6%94%B6%E8%97%8F%E5%A4%B9/02.%E4%B9%A6%E7%B1%8D.html",relativePath:"102.收藏夹/02.书籍.md",key:"v-2cb7c104",path:"/collections/books/",headers:[{level:2,title:"操作系统",slug:"操作系统",normalizedTitle:"操作系统",charIndex:20},{level:3,title:"Linux",slug:"linux",normalizedTitle:"linux",charIndex:27},{level:2,title:"编程语言",slug:"编程语言",normalizedTitle:"编程语言",charIndex:118},{level:3,title:"Java",slug:"java",normalizedTitle:"java",charIndex:125},{level:2,title:"后端框架",slug:"后端框架",normalizedTitle:"后端框架",charIndex:296},{level:3,title:"Spring",slug:"spring",normalizedTitle:"spring",charIndex:303}],lastUpdated:"2020-12-12",headersStr:"操作系统 Linux 编程语言 Java 后端框架 Spring",content:"下面是一些我看过或正在看的书籍。\n\n# 操作系统\n# Linux\n# TLPI\n简称TLPI，讲诉Linux系统编程的书，是理解Linux如何工作的入口。作者是Linux man pages的维护者，提供了书中的源码以及本书的勘误。# 编程语言\n# Java\n# Modern Java in Action (second edition)\n该书的前身是Java 8 in action，但比后者覆盖更多新版本的特性。两本书的作者也都一样，其中两位是英国人（来自剑桥大学），行文风格清晰直接。Java已经走过25年载，后来的Java产生了许许多多的特性，本书是了解现代Java的不二之选。# 后端框架\n# Spring",normalizedContent:"下面是一些我看过或正在看的书籍。\n\n# 操作系统\n# linux\n# tlpi\n简称tlpi，讲诉linux系统编程的书，是理解linux如何工作的入口。作者是linux man pages的维护者，提供了书中的源码以及本书的勘误。# 编程语言\n# java\n# modern java in action (second edition)\n该书的前身是java 8 in action，但比后者覆盖更多新版本的特性。两本书的作者也都一样，其中两位是英国人（来自剑桥大学），行文风格清晰直接。java已经走过25年载，后来的java产生了许许多多的特性，本书是了解现代java的不二之选。# 后端框架\n# spring",charsets:{cjk:!0}},{title:"Spring AOP基础",frontmatter:{title:"Spring AOP基础",categories:["后端框架"],tags:["Spring"],date:"2021-02-08T15:50:42.000Z",permalink:"/pages/0c4c2e/"},regularPath:"/22.%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/01.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/01.Spring%20Framework/02.AOP/01.AOP%E5%9F%BA%E7%A1%80.html",relativePath:"22.后端框架/01.Spring全家桶/01.Spring Framework/02.AOP/01.AOP基础.md",key:"v-35f7b9be",path:"/pages/0c4c2e/",headers:[{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:99},{level:2,title:"相关概念",slug:"相关概念",normalizedTitle:"相关概念",charIndex:165},{level:2,title:"实现者",slug:"实现者",normalizedTitle:"实现者",charIndex:830},{level:2,title:"使用配置",slug:"使用配置",normalizedTitle:"使用配置",charIndex:955},{level:3,title:"基于接口的配置",slug:"基于接口的配置",normalizedTitle:"基于接口的配置",charIndex:987},{level:3,title:"@Aspect配置",slug:"aspect配置",normalizedTitle:"@aspect配置",charIndex:3832},{level:3,title:"基于schema的配置",slug:"基于schema的配置",normalizedTitle:"基于schema的配置",charIndex:5848},{level:2,title:"创建增强",slug:"创建增强",normalizedTitle:"创建增强",charIndex:6844},{level:2,title:"创建切面",slug:"创建切面",normalizedTitle:"创建切面",charIndex:7693},{level:3,title:"切点类型",slug:"切点类型",normalizedTitle:"切点类型",charIndex:7700},{level:3,title:"切面类型",slug:"切面类型",normalizedTitle:"切面类型",charIndex:7780},{level:2,title:"@Aspect进阶",slug:"aspect进阶",normalizedTitle:"@aspect进阶",charIndex:7893},{level:3,title:"访问连接点信息",slug:"访问连接点信息",normalizedTitle:"访问连接点信息",charIndex:7905},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:7661}],excerpt:"<p>AOP是Spring的两大核心之一，在Spring种占据重要地位。但是由于其涉及很多复杂概念，配置方式多种多样，常常让学习者眼花缭乱，晕头转向。本文对AOP相关的概念和配置做一个简单的梳理。</p>\n",lastUpdated:"2021-02-22",headersStr:"应用场景 相关概念 实现者 使用配置 基于接口的配置 @Aspect配置 基于schema的配置 创建增强 创建切面 切点类型 切面类型 @Aspect进阶 访问连接点信息 参考",content:'AOP是Spring的两大核心之一，在Spring种占据重要地位。但是由于其涉及很多复杂概念，配置方式多种多样，常常让学习者眼花缭乱，晕头转向。本文对AOP相关的概念和配置做一个简单的梳理。\n\n# 应用场景\n * 记录日志\n * 监控方法的运行（如运行时间，入参，返回值等）\n * 权限控制\n * 缓存优化\n * 事务管理\n\n# 相关概念\n * 连接点（Join Point）：指程序执行的某个特定位置，Spring仅支持方法的连接点。即仅能在方法调用前，方法调用后，异常抛出时及方法调用前后这些程序执行点织入增强。连接点是程序类中客观存在的事务。\n   \n   \n * 切点（Pointcut）：指增强要织入的具体位置，即连接点的信息，切点是连接点，而连接点不一定是切点。\n   \n   \n * 增强（Advice）：又被称为通知。既包含了一段在切点上执行的逻辑，又包含了在众多连接点中定位切点点的方位信息。\n   \n   \n * 目标对象（Target）：指增强逻辑的织入目标。如对象A中有一个方法sayHello()，如果该方法是一个切点，那么对象A就是AOP的目标对象。\n   \n   \n * 织入（Weaving）：将目标类，增强编织在一起。Spring AOP有3种织入方式：\n   \n    * 编译期织入，要求使用特殊的编译器。\n    * 类装载期织入，要求使用特殊的类装载器。\n    * 动态代理织入，在运行期为目标类添加增强生成子类的方式。\n   \n   Spring AOP采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。\n   \n   \n * 代理（Proxy）：进行织入后，目标对象会生成一个结果类。\n   \n   \n * 切面（Aspect）：可以仅通过增强类生成一个切面，但切点必须结合增强才能制作出切面。增强包含连接点信息和横切逻辑，但切点仅包含连接点信息（感觉有点不好理解？？？）。\n   \n   \n\n# 实现者\nAOP的设计目标是把横切的问题模块化。在Java中，相关的AOP实现有AspectJ，Spring AOP等。前者是Java领域AOP的完全解决方案，十分强大；而后者是Spring提供的轻量级方案，致力于解决企业级开发中最普遍的需求。\n\n# 使用配置\n目前Spring AOP一共有三种配置方式：\n\n * 基于接口的配置（始于Spring 1.2）。\n * 基于schema的方式（始于Spring 2.0）。\n * @Aspect注解配置（始于Spring 2.0）。\n\n# 基于接口的配置\n新建一个UserService接口和对应的实现类UserServiceImpl：\n\npublic interface UserService {\n  User createUser(int id, String username, String password);\n}\n\n\n1\n2\n3\npublic class UserServiceImpl implements UserService {\n  @Override\n  public User createUser(int id, String username, String password) {\n    return new User(id, username, password);\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n在定义两个增强逻辑实现类：\n\npublic class LogArgsAdvice implements MethodBeforeAdvice {\n  @Override\n  public void before(Method method, Object[] args, Object target) throws Throwable {\n    System.out.println("准备执行方法：" + method.getName());\n    System.out.println("方法参数列表：" + Arrays.toString(args));\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\npublic class LogResultAdvice implements AfterReturningAdvice {\n  @Override\n  public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable {\n    System.out.println("方法执行返回：" + method.getName());\n    System.out.println("方法返回值为：" + returnValue);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n然后在xml文件中进行配置：\n\n<bean id="userServiceImpl" class="net.harrison.service.impl.UserServiceImpl" />\n\n<bean id="logArgsAdvice" class="net.harrison.advice.LogArgsAdvice"/>\n<bean id="logResultAdvice" class="net.harrison.advice.LogResultAdvice"/>\n\n<bean id="userServiceProxy" class="org.springframework.aop.framework.ProxyFactoryBean">\n    <property name="proxyInterfaces">\n        <list>\n            <value>net.harrison.service.UserService</value>\n        </list>\n    </property>\n    <property name="target" ref="userServiceImpl" />\n    <property name="interceptorNames">\n        <list>\n            <value>logArgsAdvice</value>\n            <value>logResultAdvice</value>\n        </list>\n    </property>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n最后进行测试：\n\nClassPathXmlApplicationContext cpxac = new ClassPathXmlApplicationContext("classpath:applicationContext.xml");\nUserService userService = (UserService) cpxac.getBean("userServiceProxy");\nuserService.createUser(1, "harrison", "123");\n\n\n1\n2\n3\n输出内容如下：\n\n> 准备执行方法：createUser 方法参数列表：[1, harrison, 123] 方法执行返回：createUser 方法返回值为：User(id=1, username=harrison, password=123)\n\n\n重点关注xml文件中的配置，配置了一个类型为ProxyFactoryBean的bean，这就是目标对象的代理对象，分别指定了织入过程中需要的一些属性：proxyInterfaces，target和interceptorNames。\n\n这种方案最大的问题是需要为每个bean都配置一个代理，非常不方便。\n\n为了解决上面说到的问题，使用BeanNameAutoProxyCreator代替ProxyFactoryBean。\n\n<bean class="org.springframework.aop.framework.autoproxy.BeanNameAutoProxyCreator">\n  <property name="interceptorNames">\n    <list>\n      <value>logArgsAdvice</value>\n      <value>logResultAdvice</value>\n    </list>\n  </property>\n  <property name="beanNames" value="*ServiceImpl"/>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n其中beanNames属性可以使用正则来匹配bean的名字，会为匹配上的bean创建代理。再次测试，可以根据类型来获取bean了。\n\nUserService userService = context.getBean(UserService.class);\n\n\n1\n# @Aspect配置\n该注解位于aspectjweaver.jar这个包中，来自AspectJ。Spring AOP引用了AspectJ的一些定义和注解。\n\n开启@Aspect注解配置有两种方式：\n\n * 在xml中：\n   \n   \x3c!-- 可以指定proxy-target-class="true" 强制让Spring使用CGLIB代理--\x3e\n   <aop:aspectj-autoproxy />\n   \n   \n   1\n   2\n   笔记\n   \n   关于Spring AOP与动态代理，如果目标对象实现了接口，默认情况下会采用JDK的动态代理，但可以强制指定使用CGLIB代理；如果目标对象没有实现接口，只能使用CGLIB代理。\n   \n   \n\n​ :::\n\n * 如果使用Java Config的话，可以使用@EnableAspectJAutoProxy注解。\n\n一旦开启了上面的配置后，所有使用@Aspect注解的bean都会被Spring当作用来实现的AOP的配置类。\n\n首先配置切点：\n\n@Aspect\npublic class AspectConfig {\n  @Pointcut("execution(* net.harrison.service.*.*(..))")\n  public void businessService() {}\n}\n\n\n1\n2\n3\n4\n5\n再配置增强：\n\n@Aspect\npublic class LogArgsAdvice {\n\n  @Before("net.harrison.config.aop.AspectConfig.businessService()")\n  public void logArgs(JoinPoint joinPoint) throws Throwable {\n    System.out.println("=========================");\n    System.out.println("方法参数列表：" + Arrays.toString(joinPoint.getArgs()));\n    System.out.println("=========================");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n@Aspect\npublic class LogResultAdvice {\n\n  @AfterReturning(pointcut = "net.harrison.config.aop.AspectConfig.businessService()",\n    returning = "result")\n  public void afterReturning(Object result) {\n    System.out.println("=========================");\n    System.out.println("方法返回值为：" + result);\n    System.out.println("=========================");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n笔记\n\n上面是将切点定义与增强分开，好处时可以复用切点定义，修改时只需修改一处。\n\n另外，可以直接将切点表达式写在增强定义中。\n\n  @Before("execution(* net.harrison.service.*.*(..))")\n  public void logArgs(JoinPoint joinPoint) throws Throwable {\n    System.out.println("=========================");\n    System.out.println("方法参数列表：" + Arrays.toString(joinPoint.getArgs()));\n    System.out.println("=========================");\n  }\n\n\n1\n2\n3\n4\n5\n6\n最后在xml文件中配置：\n\n  <bean id="userServiceImpl" class="net.harrison.service.impl.UserServiceImpl" />\n\n  <bean id="logArgsAdvice" class="net.harrison.advice.LogArgsAdvice"/>\n  <bean id="logResultAdvice" class="net.harrison.advice.LogResultAdvice"/>\n\n\n1\n2\n3\n4\n这样就实现了AOP的配置了。\n\n# 基于schema的配置\n在上面基于@Aspect配置的基础上，去掉Java类中的相关注解（因为这种配置方式不需要用到任何注解），然后在xml中配置如下：\n\n<bean id="userServiceImpl" class="net.harrison.service.impl.UserServiceImpl" />\n<bean id="logArgsAdvice" class="net.harrison.advice.LogArgsAdvice"/>\n<bean id="logResultAdvice" class="net.harrison.advice.LogResultAdvice"/>\n\n<aop:config>\n    \x3c!-- 第一种方式 --\x3e\n    <aop:pointcut id="logArgsPointCut" expression="execution(* net.harrison.service..*.*(..))"/>\n    <aop:aspect ref="logArgsAdvice">\n        <aop:before pointcut-ref="logArgsPointCut" method="logArgs"/>\n    </aop:aspect>\n    \n    \x3c!-- 第二种方式 --\x3e\n    <aop:aspect ref="logResultAdvice">\n        <aop:pointcut id="logResultPointCut" expression="execution(* net.harrison.service..*.*(..))"/>\n        <aop:after-returning method="afterReturning" pointcut-ref="logResultPointCut" returning="result"/>\n    </aop:aspect>\n</aop:config>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n上面有两种配置方式，第一种将切点的配置和切面的配置分离，第二种将切点配置在切面内部。前者的切点配置是全局的，可以在其他任何切面配置中引用；而后者是局部的，只能在当前切面内引用。\n\n# 创建增强\n上面配置中，只是简单的使用了两种增强类型，在Spring AOP中还支持其他类型的增强。下面详细分析一下各种类型的增强的使用方式。\n\n下图是增强接口继承关系图：\n\n\n\n其中<<aopalliance>>是指aop联盟定义的，<<spring>>是指Spring定义的。\n\n在Spring AOP中，一共有5中增强类型：\n\n * 前置增强，MethodBeforeAdvice接口。\n * 后置增强，AfterReturningAdvice接口。\n * 环绕增强，MethodInterceptor接口。\n * 异常抛出增强，ThrowAdvice接口。\n * 引介增强，IntroductionInterceptor接口。\n\n可以实现实现这些接口来定义增强。\n\n但是使用@Aspect注解配置时，一般使用注解来定义增强，一般包括三部分：增强类型，目标切点表达式和增强横切逻辑。增强横切逻辑一般就是方法，增强类型是注解，目标切点表达式为这些注解的参数，是一些切点表达式函数。\n\n * 前置增强：@Before。\n * 返回增强：@AfterReturning。方法正常返回时执行。\n * 后置增强：@After，不管是抛出异常还是正常退出，该增强都会得到执行。\n * 异常抛出增强：AfterThrowing。方法抛出异常时执行。\n * 环绕增强：@Around。\n * 引介增强：@DeclareParents。\n\n切点表达式由切点表达式函数组成，Spring支持9中不同的切点表达式函数，用不同的方式描述切点信息，根据描述对象的不同，可以大致分为4类：\n\n * 方法切入点函数：通过描述目标类方法的信息定义连接点。\n * 方法入参切点函数：通过描述目标类方法入参的信息定义连接点。\n * 目标类切点函数：通过描述目标类类型的信息定义连接点。\n * 代理类切点函数：通过描述目标类的代理类的信息定义连接点。\n\n完整的说明可以参考下图：\n\n\n\n最常用的是execution()函数。\n\n# 创建切面\n# 切点类型\nSpring定义了6种类型的切点：\n\n * 静态方法切点\n * 动态方法切点\n * 注解切点\n * 表达式切点\n * 流程切点\n * 复合切点\n\n# 切面类型\n * Advisor：表示一般切面。\n * PointcutAdvisor：具有切点的切面。可以通过PointcutAdvisor的实现类来创建切面。\n * IntroductionAdvisor：引介切面。\n\n# @Aspect进阶\n# 访问连接点信息\n任何增强方法都可以将第一个入参声明为JoinPoint来访问连接点的上下文信息。另外它的子接口ProceedingJoinPoint增加了两个用于执行连接点方法的方法。可以参考一下源码，很容易理解类中定义的各项属性的含义。\n\n# 参考\n * javadoop相关文章\n * 《精通Spring 4.x》',normalizedContent:'aop是spring的两大核心之一，在spring种占据重要地位。但是由于其涉及很多复杂概念，配置方式多种多样，常常让学习者眼花缭乱，晕头转向。本文对aop相关的概念和配置做一个简单的梳理。\n\n# 应用场景\n * 记录日志\n * 监控方法的运行（如运行时间，入参，返回值等）\n * 权限控制\n * 缓存优化\n * 事务管理\n\n# 相关概念\n * 连接点（join point）：指程序执行的某个特定位置，spring仅支持方法的连接点。即仅能在方法调用前，方法调用后，异常抛出时及方法调用前后这些程序执行点织入增强。连接点是程序类中客观存在的事务。\n   \n   \n * 切点（pointcut）：指增强要织入的具体位置，即连接点的信息，切点是连接点，而连接点不一定是切点。\n   \n   \n * 增强（advice）：又被称为通知。既包含了一段在切点上执行的逻辑，又包含了在众多连接点中定位切点点的方位信息。\n   \n   \n * 目标对象（target）：指增强逻辑的织入目标。如对象a中有一个方法sayhello()，如果该方法是一个切点，那么对象a就是aop的目标对象。\n   \n   \n * 织入（weaving）：将目标类，增强编织在一起。spring aop有3种织入方式：\n   \n    * 编译期织入，要求使用特殊的编译器。\n    * 类装载期织入，要求使用特殊的类装载器。\n    * 动态代理织入，在运行期为目标类添加增强生成子类的方式。\n   \n   spring aop采用动态代理织入，而aspectj采用编译期织入和类装载期织入。\n   \n   \n * 代理（proxy）：进行织入后，目标对象会生成一个结果类。\n   \n   \n * 切面（aspect）：可以仅通过增强类生成一个切面，但切点必须结合增强才能制作出切面。增强包含连接点信息和横切逻辑，但切点仅包含连接点信息（感觉有点不好理解？？？）。\n   \n   \n\n# 实现者\naop的设计目标是把横切的问题模块化。在java中，相关的aop实现有aspectj，spring aop等。前者是java领域aop的完全解决方案，十分强大；而后者是spring提供的轻量级方案，致力于解决企业级开发中最普遍的需求。\n\n# 使用配置\n目前spring aop一共有三种配置方式：\n\n * 基于接口的配置（始于spring 1.2）。\n * 基于schema的方式（始于spring 2.0）。\n * @aspect注解配置（始于spring 2.0）。\n\n# 基于接口的配置\n新建一个userservice接口和对应的实现类userserviceimpl：\n\npublic interface userservice {\n  user createuser(int id, string username, string password);\n}\n\n\n1\n2\n3\npublic class userserviceimpl implements userservice {\n  @override\n  public user createuser(int id, string username, string password) {\n    return new user(id, username, password);\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n在定义两个增强逻辑实现类：\n\npublic class logargsadvice implements methodbeforeadvice {\n  @override\n  public void before(method method, object[] args, object target) throws throwable {\n    system.out.println("准备执行方法：" + method.getname());\n    system.out.println("方法参数列表：" + arrays.tostring(args));\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\npublic class logresultadvice implements afterreturningadvice {\n  @override\n  public void afterreturning(object returnvalue, method method, object[] args, object target) throws throwable {\n    system.out.println("方法执行返回：" + method.getname());\n    system.out.println("方法返回值为：" + returnvalue);\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n然后在xml文件中进行配置：\n\n<bean id="userserviceimpl" class="net.harrison.service.impl.userserviceimpl" />\n\n<bean id="logargsadvice" class="net.harrison.advice.logargsadvice"/>\n<bean id="logresultadvice" class="net.harrison.advice.logresultadvice"/>\n\n<bean id="userserviceproxy" class="org.springframework.aop.framework.proxyfactorybean">\n    <property name="proxyinterfaces">\n        <list>\n            <value>net.harrison.service.userservice</value>\n        </list>\n    </property>\n    <property name="target" ref="userserviceimpl" />\n    <property name="interceptornames">\n        <list>\n            <value>logargsadvice</value>\n            <value>logresultadvice</value>\n        </list>\n    </property>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n最后进行测试：\n\nclasspathxmlapplicationcontext cpxac = new classpathxmlapplicationcontext("classpath:applicationcontext.xml");\nuserservice userservice = (userservice) cpxac.getbean("userserviceproxy");\nuserservice.createuser(1, "harrison", "123");\n\n\n1\n2\n3\n输出内容如下：\n\n> 准备执行方法：createuser 方法参数列表：[1, harrison, 123] 方法执行返回：createuser 方法返回值为：user(id=1, username=harrison, password=123)\n\n\n重点关注xml文件中的配置，配置了一个类型为proxyfactorybean的bean，这就是目标对象的代理对象，分别指定了织入过程中需要的一些属性：proxyinterfaces，target和interceptornames。\n\n这种方案最大的问题是需要为每个bean都配置一个代理，非常不方便。\n\n为了解决上面说到的问题，使用beannameautoproxycreator代替proxyfactorybean。\n\n<bean class="org.springframework.aop.framework.autoproxy.beannameautoproxycreator">\n  <property name="interceptornames">\n    <list>\n      <value>logargsadvice</value>\n      <value>logresultadvice</value>\n    </list>\n  </property>\n  <property name="beannames" value="*serviceimpl"/>\n</bean>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n其中beannames属性可以使用正则来匹配bean的名字，会为匹配上的bean创建代理。再次测试，可以根据类型来获取bean了。\n\nuserservice userservice = context.getbean(userservice.class);\n\n\n1\n# @aspect配置\n该注解位于aspectjweaver.jar这个包中，来自aspectj。spring aop引用了aspectj的一些定义和注解。\n\n开启@aspect注解配置有两种方式：\n\n * 在xml中：\n   \n   \x3c!-- 可以指定proxy-target-class="true" 强制让spring使用cglib代理--\x3e\n   <aop:aspectj-autoproxy />\n   \n   \n   1\n   2\n   笔记\n   \n   关于spring aop与动态代理，如果目标对象实现了接口，默认情况下会采用jdk的动态代理，但可以强制指定使用cglib代理；如果目标对象没有实现接口，只能使用cglib代理。\n   \n   \n\n​ :::\n\n * 如果使用java config的话，可以使用@enableaspectjautoproxy注解。\n\n一旦开启了上面的配置后，所有使用@aspect注解的bean都会被spring当作用来实现的aop的配置类。\n\n首先配置切点：\n\n@aspect\npublic class aspectconfig {\n  @pointcut("execution(* net.harrison.service.*.*(..))")\n  public void businessservice() {}\n}\n\n\n1\n2\n3\n4\n5\n再配置增强：\n\n@aspect\npublic class logargsadvice {\n\n  @before("net.harrison.config.aop.aspectconfig.businessservice()")\n  public void logargs(joinpoint joinpoint) throws throwable {\n    system.out.println("=========================");\n    system.out.println("方法参数列表：" + arrays.tostring(joinpoint.getargs()));\n    system.out.println("=========================");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n@aspect\npublic class logresultadvice {\n\n  @afterreturning(pointcut = "net.harrison.config.aop.aspectconfig.businessservice()",\n    returning = "result")\n  public void afterreturning(object result) {\n    system.out.println("=========================");\n    system.out.println("方法返回值为：" + result);\n    system.out.println("=========================");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n笔记\n\n上面是将切点定义与增强分开，好处时可以复用切点定义，修改时只需修改一处。\n\n另外，可以直接将切点表达式写在增强定义中。\n\n  @before("execution(* net.harrison.service.*.*(..))")\n  public void logargs(joinpoint joinpoint) throws throwable {\n    system.out.println("=========================");\n    system.out.println("方法参数列表：" + arrays.tostring(joinpoint.getargs()));\n    system.out.println("=========================");\n  }\n\n\n1\n2\n3\n4\n5\n6\n最后在xml文件中配置：\n\n  <bean id="userserviceimpl" class="net.harrison.service.impl.userserviceimpl" />\n\n  <bean id="logargsadvice" class="net.harrison.advice.logargsadvice"/>\n  <bean id="logresultadvice" class="net.harrison.advice.logresultadvice"/>\n\n\n1\n2\n3\n4\n这样就实现了aop的配置了。\n\n# 基于schema的配置\n在上面基于@aspect配置的基础上，去掉java类中的相关注解（因为这种配置方式不需要用到任何注解），然后在xml中配置如下：\n\n<bean id="userserviceimpl" class="net.harrison.service.impl.userserviceimpl" />\n<bean id="logargsadvice" class="net.harrison.advice.logargsadvice"/>\n<bean id="logresultadvice" class="net.harrison.advice.logresultadvice"/>\n\n<aop:config>\n    \x3c!-- 第一种方式 --\x3e\n    <aop:pointcut id="logargspointcut" expression="execution(* net.harrison.service..*.*(..))"/>\n    <aop:aspect ref="logargsadvice">\n        <aop:before pointcut-ref="logargspointcut" method="logargs"/>\n    </aop:aspect>\n    \n    \x3c!-- 第二种方式 --\x3e\n    <aop:aspect ref="logresultadvice">\n        <aop:pointcut id="logresultpointcut" expression="execution(* net.harrison.service..*.*(..))"/>\n        <aop:after-returning method="afterreturning" pointcut-ref="logresultpointcut" returning="result"/>\n    </aop:aspect>\n</aop:config>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n上面有两种配置方式，第一种将切点的配置和切面的配置分离，第二种将切点配置在切面内部。前者的切点配置是全局的，可以在其他任何切面配置中引用；而后者是局部的，只能在当前切面内引用。\n\n# 创建增强\n上面配置中，只是简单的使用了两种增强类型，在spring aop中还支持其他类型的增强。下面详细分析一下各种类型的增强的使用方式。\n\n下图是增强接口继承关系图：\n\n\n\n其中<<aopalliance>>是指aop联盟定义的，<<spring>>是指spring定义的。\n\n在spring aop中，一共有5中增强类型：\n\n * 前置增强，methodbeforeadvice接口。\n * 后置增强，afterreturningadvice接口。\n * 环绕增强，methodinterceptor接口。\n * 异常抛出增强，throwadvice接口。\n * 引介增强，introductioninterceptor接口。\n\n可以实现实现这些接口来定义增强。\n\n但是使用@aspect注解配置时，一般使用注解来定义增强，一般包括三部分：增强类型，目标切点表达式和增强横切逻辑。增强横切逻辑一般就是方法，增强类型是注解，目标切点表达式为这些注解的参数，是一些切点表达式函数。\n\n * 前置增强：@before。\n * 返回增强：@afterreturning。方法正常返回时执行。\n * 后置增强：@after，不管是抛出异常还是正常退出，该增强都会得到执行。\n * 异常抛出增强：afterthrowing。方法抛出异常时执行。\n * 环绕增强：@around。\n * 引介增强：@declareparents。\n\n切点表达式由切点表达式函数组成，spring支持9中不同的切点表达式函数，用不同的方式描述切点信息，根据描述对象的不同，可以大致分为4类：\n\n * 方法切入点函数：通过描述目标类方法的信息定义连接点。\n * 方法入参切点函数：通过描述目标类方法入参的信息定义连接点。\n * 目标类切点函数：通过描述目标类类型的信息定义连接点。\n * 代理类切点函数：通过描述目标类的代理类的信息定义连接点。\n\n完整的说明可以参考下图：\n\n\n\n最常用的是execution()函数。\n\n# 创建切面\n# 切点类型\nspring定义了6种类型的切点：\n\n * 静态方法切点\n * 动态方法切点\n * 注解切点\n * 表达式切点\n * 流程切点\n * 复合切点\n\n# 切面类型\n * advisor：表示一般切面。\n * pointcutadvisor：具有切点的切面。可以通过pointcutadvisor的实现类来创建切面。\n * introductionadvisor：引介切面。\n\n# @aspect进阶\n# 访问连接点信息\n任何增强方法都可以将第一个入参声明为joinpoint来访问连接点的上下文信息。另外它的子接口proceedingjoinpoint增加了两个用于执行连接点方法的方法。可以参考一下源码，很容易理解类中定义的各项属性的含义。\n\n# 参考\n * javadoop相关文章\n * 《精通spring 4.x》',charsets:{cjk:!0}},{title:"注册DispatcherServlet",frontmatter:{title:"注册DispatcherServlet",categories:["后端框架"],tags:["SpringMVC"],date:"2020-12-26T23:11:48.000Z",permalink:"/pages/f167d9/"},regularPath:"/22.%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/01.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/01.Spring%20Framework/03.Web/01.%E6%B3%A8%E5%86%8CDispatcherServlet.html",relativePath:"22.后端框架/01.Spring全家桶/01.Spring Framework/03.Web/01.注册DispatcherServlet.md",key:"v-44cd0617",path:"/pages/f167d9/",headers:[{level:2,title:"基于web.xml的方式",slug:"基于web-xml的方式",normalizedTitle:"基于web.xml的方式",charIndex:208},{level:2,title:"通过实现WebApplicationInitializer接口",slug:"通过实现webapplicationinitializer接口",normalizedTitle:"通过实现webapplicationinitializer接口",charIndex:1693},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:5353}],excerpt:"<p>DispatcherServlet是SpringMVC的前端控制器，其本身也是一个Servlet，Servlet容器会调用内部的<code>service()</code>方法来处理请求。目前主要有两种方式注册DispatcherServlet到Servlet容器中，第一种就是常见的通过web.xml的方式，第二种是使用通过实现<code>org.springframework.web.WebApplicationInitializer</code>接口。</p>\n",lastUpdated:"2021-01-13",headersStr:"基于web.xml的方式 通过实现WebApplicationInitializer接口 总结",content:'DispatcherServlet是SpringMVC的前端控制器，其本身也是一个Servlet，Servlet容器会调用内部的service()方法来处理请求。目前主要有两种方式注册DispatcherServlet到Servlet容器中，第一种就是常见的通过web.xml的方式，第二种是使用通过实现org.springframework.web.WebApplicationInitializer接口。\n\n# 基于web.xml的方式\nweb.xml位于classpath:WEB-INF目录下，当启动servlet容器时，容器会读取该文件，并进行相应的处理。下面是一个很简单的配置：\n\n<!DOCTYPE web-app PUBLIC\n "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"\n "http://java.sun.com/dtd/web-app_2_3.dtd" >\n\n<web-app>\n  <context-param>\n    <param-name>contextConfigLocation</param-name>\n    <param-value>classpath:applicationContext.xml</param-value>\n  </context-param>\n\n  <listener>\n    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n  </listener>\n\n  <servlet>\n    <servlet-name>dispatcherServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n      <param-name>contextConfigLocation</param-name>\n      <param-value>classpath:dispatcherServlet-servlet.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n  </servlet>\n  \n  <servlet-mapping>\n    <servlet-name>dispatcherServlet</servlet-name>\n    <url-pattern>/*</url-pattern>\n  </servlet-mapping>\n</web-app>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n和注册普通的Servlet一样，通过<servlet>和<servlet-mapping>标签注册servlet以及映射关系，在定义DispatcherServlet时，通过<init-param>标签将SpringMVC的配置文件位置作为初始化信息传递给该Servlet（默认情况下的配置文件为：classpath:[servlet-name]-servlet.xml）。\n\n另外，还通过<context-param>标签将Spring的配置文件作为ServletContext的初始化参数，通过<listen>容器注册了一个Servlet容器事件监听器（该监听器实现了Servlet规范定义的ServletContextListener接口），在容器启动和销毁时，会调用对应的方法。通过监听Servlet容器的启动事件，Spring执行IOC容器的初始化操作，关于这部分内容，后面再进行分析。\n\n# 通过实现WebApplicationInitializer接口\n可能大部分人都很熟悉通过web.xml的方式，但是在Servlet3.0后，Spring（Spring3.1版本开始）提供了另外一种方式注册DispatcherServlet，下面通过实现WebApplicationInitializer接口达到了上述web.xml中一样的效果。\n\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\n  @Override\n  public void onStartup(ServletContext servletContext) throws ServletException {\n    final ServletRegistration.Dynamic servlet = servletContext\n        .addServlet("dispatcherServlet", new DispatcherServlet());\n    servlet.setInitParameter("contextConfigLocation", "classpath:dispatcherServlet.xml");\n    servlet.setLoadOnStartup(1);\n    servlet.addMapping("/*");\n    servletContext.addListener(org.springframework.web.context.ContextLoaderListener.class);\n    servletContext.setInitParameter("contextConfigLocation", "classpath:applicationContext.xml");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n第4行，手动创建了一个DispatcherServlet并注册到ServletContext，然后返回了一个ServletRegistration.Dynamic类型的对象，第6行和第7行分别通过该对象配置了该servlet的属性。第8行注册了监听器，第9行将Spring的配置文件路径设置为ServletContext的初始化参数。\n\nweb.xml文件的位置是固定的，Servlet容器很容易就可以加载该文件，但是我们编写的WebApplicationInitializer实现类的位置却不固定，那么Servlet容器又是怎么找到该实现类的呢？\n\nServlet3.0规范定义了ServletContainerInitializer接口，该接口内部定义了一个叫做onStartup的方法，Spring中定义了一个该接口的实现类：org.springframework.web.SpringServletContainerInitializer。在Servlet容器启动时会通过Java的SPI机制找到所有实现了ServletContainerInitializer接口的类，Servlet规范规定，凡是实现了Servlet规范的容器，必须在启动容器时，调用这些实现类的onStartup方法。\n\n另外，该实现类还标注一个javax.servlet.annotation.HandlesTypes注解：\n\n@HandlesTypes(WebApplicationInitializer.class)\n\n\n1\n该注解的含义为该实现类希望在对哪些类进行处理，这里就是我们上面所述的WebApplicationInitializer，当容器启动时，在执行该实现类的onStartup方法之前，首先会扫描所有的类，然后找到我们所希望进行处理的类（@HandlesTypes所指示的类）并放入集合中，作为onStartup方法的第一个参数。\n\n也即是说，整个执行链为：Servlet容器 -> SpringServletContainerInitializer.onStartup() -> MyServletContainerInitializer.onStartup()。\n\nSpring之所以为我们定义SpringServletContainerInitializer类，一方面是简化使用SPI机制带来的额外配置（比如在classpath:WEB-INFO/servies目录下定义对应的配置文件），让我们仅实现WebApplicationInitializer接口即可。另一方面是进一步简化我们的使用配置，避免我们直接通过ServletContext进行配置，上面例子中就是这样实现的，那是因为配置较少，如果配置较多就比较繁琐了。那么Spring是如何简化的呢？其实，Spring还定义几个实现了WebApplicationInitializer接口的抽象类，整个关联关系为下图所示：\n\n\n\n比如，我们可以继承AbstractAnnotationConfigDispatcherServletInitializer类，该类中定义了几个方法，可以用来处理我们的常用配置，具体请参考API。\n\n其实，还可以对上述配置进行修改一下，实现纯Java配置。\n\npublic class MyWebApplicationInitializer implements WebApplicationInitializer {\n  @Override\n  public void onStartup(ServletContext servletContext) throws ServletException {\n\n    final AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext();\n    applicationContext.register(AppConfig.class);\n\n    AnnotationConfigWebApplicationContext webContainer\n        = new AnnotationConfigWebApplicationContext();\n    webContainer.setParent(applicationContext);\n    webContainer.register(AppWebConfig.class);\n\n    final ServletRegistration.Dynamic servlet = servletContext\n        .addServlet("dispatcherServlet", new DispatcherServlet(webContainer));\n    servlet.setLoadOnStartup(1);\n    servlet.addMapping("/");\n\n    servletContext.addListener(org.springframework.web.context.ContextLoaderListener.class);\n    servletContext.setInitParameter("contextConfigLocation", "classpath:applicationContext.xml");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n@Configuration\n@ComponentScan(useDefaultFilters = false,\n    basePackages = {"net.harrison"},\n    excludeFilters = {@ComponentScan.Filter(type = FilterType.ANNOTATION,\n        classes = org.springframework.web.bind.annotation.RestController.class)})\npublic class AppConfig{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n@Configuration\n@ComponentScan(basePackages = "net.harrison.controller")\npublic class AppWebConfig {\n}\n\n\n1\n2\n3\n4\n关于Spring容器的更多配置，后面再写文分析。\n\n# 总结\n以前使用XML配置是为了实现配置与业务解耦，大概后来发现XML配置也具有很多缺点，比如不能实现类型检查，可读性不高等。践行“约定大于配置”的SpringBoot确实给我们的开发带来了很多便利，其实JavaConfig也并不是那么地“耦合”。',normalizedContent:'dispatcherservlet是springmvc的前端控制器，其本身也是一个servlet，servlet容器会调用内部的service()方法来处理请求。目前主要有两种方式注册dispatcherservlet到servlet容器中，第一种就是常见的通过web.xml的方式，第二种是使用通过实现org.springframework.web.webapplicationinitializer接口。\n\n# 基于web.xml的方式\nweb.xml位于classpath:web-inf目录下，当启动servlet容器时，容器会读取该文件，并进行相应的处理。下面是一个很简单的配置：\n\n<!doctype web-app public\n "-//sun microsystems, inc.//dtd web application 2.3//en"\n "http://java.sun.com/dtd/web-app_2_3.dtd" >\n\n<web-app>\n  <context-param>\n    <param-name>contextconfiglocation</param-name>\n    <param-value>classpath:applicationcontext.xml</param-value>\n  </context-param>\n\n  <listener>\n    <listener-class>org.springframework.web.context.contextloaderlistener</listener-class>\n  </listener>\n\n  <servlet>\n    <servlet-name>dispatcherservlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.dispatcherservlet</servlet-class>\n    <init-param>\n      <param-name>contextconfiglocation</param-name>\n      <param-value>classpath:dispatcherservlet-servlet.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n  </servlet>\n  \n  <servlet-mapping>\n    <servlet-name>dispatcherservlet</servlet-name>\n    <url-pattern>/*</url-pattern>\n  </servlet-mapping>\n</web-app>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n和注册普通的servlet一样，通过<servlet>和<servlet-mapping>标签注册servlet以及映射关系，在定义dispatcherservlet时，通过<init-param>标签将springmvc的配置文件位置作为初始化信息传递给该servlet（默认情况下的配置文件为：classpath:[servlet-name]-servlet.xml）。\n\n另外，还通过<context-param>标签将spring的配置文件作为servletcontext的初始化参数，通过<listen>容器注册了一个servlet容器事件监听器（该监听器实现了servlet规范定义的servletcontextlistener接口），在容器启动和销毁时，会调用对应的方法。通过监听servlet容器的启动事件，spring执行ioc容器的初始化操作，关于这部分内容，后面再进行分析。\n\n# 通过实现webapplicationinitializer接口\n可能大部分人都很熟悉通过web.xml的方式，但是在servlet3.0后，spring（spring3.1版本开始）提供了另外一种方式注册dispatcherservlet，下面通过实现webapplicationinitializer接口达到了上述web.xml中一样的效果。\n\npublic class mywebapplicationinitializer implements webapplicationinitializer {\n  @override\n  public void onstartup(servletcontext servletcontext) throws servletexception {\n    final servletregistration.dynamic servlet = servletcontext\n        .addservlet("dispatcherservlet", new dispatcherservlet());\n    servlet.setinitparameter("contextconfiglocation", "classpath:dispatcherservlet.xml");\n    servlet.setloadonstartup(1);\n    servlet.addmapping("/*");\n    servletcontext.addlistener(org.springframework.web.context.contextloaderlistener.class);\n    servletcontext.setinitparameter("contextconfiglocation", "classpath:applicationcontext.xml");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n第4行，手动创建了一个dispatcherservlet并注册到servletcontext，然后返回了一个servletregistration.dynamic类型的对象，第6行和第7行分别通过该对象配置了该servlet的属性。第8行注册了监听器，第9行将spring的配置文件路径设置为servletcontext的初始化参数。\n\nweb.xml文件的位置是固定的，servlet容器很容易就可以加载该文件，但是我们编写的webapplicationinitializer实现类的位置却不固定，那么servlet容器又是怎么找到该实现类的呢？\n\nservlet3.0规范定义了servletcontainerinitializer接口，该接口内部定义了一个叫做onstartup的方法，spring中定义了一个该接口的实现类：org.springframework.web.springservletcontainerinitializer。在servlet容器启动时会通过java的spi机制找到所有实现了servletcontainerinitializer接口的类，servlet规范规定，凡是实现了servlet规范的容器，必须在启动容器时，调用这些实现类的onstartup方法。\n\n另外，该实现类还标注一个javax.servlet.annotation.handlestypes注解：\n\n@handlestypes(webapplicationinitializer.class)\n\n\n1\n该注解的含义为该实现类希望在对哪些类进行处理，这里就是我们上面所述的webapplicationinitializer，当容器启动时，在执行该实现类的onstartup方法之前，首先会扫描所有的类，然后找到我们所希望进行处理的类（@handlestypes所指示的类）并放入集合中，作为onstartup方法的第一个参数。\n\n也即是说，整个执行链为：servlet容器 -> springservletcontainerinitializer.onstartup() -> myservletcontainerinitializer.onstartup()。\n\nspring之所以为我们定义springservletcontainerinitializer类，一方面是简化使用spi机制带来的额外配置（比如在classpath:web-info/servies目录下定义对应的配置文件），让我们仅实现webapplicationinitializer接口即可。另一方面是进一步简化我们的使用配置，避免我们直接通过servletcontext进行配置，上面例子中就是这样实现的，那是因为配置较少，如果配置较多就比较繁琐了。那么spring是如何简化的呢？其实，spring还定义几个实现了webapplicationinitializer接口的抽象类，整个关联关系为下图所示：\n\n\n\n比如，我们可以继承abstractannotationconfigdispatcherservletinitializer类，该类中定义了几个方法，可以用来处理我们的常用配置，具体请参考api。\n\n其实，还可以对上述配置进行修改一下，实现纯java配置。\n\npublic class mywebapplicationinitializer implements webapplicationinitializer {\n  @override\n  public void onstartup(servletcontext servletcontext) throws servletexception {\n\n    final annotationconfigapplicationcontext applicationcontext = new annotationconfigapplicationcontext();\n    applicationcontext.register(appconfig.class);\n\n    annotationconfigwebapplicationcontext webcontainer\n        = new annotationconfigwebapplicationcontext();\n    webcontainer.setparent(applicationcontext);\n    webcontainer.register(appwebconfig.class);\n\n    final servletregistration.dynamic servlet = servletcontext\n        .addservlet("dispatcherservlet", new dispatcherservlet(webcontainer));\n    servlet.setloadonstartup(1);\n    servlet.addmapping("/");\n\n    servletcontext.addlistener(org.springframework.web.context.contextloaderlistener.class);\n    servletcontext.setinitparameter("contextconfiglocation", "classpath:applicationcontext.xml");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n@configuration\n@componentscan(usedefaultfilters = false,\n    basepackages = {"net.harrison"},\n    excludefilters = {@componentscan.filter(type = filtertype.annotation,\n        classes = org.springframework.web.bind.annotation.restcontroller.class)})\npublic class appconfig{\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n@configuration\n@componentscan(basepackages = "net.harrison.controller")\npublic class appwebconfig {\n}\n\n\n1\n2\n3\n4\n关于spring容器的更多配置，后面再写文分析。\n\n# 总结\n以前使用xml配置是为了实现配置与业务解耦，大概后来发现xml配置也具有很多缺点，比如不能实现类型检查，可读性不高等。践行“约定大于配置”的springboot确实给我们的开发带来了很多便利，其实javaconfig也并不是那么地“耦合”。',charsets:{cjk:!0}},{title:"web.xml配置Spring容器启动",frontmatter:{title:"web.xml配置Spring容器启动",categories:["后端框架"],tags:["Spring","SpringMVC"],date:"2020-12-29T00:33:52.000Z",permalink:"/pages/668c92/"},regularPath:"/22.%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/01.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/01.Spring%20Framework/03.Web/02.Xml%E9%85%8D%E7%BD%AE%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8.html",relativePath:"22.后端框架/01.Spring全家桶/01.Spring Framework/03.Web/02.Xml配置容器启动.md",key:"v-ea5e1dca",path:"/pages/668c92/",headers:[{level:2,title:"创建父容器",slug:"创建父容器",normalizedTitle:"创建父容器",charIndex:210},{level:2,title:"创建子容器",slug:"创建子容器",normalizedTitle:"创建子容器",charIndex:1437},{level:2,title:"父子容器",slug:"父子容器",normalizedTitle:"父子容器",charIndex:169}],excerpt:"<p>一般我们在使用Spring，SpringMVC开发web项目时，并没有手动创建容器，而只需要在配置文件中配置好bean的信息即可。一般我们会定义两个配置文件，一个spring的，一个springmvc的，然后将这两个配置文件的路径信息配置在web.xml文件中的。那么Spring容器是怎么启动的，如何将这两个配置文件关联到容器，以及使用父子容器有什么优缺点。</p>\n",lastUpdated:"2021-01-13",headersStr:"创建父容器 创建子容器 父子容器",content:"一般我们在使用Spring，SpringMVC开发web项目时，并没有手动创建容器，而只需要在配置文件中配置好bean的信息即可。一般我们会定义两个配置文件，一个spring的，一个springmvc的，然后将这两个配置文件的路径信息配置在web.xml文件中的。那么Spring容器是怎么启动的，如何将这两个配置文件关联到容器，以及使用父子容器有什么优缺点。\n\n注意\n\n本文分析的Spring版本为5.3.2。\n\n# 创建父容器\n一般我们会通过以下配置指定父容器的配置信息，并且通过配置Servlet容器监听器，准备在Servlet容器启动时创建容器。\n\n<context-param>\n    <param-name>contextConfigLocation</param-name>\n    <param-value>classpath:applicationContext.xml</param-value>\n</context-param>\n<listener>\n    <listener-class>\n        org.springframework.web.context.ContextLoaderListener\n    </listener-class>\n</listener>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n那么ContextLoaderListener就是分析的入口，该类实现了接口ServletContextListener，并继承了类ContextLoader。Servlet容器启动时，会调用contextInitialized()方法，在内部又调用ContextLoader的initWebApplicationContext()方法。\n\n首先根据ServletContext判断是否已经创建过容器，如果没有创建则调用createWebApplicationContext()创建，在该方法内部，首先会调用determineContextClass()获取需要创建的容器的类型信息（Class对象），这是Spring为我们提供的一个扩展，如果我们配置了属性名为contextClass的属性，那么Spring会创建该类型的容器，否则使用保存在org.springframework.web.context.ContextLoader.properties文件中的默认配置：\n\norg.springframework.web.context.WebApplicationContext=org.springframework.web.context.support.XmlWebApplicationContext\n\n\n1\n确定好容器类型就可以创建容器实例，然后回到initWebApplicationContext()中，会继续为容器设置父容器，当然默认为空实现。接下来继续调用configureAndRefreshWebApplicationContext()，在该方法中，从ServletContext中获取属性名为contextConfigLocation的属性，这刚好就是我们在web.xml中配置的Spring配置文件路径，当然，如果我们不配置或者是不配置成contextConfigLocation，则不会将配置绑定到容器中，但是还是会调用容器的refresh()方法。至此，父容器的创建过程基本完成。\n\n# 创建子容器\n在web.xml文件中我们还会配置DispatcherServlet，子容器的配置信息通过该Servlet配置传递给Spring。\n\n<servlet>\n    <servlet-name>dispatcherServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:dispatcherServlet.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n</servlet>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nServlet容器在调用了Servlet监听器后，就会调用Servlet的init()来实例化。DispatcherServlet的父类HttpServletBean重写了init()方法，所以子容器的创建过程就从这里开始。首先获取servlet的ServletConfig对象中保存的属性信息，其中就包括上述xml配置中的contextConfigLocation属性，然后在init()中执行bw.setPropertyValues(pvs, true);，该调用链比较长，这里主要关注通过反射调用了FrameworkServlet的setContextConfigLocation()方法为其contextConfigLocation属性赋了值。\n\n回到HttpServletBean的init()方法，最后调用了initServletBean()方法，该方法被子类FrameworkBean重写。根据调用链，在createWebApplicationContext()方法中进行子容器的创建，并把从ServletContext中获取到的父容器设置为子容器的父容器。这里创建的子容器的Class是FrameworkServlet中的常量属性DEFAULT_CONTEXT_CLASS，其值为XmlWebApplicationContext.class。然后将上面进行赋值过的contextConfigLocation属性绑定到容器中。如果该属性为null则不会绑定，但是仍然会调用容器的refresh()方法。至此，子容器的创建过程基本完成。\n\n# 父子容器\n通过以上分析，可知我们常见的配置会导致创建两个Spring容器，两个容器都是XmlWebApplicationContext类型的。一般我们开发都分为三层：Controller，Service，Dao，而将Service和Dao的bean注入父容器中，Controller层的bean注入子容器中。使用父子容器可以避免因为同一容器中同名bean无法共存的问题，可以避免service层注入controller层的bean，导致依赖混乱，因为父容器内无法获取到子容器的bean，而子容器可以获取到父容器的bean。",normalizedContent:"一般我们在使用spring，springmvc开发web项目时，并没有手动创建容器，而只需要在配置文件中配置好bean的信息即可。一般我们会定义两个配置文件，一个spring的，一个springmvc的，然后将这两个配置文件的路径信息配置在web.xml文件中的。那么spring容器是怎么启动的，如何将这两个配置文件关联到容器，以及使用父子容器有什么优缺点。\n\n注意\n\n本文分析的spring版本为5.3.2。\n\n# 创建父容器\n一般我们会通过以下配置指定父容器的配置信息，并且通过配置servlet容器监听器，准备在servlet容器启动时创建容器。\n\n<context-param>\n    <param-name>contextconfiglocation</param-name>\n    <param-value>classpath:applicationcontext.xml</param-value>\n</context-param>\n<listener>\n    <listener-class>\n        org.springframework.web.context.contextloaderlistener\n    </listener-class>\n</listener>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n那么contextloaderlistener就是分析的入口，该类实现了接口servletcontextlistener，并继承了类contextloader。servlet容器启动时，会调用contextinitialized()方法，在内部又调用contextloader的initwebapplicationcontext()方法。\n\n首先根据servletcontext判断是否已经创建过容器，如果没有创建则调用createwebapplicationcontext()创建，在该方法内部，首先会调用determinecontextclass()获取需要创建的容器的类型信息（class对象），这是spring为我们提供的一个扩展，如果我们配置了属性名为contextclass的属性，那么spring会创建该类型的容器，否则使用保存在org.springframework.web.context.contextloader.properties文件中的默认配置：\n\norg.springframework.web.context.webapplicationcontext=org.springframework.web.context.support.xmlwebapplicationcontext\n\n\n1\n确定好容器类型就可以创建容器实例，然后回到initwebapplicationcontext()中，会继续为容器设置父容器，当然默认为空实现。接下来继续调用configureandrefreshwebapplicationcontext()，在该方法中，从servletcontext中获取属性名为contextconfiglocation的属性，这刚好就是我们在web.xml中配置的spring配置文件路径，当然，如果我们不配置或者是不配置成contextconfiglocation，则不会将配置绑定到容器中，但是还是会调用容器的refresh()方法。至此，父容器的创建过程基本完成。\n\n# 创建子容器\n在web.xml文件中我们还会配置dispatcherservlet，子容器的配置信息通过该servlet配置传递给spring。\n\n<servlet>\n    <servlet-name>dispatcherservlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.dispatcherservlet</servlet-class>\n    <init-param>\n        <param-name>contextconfiglocation</param-name>\n        <param-value>classpath:dispatcherservlet.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n</servlet>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nservlet容器在调用了servlet监听器后，就会调用servlet的init()来实例化。dispatcherservlet的父类httpservletbean重写了init()方法，所以子容器的创建过程就从这里开始。首先获取servlet的servletconfig对象中保存的属性信息，其中就包括上述xml配置中的contextconfiglocation属性，然后在init()中执行bw.setpropertyvalues(pvs, true);，该调用链比较长，这里主要关注通过反射调用了frameworkservlet的setcontextconfiglocation()方法为其contextconfiglocation属性赋了值。\n\n回到httpservletbean的init()方法，最后调用了initservletbean()方法，该方法被子类frameworkbean重写。根据调用链，在createwebapplicationcontext()方法中进行子容器的创建，并把从servletcontext中获取到的父容器设置为子容器的父容器。这里创建的子容器的class是frameworkservlet中的常量属性default_context_class，其值为xmlwebapplicationcontext.class。然后将上面进行赋值过的contextconfiglocation属性绑定到容器中。如果该属性为null则不会绑定，但是仍然会调用容器的refresh()方法。至此，子容器的创建过程基本完成。\n\n# 父子容器\n通过以上分析，可知我们常见的配置会导致创建两个spring容器，两个容器都是xmlwebapplicationcontext类型的。一般我们开发都分为三层：controller，service，dao，而将service和dao的bean注入父容器中，controller层的bean注入子容器中。使用父子容器可以避免因为同一容器中同名bean无法共存的问题，可以避免service层注入controller层的bean，导致依赖混乱，因为父容器内无法获取到子容器的bean，而子容器可以获取到父容器的bean。",charsets:{cjk:!0}},{title:"SpringMVC源码分析之HandlerMapping",frontmatter:{title:"SpringMVC源码分析之HandlerMapping",categories:["后端框架"],tags:["SpringMVC"],date:"2021-01-10T20:13:00.000Z",permalink:"/pages/f2c795/"},regularPath:"/22.%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/01.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/01.Spring%20Framework/03.Web/03.%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BHandlerMapping.html",relativePath:"22.后端框架/01.Spring全家桶/01.Spring Framework/03.Web/03.源码分析之HandlerMapping.md",key:"v-f2f938b2",path:"/pages/f2c795/",headers:[{level:2,title:"注册HandlerMapping",slug:"注册handlermapping",normalizedTitle:"注册handlermapping",charIndex:445},{level:2,title:"获取HandlerExecutionChain",slug:"获取handlerexecutionchain",normalizedTitle:"获取handlerexecutionchain",charIndex:4820},{level:2,title:"HandlerMapping体系",slug:"handlermapping体系",normalizedTitle:"handlermapping体系",charIndex:5656},{level:2,title:"AbstractHandlerMapping中的初始化",slug:"abstracthandlermapping中的初始化",normalizedTitle:"abstracthandlermapping中的初始化",charIndex:6308},{level:2,title:"AbstractHandlerMapping获取HandlerExecutionChain",slug:"abstracthandlermapping获取handlerexecutionchain",normalizedTitle:"abstracthandlermapping获取handlerexecutionchain",charIndex:9003},{level:2,title:"AbstractHandlerMethodMapping<T>",slug:"abstracthandlermethodmapping-t",normalizedTitle:"abstracthandlermethodmapping<t>",charIndex:10855},{level:3,title:"RequestMappingHandlerMapping中的初始化",slug:"requestmappinghandlermapping中的初始化",normalizedTitle:"requestmappinghandlermapping中的初始化",charIndex:11181},{level:3,title:"MappingRegistry",slug:"mappingregistry",normalizedTitle:"mappingregistry",charIndex:23337},{level:3,title:"RequestMappingInfoHandlerMapping中获取handler",slug:"requestmappinginfohandlermapping中获取handler",normalizedTitle:"requestmappinginfohandlermapping中获取handler",charIndex:29297},{level:3,title:"AbstractHandlerMethodMapping中获取handler",slug:"abstracthandlermethodmapping中获取handler",normalizedTitle:"abstracthandlermethodmapping中获取handler",charIndex:29862},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:30576},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:13924}],excerpt:"<p>当Servlet容器接收到请求时，会根据请求路径找到所映射的Servlet，然后调用其<code>service()</code>方法。在SpringMVC中，我们只配置了单一的<code>DispatcherServlet</code>，在其父类<code>FrameworkServlet</code>中重写了<code>service()</code>方法，然后在<code>processRequest()</code>方法内部调用了<code>HttpServlet</code>所定义的<code>doService()</code>方法，<code>DispatcherServlet</code>重写了该方法，然后在调用同一个类中的<code>doDispatch()</code>方法。在该方法中，调用了<code>getHandler()</code>方法获取该请求对应的<code>Handler</code>以及与该请求相关的<code>HandlerInterceptor</code>，SpringMVC将两者封装为<code>HandlerExecutionChain</code>。本文分析与<code>HandlerMapping</code>有关的内容。</p>\n",lastUpdated:"2021-01-14",headersStr:"注册HandlerMapping 获取HandlerExecutionChain HandlerMapping体系 AbstractHandlerMapping中的初始化 AbstractHandlerMapping获取HandlerExecutionChain AbstractHandlerMethodMapping<T> RequestMappingHandlerMapping中的初始化 MappingRegistry RequestMappingInfoHandlerMapping中获取handler AbstractHandlerMethodMapping中获取handler 总结 参考",content:'当Servlet容器接收到请求时，会根据请求路径找到所映射的Servlet，然后调用其service()方法。在SpringMVC中，我们只配置了单一的DispatcherServlet，在其父类FrameworkServlet中重写了service()方法，然后在processRequest()方法内部调用了HttpServlet所定义的doService()方法，DispatcherServlet重写了该方法，然后在调用同一个类中的doDispatch()方法。在该方法中，调用了getHandler()方法获取该请求对应的Handler以及与该请求相关的HandlerInterceptor，SpringMVC将两者封装为HandlerExecutionChain。本文分析与HandlerMapping有关的内容。\n\n注意\n\n本文中的Spring源码版本为5.3.2，不过本文中涉及的大部分内容相比之前版本都是大同小异。另外，本文中所展示的源码可能会有些删减，避免冗长。\n\n# 注册HandlerMapping\n在DispatcherServlet初始化时，会调用initStrategies()方法，该方法包含了对各种组件的初始化，本文重点关注initHanlderMappings()方法。\n\n// DispatcherServlet#initHandlerMappings()\nprivate void initHandlerMappings(ApplicationContext context) {\n    this.handlerMappings = null;\n    /*\n    this.detectAllHandlerMappings 默认为true，即默认情况下需要探测所有的HandlerMapping。\n    */\n    if (this.detectAllHandlerMappings) {\n        /*\n        在当前容器以及其父容器中找HandlerMapping，不过我们一般不会自定义HandlerMapping，所以matchingBeans.isEmpty() == true大部分时候成立，无需重点关注这种情况。\n      \t*/\n        Map<String, HandlerMapping> matchingBeans =\n            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);\n        if (!matchingBeans.isEmpty()) {\n            this.handlerMappings = new ArrayList<>(matchingBeans.values());\n            // We keep HandlerMappings in sorted order.\n            AnnotationAwareOrderComparator.sort(this.handlerMappings);\n        }\n    }\n    else {\n        try {\n            /*\n            判断容器中是否有名称为handlerMapping的bean，一般不会有这种情况，无需重点关注。\n            */\n            HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);\n            this.handlerMappings = Collections.singletonList(hm);\n        }\n        catch (NoSuchBeanDefinitionException ex) {}\n    }\n    /*\n    一般情况下，我们使用SpringMVC默认的HandlerMapping就足够了，所以重点关注该分支。\n    */\n    if (this.handlerMappings == null) {\n        /*\n        通过getDefaultStrategies()获取默认的HandlerMapping，请重点关注该方法，后序组件分析中也会提及到该方法。\n        将返回的HandlerMapping列表保存到DispatcherServlet对象的handlerMappings属性中，当解析请求时，会访问该属性。\n        */\n        this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);\n    }\n    for (HandlerMapping mapping : this.handlerMappings) {\n        /*是否需要进行路径模式匹配*/\n        if (mapping.usesPathPatterns()) {\n            this.parseRequestPath = true;\n            break;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n// DispatcherServlet#getDefaultStrageties()\n/*\nstrategyInterface表示需要获取哪种类型的默认策略，在本文中，这里指的是HandlerMapping。\n*/\nprotected <T> List<T> getDefaultStrategies(ApplicationContext context, Class<T> strategyInterface) {\n    /*\n    SpringMVC中所有组件的默认初始化策略都会通过该方法获取。默认策略保存在一个属性文件中，该文件的路径名为：\t\torg.springframework.web.servlet.DispatcherServlet.properties。\n    如果是第一次调用该方法，defaultStrategies当然为null，所以会读取上述文件，并保存到defaultStrategies中。后序调用就不会再读取文件。\n    */\n    if (defaultStrategies == null) {\n        try {\n            /*\n            DEFAULT_STRATEGIES_PATH的值为DispatcherServlet.properties\n            */\n            ClassPathResource resource = new ClassPathResource(DEFAULT_STRATEGIES_PATH, DispatcherServlet.class);\n            defaultStrategies = PropertiesLoaderUtils.loadProperties(resource);\n        }\n        catch (IOException ex) {}\n    }\n\n    /*\n    这里从属性文件获取到HandlerMapping的默认策略，其内容为：org.springframework.web.servlet.HandlerMapping=org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\\\n\torg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping,\\\n\torg.springframework.web.servlet.function.support.RouterFunctionMapping\n\t也就是说，默认情况下会定义这三种HandlerMapping，后面会重点分析RequestMappingHandlerMapping，因为这是我们用得最多的一种情况。\n    */\n    String key = strategyInterface.getName();\n    String value = defaultStrategies.getProperty(key);\n    if (value != null) {\n        /*\n        将逗号分隔字符串转化为字符串数组\n        */\n        String[] classNames = StringUtils.commaDelimitedListToStringArray(value);\n        List<T> strategies = new ArrayList<>(classNames.length);\n        for (String className : classNames) {\n            try {\n                Class<?> clazz = ClassUtils.forName(className, DispatcherServlet.class.getClassLoader());\n                /* \n                创建每一个默认的HandlerMapping组件，然后将其暂存到strategies列表中，最后统一返回。\n                */\n                Object strategy = createDefaultStrategy(context, clazz);\n                strategies.add((T) strategy);\n            }\n            catch (ClassNotFoundException ex) {} catch (LinkageError err) {}\n        }\n        return strategies;\n    }\n    else {\n        return Collections.emptyList();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n上面分析到会创建默认的HandlerMapping组件并保存到DispatcherServlet实例的属性中。这个过程看似很简单，但是真正重要的部分还没有开始。\n\n# 获取HandlerExecutionChain\n注意\n\n如果还不熟悉Handler的注册过程，可先跳过这部分内容。\n\n在SpringMVC中，将HandlerMapping和HandlerInterceptor结合在一起形成了HandlerExectutionChain，在DispatcherServlet#doDispatch()方法中调用了getHandler()方法。\n\n// DispatcherServlet#getHandler()\n@Nullable\nprotected HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n    /* this.handlerMappings已经在上面注册的过程中进行了赋值 */\n    if (this.handlerMappings != null) {\n        /* 依次遍历每一个HandlerMapping */\n        for (HandlerMapping mapping : this.handlerMappings) {\n            /* \n            调用HandlerMapping接口定义的getHandler()方法，具体逻辑有子类实现\n            */\n            HandlerExecutionChain handler = mapping.getHandler(request);\n            if (handler != null) {\n                return handler;\n            }\n        }\n    }\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# HandlerMapping体系\n下面先来分析一下HandlerMapping体系，如下图所示（有删减）：\n\n\n\n可见，HandlerMapping体系分为两派，一派基于AbstractHandlerMapping，另一派基于AbstractUrlHandlerMapping，两派都继承于AbstractHandlerMapping。\n\nAbstractHandlerMapping采用模板模式涉及了HanlderMapping的整体结构，HandlerMapping的作用是根据request查找Handler和Interceptor，AbstractHandlerMapping定义了获取Handler的模板方法getHandlerInternal()，交由子类实现，但是自己处理Interceptor。\n\n首先需要找到分析的入口。请仔细注意在其父类中，AbstractHandlerMapping实现了WebApplicationObjectSupport从而间接实现了ApplicationContextAware接口，AbstractHandlerMethodMapping实现了InitializingBean接口。根据Spring Bean的声明周期，在创建RequestMappingHandlerMapping实例时，会调用上述两个声明周期接口中相应的方法，而且先执行setApplicationContext()方法，然后再执行afterPropertiesSet()方法。\n\n# AbstractHandlerMapping中的初始化\n根据方法调用链，AbstractHandlerMapping中的initApplicationContext()方法会被调用。\n\n// AbstractHandlerMapping#initApplicationContext()\n@Override\nprotected void initApplicationContext() throws BeansException {\n    /* extendInterceptors()方法是一个在源码中是一个空方法，算是Spring提供的一个扩展点 */\n    extendInterceptors(this.interceptors);\n    /*\n    detectMappedInterceptors() 方法的作用是将SpringMVC容器及其父容器中的所有MappedInterceptor类型的拦截器添加到adaptedInterceptors属性中，因为MappedInterceptor是HandlerInerceptor的子实现类。\n    */\n    detectMappedInterceptors(this.adaptedInterceptors);\n    /*\n    initInterceptors()方法的作用是初始化Interceptor，具体内容是将interceptors属性里包含的对象按类型添加到mappedInterceptors或者adaptedInterceptors。\n    */\n    initInterceptors();\n}\n\nprotected void detectMappedInterceptors(List<HandlerInterceptor> mappedInterceptors) {\n    mappedInterceptors.addAll(BeanFactoryUtils.beansOfTypeIncludingAncestors(\n        obtainApplicationContext(), MappedInterceptor.class, true, false).values());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n上面提到AbstractHandlerMapping中的几个属性：\n\n/*\ninterceptors属性保存了我们在SpringMVC配置的拦截器，注意泛型参数是Object的，因为SpringMVC中目前有两种拦截器：\nHandlerInterceptor和WebRequestInterceptor，后者与异步请求有关，暂时没有使用过。\n*/\nprivate final List<Object> interceptors = new ArrayList<>();\n/*\n经过适配后的拦截器，注意泛型参数是HandlerInterceptor，所以当拦截器类型为WebRequestInterceptor时，需要使用WebRequestHandlerInterceptorAdapter进行适配。getHandlerInternal()返回的HandlerExecutionChain中包含的拦截器就是adaptedInterceptors中的。\n*/\nprivate final List<HandlerInterceptor> adaptedInterceptors = new ArrayList<>();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n// AbstractHandlerMapping#initInterceptors()\nprotected void initInterceptors() {\n    if (!this.interceptors.isEmpty()) {\n        for (int i = 0; i < this.interceptors.size(); i++) {\n            Object interceptor = this.interceptors.get(i);\n            if (interceptor == null) {\n                throw new IllegalArgumentException("Entry number " + i + " in interceptors array is null");\n            }\n            /*\n            调用adaptInterceptor适配拦截器，并将适配后的对象加入adaptedInterceptors中。\n            */\n            this.adaptedInterceptors.add(adaptInterceptor(interceptor));\n        }\n    }\n}\n\n/* 实现逻辑很简单，就不再赘述了 */\nprotected HandlerInterceptor adaptInterceptor(Object interceptor) {\n    if (interceptor instanceof HandlerInterceptor) {\n        return (HandlerInterceptor) interceptor;\n    }\n    else if (interceptor instanceof WebRequestInterceptor) {\n        return new WebRequestHandlerInterceptorAdapter((WebRequestInterceptor) interceptor);\n    }\n    else {\n        throw new IllegalArgumentException("Interceptor type not supported: " + interceptor.getClass().getName());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n# AbstractHandlerMapping获取HandlerExecutionChain\n// AbstractHandlerMapping#HandlerExecutionChain\n@Override\n@Nullable\npublic final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception {\n    /* 获取handler, 由子类实现 */\n    Object handler = getHandlerInternal(request);\n    if (handler == null) {\n        /* 如果当前请求没有对应的handler，则设置为默认的handler */\n        handler = getDefaultHandler();\n    }\n    if (handler == null) {\n        return null;\n    }\n    // Bean name or resolved handler?\n    if (handler instanceof String) {\n        String handlerName = (String) handler;\n        handler = obtainApplicationContext().getBean(handlerName);\n    }\n\n    /* 获取HandlerExecutionChain并返回，后序操作这里有删减 */\n    HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request);\n    return executionChain;\n}\n\n// AbstractHandlerMapping#getHandlerExecutionChain\nprotected HandlerExecutionChain getHandlerExecutionChain(Object handler, HttpServletRequest request) {\n    HandlerExecutionChain chain = (handler instanceof HandlerExecutionChain ?\n                                   (HandlerExecutionChain) handler : new HandlerExecutionChain(handler));\n\n    /* 遍历所有适配后的拦截器 */\n    for (HandlerInterceptor interceptor : this.adaptedInterceptors) {\n        if (interceptor instanceof MappedInterceptor) {\n            MappedInterceptor mappedInterceptor = (MappedInterceptor) interceptor;\n            /* 判断拦截器是否匹配请求 */\n            if (mappedInterceptor.matches(request)) {\n                /* 将匹配的拦截器加入HandlerExecutionChain中 */\n                chain.addInterceptor(mappedInterceptor.getInterceptor());\n            }\n        }\n        else {\n            chain.addInterceptor(interceptor);\n        }\n    }\n    return chain;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n# AbstractHandlerMethodMapping<T>\n该抽象类是继承AbstractHandleMapping的两大阵营之一，定义一个请求和一个HandlerMethod（顾名思义，将方法作为Handler）之间的关系，提供了handlerMapping的初始化，注册和获取等模板方法。\n\n提示\n\nHandlerMethod将Method和Bean封装在一起，便于调用，因为反射调用的时候需要执行的对象。\n\n注意泛型T表示Mapping类型，如我们常用的@RequestMapping对应的泛型实参是RequestMappingInfo。如果我们想自定义类似@RequestMapping的注解，那么就可以在实现时提供不同的泛型实参。\n\n# RequestMappingHandlerMapping中的初始化\n上面我们说到，RequestMappingHandlerMapping是我们常使用的，当我们在controller类中使用@RequestMapping注解或基于该注解的其他REST风格的注解时，SpringMVC会使用该类型的handlerMapping。\n\nRequestMappingHandlerMapping中重写了AbstractHandlerMethodMapping中的afterPropertiesSet()方法。\n\n// RequestMappingHandlerMapping#afterPropertiesSet()\n@Override\n@SuppressWarnings("deprecation")\npublic void afterPropertiesSet() {\n\n    this.config = new RequestMappingInfo.BuilderConfiguration();\n    this.config.setTrailingSlashMatch(useTrailingSlashMatch());\n    this.config.setContentNegotiationManager(getContentNegotiationManager());\n\n    if (getPatternParser() != null) {\n        this.config.setPatternParser(getPatternParser());\n        Assert.isTrue(!this.useSuffixPatternMatch && !this.useRegisteredSuffixPatternMatch,\n                      "Suffix pattern matching not supported with PathPatternParser.");\n    }\n    else {\n        this.config.setSuffixPatternMatch(useSuffixPatternMatch());\n        this.config.setRegisteredSuffixPatternMatch(useRegisteredSuffixPatternMatch());\n        this.config.setPathMatcher(getPathMatcher());\n    }\n\t\n    // 调用父类AbstractHandlerMethodMapping的afterPropertiesSet()方法\n    super.afterPropertiesSet();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nAbstractHandlerMethodMapping的afterPropertiesSet()方法内部直接调用了其内部的initHandlerMethods()方法。\n\n// AbstractHandlerMethodMapping#initHandlerMethods()\nprotected void initHandlerMethods() {\n    for (String beanName : getCandidateBeanNames()) {\n        /*\n        如果bean的名称以scopedTarget开头，那么则不处理，\n        目的是排除CGLIB代理的bean，原因是代理bean的方法上没有@RequestMapping注解\n        */\n        if (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) {\n            processCandidateBean(beanName);\n        }\n    }\n    handlerMethodsInitialized(getHandlerMethods());\n}\n\n// AbstractHandlerMethodMapping#getCandidateBeanNames()\n/* 返回所有的候选Bean的名称*/\nprotected String[] getCandidateBeanNames() {\n    /*\n    detectHandlerMethodsInAncestorContexts表示是否探测父容器内的bean，默认为false\n    */\n    return (this.detectHandlerMethodsInAncestorContexts ?\n            BeanFactoryUtils.beanNamesForTypeIncludingAncestors(obtainApplicationContext(), Object.class) :\n            obtainApplicationContext().getBeanNamesForType(Object.class));\n}\n\n// AbstractHandlerMethodMapping#processCandidateBean\n/* 处理候选bean */\nprotected void processCandidateBean(String beanName) {\n    Class<?> beanType = null;\n    try {\n        beanType = obtainApplicationContext().getType(beanName);\n    }\n    catch (Throwable ex) {\n        // An unresolvable bean type, probably from a lazy bean - let\'s ignore it.\n        if (logger.isTraceEnabled()) {\n            logger.trace("Could not resolve type for bean \'" + beanName + "\'", ex);\n        }\n    }\n    // isHandler()方法参考下面的讲解\n    if (beanType != null && isHandler(beanType)) {\n        detectHandlerMethods(beanName);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n上面的isHandler()在AbstractMethodHandlerMapping中是一个模板方法，对于一个bean，是否是handler应该有具体的子类来实现，对于RequestMappingHandlerMapping中的实现如下：\n\n// RequestMappingHandlerMapping#isHandler()\n@Override\nprotected boolean isHandler(Class<?> beanType) {\n    /*\n    该bean是否由@Controller或者是@RequestMapping修饰\n    */\n    return (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) ||\n            AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n继续来看detectHandlerMethods()方法：\n\n// AbstractMethodHandlerMapping#detectHandlerMethods()\n/* \n该方法顾名思义，就是探测处理器中的方法\n*/\nprotected void detectHandlerMethods(Object handler) {\n    Class<?> handlerType = (handler instanceof String ?\n                            obtainApplicationContext().getType((String) handler) : handler.getClass());\n\n    if (handlerType != null) {\n        Class<?> userType = ClassUtils.getUserClass(handlerType);\n        /*\n        methods中保存了当前handler中满足要求的方法与T（这里主要指RequestMappingInfo）之间的关系。\n        selectMethods的第二个参数的是元数据解析器，具体细节请参考下文\n        */\n        Map<Method, T> methods = MethodIntrospector.selectMethods(userType,\n            (MethodIntrospector.MetadataLookup<T>) method -> {\n                try {\n                    return getMappingForMethod(method, userType);\n                }\n                catch (Throwable ex) {\n                    throw new IllegalStateException("Invalid mapping on handler class [" +\n                                                    userType.getName() + "]: " + method, ex);\n                }\n            });\n        if (logger.isTraceEnabled()) {\n            logger.trace(formatMappings(userType, methods));\n        }\n        /*\n        遍历method和mapping，然后进行注册操作\n        */\n        methods.forEach((method, mapping) -> {\n            /* 获取代理后的bean的方法 */\n            Method invocableMethod = AopUtils.selectInvocableMethod(method, userType);\n            /* 进行注册HandlerMethod，具体细节请参考下文 */\n            registerHandlerMethod(handler, invocableMethod, mapping);\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n上面的方法中调用了MethodIntrospector#selectMethods()：\n\n// MethodIntrospector#selectMethods()\npublic static <T> Map<Method, T> selectMethods(Class<?> targetType, final MetadataLookup<T> metadataLookup) {\n    /* methodMap暂存了targetType中method和mapping（对于RequestMappingHandlerMapping是RequestMappingInfo）的对应关系，最后将该map返回 */\n    final Map<Method, T> methodMap = new LinkedHashMap<>();\n    /* 保存了targetType以及实现的接口 */\n    Set<Class<?>> handlerTypes = new LinkedHashSet<>();\n    /* 具体的实现类，如果targetType是JDK动态代理的类型的话，那么将仍然为null */\n    Class<?> specificHandlerType = null;\n    /*\n    排除JDK动态代理bean的情况\n    */\n    if (!Proxy.isProxyClass(targetType)) {\n        specificHandlerType = ClassUtils.getUserClass(targetType);\n        handlerTypes.add(specificHandlerType);\n    }\n    /* 添加所有的接口 */\n    handlerTypes.addAll(ClassUtils.getAllInterfacesForClassAsSet(targetType));\n\n    /*循环处理每一个类型*/\n    for (Class<?> currentHandlerType : handlerTypes) {\n        final Class<?> targetClass = (specificHandlerType != null ? specificHandlerType : currentHandlerType);\n        /* 处理当前类型中的方法 */\n        ReflectionUtils.doWithMethods(currentHandlerType, method -> {\n            /* \n            获取与该方法相关的最具体的方法 \n            意思就是如果该方法位于父类型中，那么获取子类中的对应的重写或实现\n            */\n            Method specificMethod = ClassUtils.getMostSpecificMethod(method, targetClass);\n            /*\n            获取该方法上的元数据（对于RequestMappingHandlerMapping是解析@RequestMapping注解），获的解析后的mapping（对于RequestMappingHandlerMapping是RequestMappingInfo）\n            */\n            T result = metadataLookup.inspect(specificMethod);\n            /* 对于RequestMappingHandlerMapping，如果result != null成立，则说明方法上有@RequestMapping注解 */\n            if (result != null) {\n                /* 处理桥接方法，可以Google一下什么是桥接方法 */\n                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(specificMethod);\n                if (bridgedMethod == specificMethod || metadataLookup.inspect(bridgedMethod) == null) {\n                    methodMap.put(specificMethod, result);\n                }\n            }\n            /* USER_DECLARED_METHODS表示方法过滤器，过滤规则为排除桥接方法和合成方法，同样地，可以Google一下什么是合成方法 */\n        }, ReflectionUtils.USER_DECLARED_METHODS);\n    }\n    return methodMap;\n}\n\n// ReflectionUtils#doWithMethods()\n/*\nclazz就是目标类型，表示要处理哪个类型中的方法\nmf表示方法的过滤器，表示哪些方法才是符合匹配要求的\nmc表示方法满足要求时执行的回调\n*/\npublic static void doWithMethods(Class<?> clazz, MethodCallback mc, @Nullable MethodFilter mf) {\n    // Keep backing up the inheritance hierarchy.\n    Method[] methods = getDeclaredMethods(clazz, false);\n    for (Method method : methods) {\n        if (mf != null && !mf.matches(method)) {\n            continue;\n        }\n        try {\n            /* 执行方法匹配回调 */\n            mc.doWith(method);\n        }\n        catch (IllegalAccessException ex) {\n            throw new IllegalStateException("Not allowed to access method \'" + method.getName() + "\': " + ex);\n        }\n    }\n    if (clazz.getSuperclass() != null && (mf != USER_DECLARED_METHODS || clazz.getSuperclass() != Object.class)) {\n        /* 递归处理父类中的方法*/\n        doWithMethods(clazz.getSuperclass(), mc, mf);\n    }\n    else if (clazz.isInterface()) {\n        for (Class<?> superIfc : clazz.getInterfaces()) {\n            /* 递归处理父接口中的方法*/\n            doWithMethods(superIfc, mc, mf);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n现在也获取到了handler中的所有非桥接和非合成方法了，接下来是要解析方法中的元数据，在上面AbstractMehtodHandlerMapping#detectHandlerMethods()方法中，以lambda的方式传递给MethodIntrospector#selectMethods()方法了一个MetadataLookup类型的实例，在lambda表达式中调用了AbstractMehtodHandlerMapping#getMappingForMethod()方法，同样地，该方法是一个模板方法，具体逻辑由子类实现（因为这里的元数据指的是什么，是泛型参数T决定的，具体是什么应该由子类决定，所以元数据的解析也应该让子类进行）。\n\n// RequestMappingHandlerMapping#getMappingForMethod()\n@Override\n@Nullable\nprotected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n    /* \n    创建RequestMappingInfo，如果method由@RequestMapping修饰，那么则返回一个非null对象\n    */\n    RequestMappingInfo info = createRequestMappingInfo(method);\n    if (info != null) {\n        RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);\n        if (typeInfo != null) {\n            info = typeInfo.combine(info);\n        }\n        String prefix = getPathPrefix(handlerType);\n        if (prefix != null) {\n            info = RequestMappingInfo.paths(prefix).options(this.config).build().combine(info);\n        }\n    }\n    return info;\n}\n\n// RequestMappingHandlerMapping#createRequestMappingInfo(),注意重载\n@Nullable\nprivate RequestMappingInfo createRequestMappingInfo(AnnotatedElement element) {\n    /* 查询@RequestMapping或该注解的合并注解（如@GetMapping）*/\n    RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class);\n    /* 获取自定义的条件，但是目前为空方法，可以忽视 */\n    RequestCondition<?> condition = (element instanceof Class ?\n                                     getCustomTypeCondition((Class<?>) element) : getCustomMethodCondition((Method) element));\n    /* 基于注解，创建RequestMappingInfo对象 */\n    return (requestMapping != null ? createRequestMappingInfo(requestMapping, condition) : null);\n}\n\n// RequestMappingHandlerMapping#createRequestMappingInfo(),注意重载\nprotected RequestMappingInfo createRequestMappingInfo(\n    RequestMapping requestMapping, @Nullable RequestCondition<?> customCondition) {\n\n    /*\n    创建RequestMappingInfo.Builder对象，并设置属性，这些属性就是通过@RequestMapping注解设置的。\n    这里顺便回忆一下各种属性的含义:\n    name 当前映射的名称，只是个名称而已，别误认为也表示url\n    value和path互为别名，因为Java中注解的value值可以直接进行赋值，不用写属性名（只为value赋值时），表示url; 注意，如果同时指定了value和path，但是值却不一致，则会抛出AnnotationConfigurationException异常：Different @AliasFor mirror values for annotation RequestMapping。\n    method 表示HTTP请求的方法\n    headers 表示请求头映射要求，具体写法为{header1=value1, header2=value2}，value中可以使用通配符\n    params 表示请求参数所应满足的条件\n    consumers 表示请求头部中Content-Type字段应满足什么条件\n    produces 表示请求头部中Accept字段应满足什么条件\n    */\n    RequestMappingInfo.Builder builder = RequestMappingInfo\n        .paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))\n        .methods(requestMapping.method())\n        .params(requestMapping.params())\n        .headers(requestMapping.headers())\n        .consumes(requestMapping.consumes())\n        .produces(requestMapping.produces())\n        .mappingName(requestMapping.name());\n    if (customCondition != null) {\n        builder.customCondition(customCondition);\n    }\n    /*\n    this.config是一个RequestMappingInfo.BuilderConfiguration类型的属性，具体构建的代码就不分析了，只知道返回一个RequestMappingInfo和对应的Method一并存入map中就可以了。\n    */\n    return builder.options(this.config).build();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n接下来，在AbstractMethodHandlerMapping#detectHandlerMethods()方法的末尾，调用了registerHandlerMethod()方法。\n\n/* AbstractMethodHandler#registerHandlerMethod */\nprotected void registerHandlerMethod(Object handler, Method method, T mapping) {\n    /* this.mappingRegistry的类型是AbstractMethodHandler.MappingRegistry */\n    this.mappingRegistry.register(mapping, handler, method);\n}\n\n\n1\n2\n3\n4\n5\n# MappingRegistry\n关于MappingRegistry，有下面几个属性（不要纠结为什么会有这么几个属性，只关心SpringMVC是怎么处理的就可以了）：\n\n/* 注册表 */\nprivate final Map<T, MappingRegistration<T>> registry = new HashMap<>();\n/* Mapping 的路径与 HandlerMethod 的映射 */\nprivate final MultiValueMap<String, T> pathLookup = new LinkedMultiValueMap<>();\n/* Mapping 的名字与 HandlerMethod 的映射 */\nprivate final Map<String, List<HandlerMethod>> nameLookup = new ConcurrentHashMap<>();\n/* 跨域相关，本文暂时不讨论 */\nprivate final Map<HandlerMethod, CorsConfiguration> corsLookup = new ConcurrentHashMap<>();\n/* 读写锁 */\nprivate final ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n提示\n\n在继续往下分析之前，先来搞清楚MappingRegistry和MappingRegistration是什么关系。\n\nMappingRegistration表示了mapping和handlerMethod之间的关系。而MappingRegistry保存了mapping和MappingRegistration之间的关系。如果把MappingRegistry看成一个表，那么MappingRegistration则是表中的每一项。\n\n下面来看上面调用的register()方法：\n\n// AbstractMethodHandlerMapping.MappingRegistry#register()\npublic void register(T mapping, Object handler, Method method) {\n    /* 加写锁 */\n    this.readWriteLock.writeLock().lock();\n    try {\n        /* 创建HandlerMethod，将handler和method绑定在一起 */\n        HandlerMethod handlerMethod = createHandlerMethod(handler, method);\n        /* 严重handlerMethod的合法性 */\n        validateMethodMapping(handlerMethod, mapping);\n\t\t\n        /* \n        获取直接路径, 直接路径是指非模式路径\n        直接路径： @GetMapping("/users")\n        模式路径： @GetMapping("/user/{id}")\n        */\n        Set<String> directPaths = AbstractHandlerMethodMapping.this.getDirectPaths(mapping);\n        for (String path : directPaths) {\n            /* \n            保存直接路径与mapping的关系，因为同一路径可以映射到不同mapping，所以要使用MultiValueMap\n            */\n            this.pathLookup.add(path, mapping);\n        }\n\n        String name = null;\n        if (getNamingStrategy() != null) {\n            name = getNamingStrategy().getName(handlerMethod, mapping);\n            /* 保存名称与HandlerMethod的关系 */\n            addMappingName(name, handlerMethod);\n        }\n\n        /* 跨域设置，暂时忽略 */\n        CorsConfiguration config = initCorsConfiguration(handler, method, mapping);\n        if (config != null) {\n            config.validateAllowCredentials();\n            this.corsLookup.put(handlerMethod, config);\n        }\n\n        /* 将”表项“加入”表“中 */\n        this.registry.put(mapping, new MappingRegistration<>(mapping, handlerMethod, directPaths, name));\n    }\n    finally {\n        /* 释放写锁 */\n        this.readWriteLock.writeLock().unlock();\n    }\n}\n\n// AbstractMethodHandlerMapping.MappingRegistry#validateMethodMapping()\nprivate void validateMethodMapping(HandlerMethod handlerMethod, T mapping) {\n    /* 获取当前mapping对应的MappingRegistration */\n    MappingRegistration<T> registration = this.registry.get(mapping);\n    /* 获取当前mapping对应的MappingRegistration中保存的HandlerMethod */\n    HandlerMethod existingHandlerMethod = (registration != null ? registration.getHandlerMethod() : null);\n    /*\n    判断当前mapping是否已经存在handlerMethod，如果已经存在且不是当前的handlerMethod,则抛出异常。\n    这也是为什么有时我们在不同的@RequestMapping注解中设置了相同的URL后，会抛出下列异常，原因是我们在不同的method上设置了两个完全一样的mapping。\n    */\n    if (existingHandlerMethod != null && !existingHandlerMethod.equals(handlerMethod)) {\n        throw new IllegalStateException(\n            "Ambiguous mapping. Cannot map \'" + handlerMethod.getBean() + "\' method \\n" +\n            handlerMethod + "\\nto " + mapping + ": There is already \'" +\n            existingHandlerMethod.getBean() + "\' bean method\\n" + existingHandlerMethod + " mapped.");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n为了方便，将获取逻辑的分析一并写在这一节。\n\nMappingRegistry中lookupHandlerMethod()方法中实现了查询逻辑：\n\n// AbstractHandlerMethodMapping.MappingRegistry#lookupHandlerMethod()\n@Nullable\nprotected HandlerMethod lookupHandlerMethod(String lookupPath, HttpServletRequest request) throws Exception {\n    /* 当前请求的匹配列表 */\n    List<Match> matches = new ArrayList<>();\n    /* 获取与直接路径匹配的mapping */\n    List<T> directPathMatches = this.mappingRegistry.getMappingsByDirectPath(lookupPath);\n    if (directPathMatches != null) {\n        addMatchingMappings(directPathMatches, matches, request);\n    }\n    /* 如果没有与直接路径相关的mapping，则获取所有的mappings，然后再进行匹配 */\n    if (matches.isEmpty()) {\n        addMatchingMappings(this.mappingRegistry.getRegistrations().keySet(), matches, request);\n    }\n    if (!matches.isEmpty()) {\n        Match bestMatch = matches.get(0);\n        if (matches.size() > 1) {\n            /* mapping匹配比较器 */\n            Comparator<Match> comparator = new MatchComparator(getMappingComparator(request));\n            matches.sort(comparator);\n            bestMatch = matches.get(0);\n            if (CorsUtils.isPreFlightRequest(request)) {\n                return PREFLIGHT_AMBIGUOUS_MATCH;\n            }\n            Match secondBestMatch = matches.get(1);\n            /* 如果最佳匹配和第二匹配优先级一样高，则说明配置有误，则抛出异常 */\n            if (comparator.compare(bestMatch, secondBestMatch) == 0) {\n                Method m1 = bestMatch.handlerMethod.getMethod();\n                Method m2 = secondBestMatch.handlerMethod.getMethod();\n                String uri = request.getRequestURI();\n                throw new IllegalStateException(\n                    "Ambiguous handler methods mapped for \'" + uri + "\': {" + m1 + ", " + m2 + "}");\n            }\n        }\n        request.setAttribute(BEST_MATCHING_HANDLER_ATTRIBUTE, bestMatch.handlerMethod);\n        /* 处理首个Match对象 */\n        handleMatch(bestMatch.mapping, lookupPath, request);\n        /* 返回最佳匹配关联的HandlerMethod */\n        return bestMatch.handlerMethod;\n    }\n    else {\n        /* 处理没有匹配的情况 */\n        return handleNoMatch(this.mappingRegistry.getRegistrations().keySet(), lookupPath, request);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n# RequestMappingInfoHandlerMapping中获取handler\nRequestMappingInfoHandlerMapping重写了父类AbstractHandlerMethodMapping中的getHandlerInternal()方法。\n\n// RequestMappingInfoHandlerMapping#getHandlerInternal()\n@Override\nprotected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception {\n    request.removeAttribute(PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE);\n    try {\n        /* 调用父类的该方法 */\n        return super.getHandlerInternal(request);\n    }\n    finally {\n        ProducesRequestCondition.clearMediaTypesAttribute(request);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# AbstractHandlerMethodMapping中获取handler\n// AbstractHandlerMethodMapping#getHandlerInternal()\n@Override\nprotected HandlerMethod getHandlerInternal(HttpServletRequest request) throws Exception {\n    /* 初始化查询路径 */\n    String lookupPath = initLookupPath(request);\n    /* 获取读锁 */\n    this.mappingRegistry.acquireReadLock();\n    try {\n        /* 获取HandlerMethod，请参考上文MappingRegistry节中关于lookupHandlerMethod的讲解 */\n        HandlerMethod handlerMethod = lookupHandlerMethod(lookupPath, request);\n        return (handlerMethod != null ? handlerMethod.createWithResolvedBean() : null);\n    }\n    finally {\n        /* 释放读锁 */\n        this.mappingRegistry.releaseReadLock();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# 总结\n本文已分析了大部分关于HandlerMapping的内容，只分析了AbstractHandlerMethodMapping这一派系，因为这是最常使用的。\n\n关于HandlerMapping可以分为两部分，初始化和获取。初始化是在Servlet容器初始化DispatcherServlet时进行的，而获取是在请求到来时进行的。\n\nHandlerExecutionChain包含了HandlerMethod和HandlerInterceptor，关于后者的初始化是由HandlerMapping的直接实现类AbstractHandlerMapping进行的，而前者由各个子类进行。对于AbstractHandlerMethodMapping，主要的逻辑还是在其自身内实现的，其子类RequestMappingInfoHandlerMapping以RequestMappingInfo作为mapping类型。所有的handlerMapping保存在了AbstractHandlerMethodMapping中的内部类MappingRegistry中，该内部类定义了注册和获取HandlerMapping的逻辑。MappingRegistry就像是一张注册表一样，其中每一项类型为MappingRegistration。\n\n本文关于获取HandlerMapping的具体匹配逻辑没有进行深入的分析，只是讲到了直接路径的匹配，路径中有参数等情况没有涉及，后面有时间再补充吧。\n\n获取到了HandlerExecutionChain只是请求在DispatcherServlet中的第一步，后面还有大量的操作（比如HandlerAdapter）才能完成一个请求。\n\n# 参考\n * SpringMVC源码分析三、组件一HandlerMapping源码分析\n * 精尽Spring MVC源码分析 - HandlerMapping 组件（三）之 AbstractHandlerMethodMapping',normalizedContent:'当servlet容器接收到请求时，会根据请求路径找到所映射的servlet，然后调用其service()方法。在springmvc中，我们只配置了单一的dispatcherservlet，在其父类frameworkservlet中重写了service()方法，然后在processrequest()方法内部调用了httpservlet所定义的doservice()方法，dispatcherservlet重写了该方法，然后在调用同一个类中的dodispatch()方法。在该方法中，调用了gethandler()方法获取该请求对应的handler以及与该请求相关的handlerinterceptor，springmvc将两者封装为handlerexecutionchain。本文分析与handlermapping有关的内容。\n\n注意\n\n本文中的spring源码版本为5.3.2，不过本文中涉及的大部分内容相比之前版本都是大同小异。另外，本文中所展示的源码可能会有些删减，避免冗长。\n\n# 注册handlermapping\n在dispatcherservlet初始化时，会调用initstrategies()方法，该方法包含了对各种组件的初始化，本文重点关注inithanldermappings()方法。\n\n// dispatcherservlet#inithandlermappings()\nprivate void inithandlermappings(applicationcontext context) {\n    this.handlermappings = null;\n    /*\n    this.detectallhandlermappings 默认为true，即默认情况下需要探测所有的handlermapping。\n    */\n    if (this.detectallhandlermappings) {\n        /*\n        在当前容器以及其父容器中找handlermapping，不过我们一般不会自定义handlermapping，所以matchingbeans.isempty() == true大部分时候成立，无需重点关注这种情况。\n      \t*/\n        map<string, handlermapping> matchingbeans =\n            beanfactoryutils.beansoftypeincludingancestors(context, handlermapping.class, true, false);\n        if (!matchingbeans.isempty()) {\n            this.handlermappings = new arraylist<>(matchingbeans.values());\n            // we keep handlermappings in sorted order.\n            annotationawareordercomparator.sort(this.handlermappings);\n        }\n    }\n    else {\n        try {\n            /*\n            判断容器中是否有名称为handlermapping的bean，一般不会有这种情况，无需重点关注。\n            */\n            handlermapping hm = context.getbean(handler_mapping_bean_name, handlermapping.class);\n            this.handlermappings = collections.singletonlist(hm);\n        }\n        catch (nosuchbeandefinitionexception ex) {}\n    }\n    /*\n    一般情况下，我们使用springmvc默认的handlermapping就足够了，所以重点关注该分支。\n    */\n    if (this.handlermappings == null) {\n        /*\n        通过getdefaultstrategies()获取默认的handlermapping，请重点关注该方法，后序组件分析中也会提及到该方法。\n        将返回的handlermapping列表保存到dispatcherservlet对象的handlermappings属性中，当解析请求时，会访问该属性。\n        */\n        this.handlermappings = getdefaultstrategies(context, handlermapping.class);\n    }\n    for (handlermapping mapping : this.handlermappings) {\n        /*是否需要进行路径模式匹配*/\n        if (mapping.usespathpatterns()) {\n            this.parserequestpath = true;\n            break;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n// dispatcherservlet#getdefaultstrageties()\n/*\nstrategyinterface表示需要获取哪种类型的默认策略，在本文中，这里指的是handlermapping。\n*/\nprotected <t> list<t> getdefaultstrategies(applicationcontext context, class<t> strategyinterface) {\n    /*\n    springmvc中所有组件的默认初始化策略都会通过该方法获取。默认策略保存在一个属性文件中，该文件的路径名为：\t\torg.springframework.web.servlet.dispatcherservlet.properties。\n    如果是第一次调用该方法，defaultstrategies当然为null，所以会读取上述文件，并保存到defaultstrategies中。后序调用就不会再读取文件。\n    */\n    if (defaultstrategies == null) {\n        try {\n            /*\n            default_strategies_path的值为dispatcherservlet.properties\n            */\n            classpathresource resource = new classpathresource(default_strategies_path, dispatcherservlet.class);\n            defaultstrategies = propertiesloaderutils.loadproperties(resource);\n        }\n        catch (ioexception ex) {}\n    }\n\n    /*\n    这里从属性文件获取到handlermapping的默认策略，其内容为：org.springframework.web.servlet.handlermapping=org.springframework.web.servlet.handler.beannameurlhandlermapping,\\\n\torg.springframework.web.servlet.mvc.method.annotation.requestmappinghandlermapping,\\\n\torg.springframework.web.servlet.function.support.routerfunctionmapping\n\t也就是说，默认情况下会定义这三种handlermapping，后面会重点分析requestmappinghandlermapping，因为这是我们用得最多的一种情况。\n    */\n    string key = strategyinterface.getname();\n    string value = defaultstrategies.getproperty(key);\n    if (value != null) {\n        /*\n        将逗号分隔字符串转化为字符串数组\n        */\n        string[] classnames = stringutils.commadelimitedlisttostringarray(value);\n        list<t> strategies = new arraylist<>(classnames.length);\n        for (string classname : classnames) {\n            try {\n                class<?> clazz = classutils.forname(classname, dispatcherservlet.class.getclassloader());\n                /* \n                创建每一个默认的handlermapping组件，然后将其暂存到strategies列表中，最后统一返回。\n                */\n                object strategy = createdefaultstrategy(context, clazz);\n                strategies.add((t) strategy);\n            }\n            catch (classnotfoundexception ex) {} catch (linkageerror err) {}\n        }\n        return strategies;\n    }\n    else {\n        return collections.emptylist();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n上面分析到会创建默认的handlermapping组件并保存到dispatcherservlet实例的属性中。这个过程看似很简单，但是真正重要的部分还没有开始。\n\n# 获取handlerexecutionchain\n注意\n\n如果还不熟悉handler的注册过程，可先跳过这部分内容。\n\n在springmvc中，将handlermapping和handlerinterceptor结合在一起形成了handlerexectutionchain，在dispatcherservlet#dodispatch()方法中调用了gethandler()方法。\n\n// dispatcherservlet#gethandler()\n@nullable\nprotected handlerexecutionchain gethandler(httpservletrequest request) throws exception {\n    /* this.handlermappings已经在上面注册的过程中进行了赋值 */\n    if (this.handlermappings != null) {\n        /* 依次遍历每一个handlermapping */\n        for (handlermapping mapping : this.handlermappings) {\n            /* \n            调用handlermapping接口定义的gethandler()方法，具体逻辑有子类实现\n            */\n            handlerexecutionchain handler = mapping.gethandler(request);\n            if (handler != null) {\n                return handler;\n            }\n        }\n    }\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# handlermapping体系\n下面先来分析一下handlermapping体系，如下图所示（有删减）：\n\n\n\n可见，handlermapping体系分为两派，一派基于abstracthandlermapping，另一派基于abstracturlhandlermapping，两派都继承于abstracthandlermapping。\n\nabstracthandlermapping采用模板模式涉及了hanldermapping的整体结构，handlermapping的作用是根据request查找handler和interceptor，abstracthandlermapping定义了获取handler的模板方法gethandlerinternal()，交由子类实现，但是自己处理interceptor。\n\n首先需要找到分析的入口。请仔细注意在其父类中，abstracthandlermapping实现了webapplicationobjectsupport从而间接实现了applicationcontextaware接口，abstracthandlermethodmapping实现了initializingbean接口。根据spring bean的声明周期，在创建requestmappinghandlermapping实例时，会调用上述两个声明周期接口中相应的方法，而且先执行setapplicationcontext()方法，然后再执行afterpropertiesset()方法。\n\n# abstracthandlermapping中的初始化\n根据方法调用链，abstracthandlermapping中的initapplicationcontext()方法会被调用。\n\n// abstracthandlermapping#initapplicationcontext()\n@override\nprotected void initapplicationcontext() throws beansexception {\n    /* extendinterceptors()方法是一个在源码中是一个空方法，算是spring提供的一个扩展点 */\n    extendinterceptors(this.interceptors);\n    /*\n    detectmappedinterceptors() 方法的作用是将springmvc容器及其父容器中的所有mappedinterceptor类型的拦截器添加到adaptedinterceptors属性中，因为mappedinterceptor是handlerinerceptor的子实现类。\n    */\n    detectmappedinterceptors(this.adaptedinterceptors);\n    /*\n    initinterceptors()方法的作用是初始化interceptor，具体内容是将interceptors属性里包含的对象按类型添加到mappedinterceptors或者adaptedinterceptors。\n    */\n    initinterceptors();\n}\n\nprotected void detectmappedinterceptors(list<handlerinterceptor> mappedinterceptors) {\n    mappedinterceptors.addall(beanfactoryutils.beansoftypeincludingancestors(\n        obtainapplicationcontext(), mappedinterceptor.class, true, false).values());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n上面提到abstracthandlermapping中的几个属性：\n\n/*\ninterceptors属性保存了我们在springmvc配置的拦截器，注意泛型参数是object的，因为springmvc中目前有两种拦截器：\nhandlerinterceptor和webrequestinterceptor，后者与异步请求有关，暂时没有使用过。\n*/\nprivate final list<object> interceptors = new arraylist<>();\n/*\n经过适配后的拦截器，注意泛型参数是handlerinterceptor，所以当拦截器类型为webrequestinterceptor时，需要使用webrequesthandlerinterceptoradapter进行适配。gethandlerinternal()返回的handlerexecutionchain中包含的拦截器就是adaptedinterceptors中的。\n*/\nprivate final list<handlerinterceptor> adaptedinterceptors = new arraylist<>();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n// abstracthandlermapping#initinterceptors()\nprotected void initinterceptors() {\n    if (!this.interceptors.isempty()) {\n        for (int i = 0; i < this.interceptors.size(); i++) {\n            object interceptor = this.interceptors.get(i);\n            if (interceptor == null) {\n                throw new illegalargumentexception("entry number " + i + " in interceptors array is null");\n            }\n            /*\n            调用adaptinterceptor适配拦截器，并将适配后的对象加入adaptedinterceptors中。\n            */\n            this.adaptedinterceptors.add(adaptinterceptor(interceptor));\n        }\n    }\n}\n\n/* 实现逻辑很简单，就不再赘述了 */\nprotected handlerinterceptor adaptinterceptor(object interceptor) {\n    if (interceptor instanceof handlerinterceptor) {\n        return (handlerinterceptor) interceptor;\n    }\n    else if (interceptor instanceof webrequestinterceptor) {\n        return new webrequesthandlerinterceptoradapter((webrequestinterceptor) interceptor);\n    }\n    else {\n        throw new illegalargumentexception("interceptor type not supported: " + interceptor.getclass().getname());\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n# abstracthandlermapping获取handlerexecutionchain\n// abstracthandlermapping#handlerexecutionchain\n@override\n@nullable\npublic final handlerexecutionchain gethandler(httpservletrequest request) throws exception {\n    /* 获取handler, 由子类实现 */\n    object handler = gethandlerinternal(request);\n    if (handler == null) {\n        /* 如果当前请求没有对应的handler，则设置为默认的handler */\n        handler = getdefaulthandler();\n    }\n    if (handler == null) {\n        return null;\n    }\n    // bean name or resolved handler?\n    if (handler instanceof string) {\n        string handlername = (string) handler;\n        handler = obtainapplicationcontext().getbean(handlername);\n    }\n\n    /* 获取handlerexecutionchain并返回，后序操作这里有删减 */\n    handlerexecutionchain executionchain = gethandlerexecutionchain(handler, request);\n    return executionchain;\n}\n\n// abstracthandlermapping#gethandlerexecutionchain\nprotected handlerexecutionchain gethandlerexecutionchain(object handler, httpservletrequest request) {\n    handlerexecutionchain chain = (handler instanceof handlerexecutionchain ?\n                                   (handlerexecutionchain) handler : new handlerexecutionchain(handler));\n\n    /* 遍历所有适配后的拦截器 */\n    for (handlerinterceptor interceptor : this.adaptedinterceptors) {\n        if (interceptor instanceof mappedinterceptor) {\n            mappedinterceptor mappedinterceptor = (mappedinterceptor) interceptor;\n            /* 判断拦截器是否匹配请求 */\n            if (mappedinterceptor.matches(request)) {\n                /* 将匹配的拦截器加入handlerexecutionchain中 */\n                chain.addinterceptor(mappedinterceptor.getinterceptor());\n            }\n        }\n        else {\n            chain.addinterceptor(interceptor);\n        }\n    }\n    return chain;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n# abstracthandlermethodmapping<t>\n该抽象类是继承abstracthandlemapping的两大阵营之一，定义一个请求和一个handlermethod（顾名思义，将方法作为handler）之间的关系，提供了handlermapping的初始化，注册和获取等模板方法。\n\n提示\n\nhandlermethod将method和bean封装在一起，便于调用，因为反射调用的时候需要执行的对象。\n\n注意泛型t表示mapping类型，如我们常用的@requestmapping对应的泛型实参是requestmappinginfo。如果我们想自定义类似@requestmapping的注解，那么就可以在实现时提供不同的泛型实参。\n\n# requestmappinghandlermapping中的初始化\n上面我们说到，requestmappinghandlermapping是我们常使用的，当我们在controller类中使用@requestmapping注解或基于该注解的其他rest风格的注解时，springmvc会使用该类型的handlermapping。\n\nrequestmappinghandlermapping中重写了abstracthandlermethodmapping中的afterpropertiesset()方法。\n\n// requestmappinghandlermapping#afterpropertiesset()\n@override\n@suppresswarnings("deprecation")\npublic void afterpropertiesset() {\n\n    this.config = new requestmappinginfo.builderconfiguration();\n    this.config.settrailingslashmatch(usetrailingslashmatch());\n    this.config.setcontentnegotiationmanager(getcontentnegotiationmanager());\n\n    if (getpatternparser() != null) {\n        this.config.setpatternparser(getpatternparser());\n        assert.istrue(!this.usesuffixpatternmatch && !this.useregisteredsuffixpatternmatch,\n                      "suffix pattern matching not supported with pathpatternparser.");\n    }\n    else {\n        this.config.setsuffixpatternmatch(usesuffixpatternmatch());\n        this.config.setregisteredsuffixpatternmatch(useregisteredsuffixpatternmatch());\n        this.config.setpathmatcher(getpathmatcher());\n    }\n\t\n    // 调用父类abstracthandlermethodmapping的afterpropertiesset()方法\n    super.afterpropertiesset();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\nabstracthandlermethodmapping的afterpropertiesset()方法内部直接调用了其内部的inithandlermethods()方法。\n\n// abstracthandlermethodmapping#inithandlermethods()\nprotected void inithandlermethods() {\n    for (string beanname : getcandidatebeannames()) {\n        /*\n        如果bean的名称以scopedtarget开头，那么则不处理，\n        目的是排除cglib代理的bean，原因是代理bean的方法上没有@requestmapping注解\n        */\n        if (!beanname.startswith(scoped_target_name_prefix)) {\n            processcandidatebean(beanname);\n        }\n    }\n    handlermethodsinitialized(gethandlermethods());\n}\n\n// abstracthandlermethodmapping#getcandidatebeannames()\n/* 返回所有的候选bean的名称*/\nprotected string[] getcandidatebeannames() {\n    /*\n    detecthandlermethodsinancestorcontexts表示是否探测父容器内的bean，默认为false\n    */\n    return (this.detecthandlermethodsinancestorcontexts ?\n            beanfactoryutils.beannamesfortypeincludingancestors(obtainapplicationcontext(), object.class) :\n            obtainapplicationcontext().getbeannamesfortype(object.class));\n}\n\n// abstracthandlermethodmapping#processcandidatebean\n/* 处理候选bean */\nprotected void processcandidatebean(string beanname) {\n    class<?> beantype = null;\n    try {\n        beantype = obtainapplicationcontext().gettype(beanname);\n    }\n    catch (throwable ex) {\n        // an unresolvable bean type, probably from a lazy bean - let\'s ignore it.\n        if (logger.istraceenabled()) {\n            logger.trace("could not resolve type for bean \'" + beanname + "\'", ex);\n        }\n    }\n    // ishandler()方法参考下面的讲解\n    if (beantype != null && ishandler(beantype)) {\n        detecthandlermethods(beanname);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n上面的ishandler()在abstractmethodhandlermapping中是一个模板方法，对于一个bean，是否是handler应该有具体的子类来实现，对于requestmappinghandlermapping中的实现如下：\n\n// requestmappinghandlermapping#ishandler()\n@override\nprotected boolean ishandler(class<?> beantype) {\n    /*\n    该bean是否由@controller或者是@requestmapping修饰\n    */\n    return (annotatedelementutils.hasannotation(beantype, controller.class) ||\n            annotatedelementutils.hasannotation(beantype, requestmapping.class));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n继续来看detecthandlermethods()方法：\n\n// abstractmethodhandlermapping#detecthandlermethods()\n/* \n该方法顾名思义，就是探测处理器中的方法\n*/\nprotected void detecthandlermethods(object handler) {\n    class<?> handlertype = (handler instanceof string ?\n                            obtainapplicationcontext().gettype((string) handler) : handler.getclass());\n\n    if (handlertype != null) {\n        class<?> usertype = classutils.getuserclass(handlertype);\n        /*\n        methods中保存了当前handler中满足要求的方法与t（这里主要指requestmappinginfo）之间的关系。\n        selectmethods的第二个参数的是元数据解析器，具体细节请参考下文\n        */\n        map<method, t> methods = methodintrospector.selectmethods(usertype,\n            (methodintrospector.metadatalookup<t>) method -> {\n                try {\n                    return getmappingformethod(method, usertype);\n                }\n                catch (throwable ex) {\n                    throw new illegalstateexception("invalid mapping on handler class [" +\n                                                    usertype.getname() + "]: " + method, ex);\n                }\n            });\n        if (logger.istraceenabled()) {\n            logger.trace(formatmappings(usertype, methods));\n        }\n        /*\n        遍历method和mapping，然后进行注册操作\n        */\n        methods.foreach((method, mapping) -> {\n            /* 获取代理后的bean的方法 */\n            method invocablemethod = aoputils.selectinvocablemethod(method, usertype);\n            /* 进行注册handlermethod，具体细节请参考下文 */\n            registerhandlermethod(handler, invocablemethod, mapping);\n        });\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n上面的方法中调用了methodintrospector#selectmethods()：\n\n// methodintrospector#selectmethods()\npublic static <t> map<method, t> selectmethods(class<?> targettype, final metadatalookup<t> metadatalookup) {\n    /* methodmap暂存了targettype中method和mapping（对于requestmappinghandlermapping是requestmappinginfo）的对应关系，最后将该map返回 */\n    final map<method, t> methodmap = new linkedhashmap<>();\n    /* 保存了targettype以及实现的接口 */\n    set<class<?>> handlertypes = new linkedhashset<>();\n    /* 具体的实现类，如果targettype是jdk动态代理的类型的话，那么将仍然为null */\n    class<?> specifichandlertype = null;\n    /*\n    排除jdk动态代理bean的情况\n    */\n    if (!proxy.isproxyclass(targettype)) {\n        specifichandlertype = classutils.getuserclass(targettype);\n        handlertypes.add(specifichandlertype);\n    }\n    /* 添加所有的接口 */\n    handlertypes.addall(classutils.getallinterfacesforclassasset(targettype));\n\n    /*循环处理每一个类型*/\n    for (class<?> currenthandlertype : handlertypes) {\n        final class<?> targetclass = (specifichandlertype != null ? specifichandlertype : currenthandlertype);\n        /* 处理当前类型中的方法 */\n        reflectionutils.dowithmethods(currenthandlertype, method -> {\n            /* \n            获取与该方法相关的最具体的方法 \n            意思就是如果该方法位于父类型中，那么获取子类中的对应的重写或实现\n            */\n            method specificmethod = classutils.getmostspecificmethod(method, targetclass);\n            /*\n            获取该方法上的元数据（对于requestmappinghandlermapping是解析@requestmapping注解），获的解析后的mapping（对于requestmappinghandlermapping是requestmappinginfo）\n            */\n            t result = metadatalookup.inspect(specificmethod);\n            /* 对于requestmappinghandlermapping，如果result != null成立，则说明方法上有@requestmapping注解 */\n            if (result != null) {\n                /* 处理桥接方法，可以google一下什么是桥接方法 */\n                method bridgedmethod = bridgemethodresolver.findbridgedmethod(specificmethod);\n                if (bridgedmethod == specificmethod || metadatalookup.inspect(bridgedmethod) == null) {\n                    methodmap.put(specificmethod, result);\n                }\n            }\n            /* user_declared_methods表示方法过滤器，过滤规则为排除桥接方法和合成方法，同样地，可以google一下什么是合成方法 */\n        }, reflectionutils.user_declared_methods);\n    }\n    return methodmap;\n}\n\n// reflectionutils#dowithmethods()\n/*\nclazz就是目标类型，表示要处理哪个类型中的方法\nmf表示方法的过滤器，表示哪些方法才是符合匹配要求的\nmc表示方法满足要求时执行的回调\n*/\npublic static void dowithmethods(class<?> clazz, methodcallback mc, @nullable methodfilter mf) {\n    // keep backing up the inheritance hierarchy.\n    method[] methods = getdeclaredmethods(clazz, false);\n    for (method method : methods) {\n        if (mf != null && !mf.matches(method)) {\n            continue;\n        }\n        try {\n            /* 执行方法匹配回调 */\n            mc.dowith(method);\n        }\n        catch (illegalaccessexception ex) {\n            throw new illegalstateexception("not allowed to access method \'" + method.getname() + "\': " + ex);\n        }\n    }\n    if (clazz.getsuperclass() != null && (mf != user_declared_methods || clazz.getsuperclass() != object.class)) {\n        /* 递归处理父类中的方法*/\n        dowithmethods(clazz.getsuperclass(), mc, mf);\n    }\n    else if (clazz.isinterface()) {\n        for (class<?> superifc : clazz.getinterfaces()) {\n            /* 递归处理父接口中的方法*/\n            dowithmethods(superifc, mc, mf);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n现在也获取到了handler中的所有非桥接和非合成方法了，接下来是要解析方法中的元数据，在上面abstractmehtodhandlermapping#detecthandlermethods()方法中，以lambda的方式传递给methodintrospector#selectmethods()方法了一个metadatalookup类型的实例，在lambda表达式中调用了abstractmehtodhandlermapping#getmappingformethod()方法，同样地，该方法是一个模板方法，具体逻辑由子类实现（因为这里的元数据指的是什么，是泛型参数t决定的，具体是什么应该由子类决定，所以元数据的解析也应该让子类进行）。\n\n// requestmappinghandlermapping#getmappingformethod()\n@override\n@nullable\nprotected requestmappinginfo getmappingformethod(method method, class<?> handlertype) {\n    /* \n    创建requestmappinginfo，如果method由@requestmapping修饰，那么则返回一个非null对象\n    */\n    requestmappinginfo info = createrequestmappinginfo(method);\n    if (info != null) {\n        requestmappinginfo typeinfo = createrequestmappinginfo(handlertype);\n        if (typeinfo != null) {\n            info = typeinfo.combine(info);\n        }\n        string prefix = getpathprefix(handlertype);\n        if (prefix != null) {\n            info = requestmappinginfo.paths(prefix).options(this.config).build().combine(info);\n        }\n    }\n    return info;\n}\n\n// requestmappinghandlermapping#createrequestmappinginfo(),注意重载\n@nullable\nprivate requestmappinginfo createrequestmappinginfo(annotatedelement element) {\n    /* 查询@requestmapping或该注解的合并注解（如@getmapping）*/\n    requestmapping requestmapping = annotatedelementutils.findmergedannotation(element, requestmapping.class);\n    /* 获取自定义的条件，但是目前为空方法，可以忽视 */\n    requestcondition<?> condition = (element instanceof class ?\n                                     getcustomtypecondition((class<?>) element) : getcustommethodcondition((method) element));\n    /* 基于注解，创建requestmappinginfo对象 */\n    return (requestmapping != null ? createrequestmappinginfo(requestmapping, condition) : null);\n}\n\n// requestmappinghandlermapping#createrequestmappinginfo(),注意重载\nprotected requestmappinginfo createrequestmappinginfo(\n    requestmapping requestmapping, @nullable requestcondition<?> customcondition) {\n\n    /*\n    创建requestmappinginfo.builder对象，并设置属性，这些属性就是通过@requestmapping注解设置的。\n    这里顺便回忆一下各种属性的含义:\n    name 当前映射的名称，只是个名称而已，别误认为也表示url\n    value和path互为别名，因为java中注解的value值可以直接进行赋值，不用写属性名（只为value赋值时），表示url; 注意，如果同时指定了value和path，但是值却不一致，则会抛出annotationconfigurationexception异常：different @aliasfor mirror values for annotation requestmapping。\n    method 表示http请求的方法\n    headers 表示请求头映射要求，具体写法为{header1=value1, header2=value2}，value中可以使用通配符\n    params 表示请求参数所应满足的条件\n    consumers 表示请求头部中content-type字段应满足什么条件\n    produces 表示请求头部中accept字段应满足什么条件\n    */\n    requestmappinginfo.builder builder = requestmappinginfo\n        .paths(resolveembeddedvaluesinpatterns(requestmapping.path()))\n        .methods(requestmapping.method())\n        .params(requestmapping.params())\n        .headers(requestmapping.headers())\n        .consumes(requestmapping.consumes())\n        .produces(requestmapping.produces())\n        .mappingname(requestmapping.name());\n    if (customcondition != null) {\n        builder.customcondition(customcondition);\n    }\n    /*\n    this.config是一个requestmappinginfo.builderconfiguration类型的属性，具体构建的代码就不分析了，只知道返回一个requestmappinginfo和对应的method一并存入map中就可以了。\n    */\n    return builder.options(this.config).build();\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n接下来，在abstractmethodhandlermapping#detecthandlermethods()方法的末尾，调用了registerhandlermethod()方法。\n\n/* abstractmethodhandler#registerhandlermethod */\nprotected void registerhandlermethod(object handler, method method, t mapping) {\n    /* this.mappingregistry的类型是abstractmethodhandler.mappingregistry */\n    this.mappingregistry.register(mapping, handler, method);\n}\n\n\n1\n2\n3\n4\n5\n# mappingregistry\n关于mappingregistry，有下面几个属性（不要纠结为什么会有这么几个属性，只关心springmvc是怎么处理的就可以了）：\n\n/* 注册表 */\nprivate final map<t, mappingregistration<t>> registry = new hashmap<>();\n/* mapping 的路径与 handlermethod 的映射 */\nprivate final multivaluemap<string, t> pathlookup = new linkedmultivaluemap<>();\n/* mapping 的名字与 handlermethod 的映射 */\nprivate final map<string, list<handlermethod>> namelookup = new concurrenthashmap<>();\n/* 跨域相关，本文暂时不讨论 */\nprivate final map<handlermethod, corsconfiguration> corslookup = new concurrenthashmap<>();\n/* 读写锁 */\nprivate final reentrantreadwritelock readwritelock = new reentrantreadwritelock();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n提示\n\n在继续往下分析之前，先来搞清楚mappingregistry和mappingregistration是什么关系。\n\nmappingregistration表示了mapping和handlermethod之间的关系。而mappingregistry保存了mapping和mappingregistration之间的关系。如果把mappingregistry看成一个表，那么mappingregistration则是表中的每一项。\n\n下面来看上面调用的register()方法：\n\n// abstractmethodhandlermapping.mappingregistry#register()\npublic void register(t mapping, object handler, method method) {\n    /* 加写锁 */\n    this.readwritelock.writelock().lock();\n    try {\n        /* 创建handlermethod，将handler和method绑定在一起 */\n        handlermethod handlermethod = createhandlermethod(handler, method);\n        /* 严重handlermethod的合法性 */\n        validatemethodmapping(handlermethod, mapping);\n\t\t\n        /* \n        获取直接路径, 直接路径是指非模式路径\n        直接路径： @getmapping("/users")\n        模式路径： @getmapping("/user/{id}")\n        */\n        set<string> directpaths = abstracthandlermethodmapping.this.getdirectpaths(mapping);\n        for (string path : directpaths) {\n            /* \n            保存直接路径与mapping的关系，因为同一路径可以映射到不同mapping，所以要使用multivaluemap\n            */\n            this.pathlookup.add(path, mapping);\n        }\n\n        string name = null;\n        if (getnamingstrategy() != null) {\n            name = getnamingstrategy().getname(handlermethod, mapping);\n            /* 保存名称与handlermethod的关系 */\n            addmappingname(name, handlermethod);\n        }\n\n        /* 跨域设置，暂时忽略 */\n        corsconfiguration config = initcorsconfiguration(handler, method, mapping);\n        if (config != null) {\n            config.validateallowcredentials();\n            this.corslookup.put(handlermethod, config);\n        }\n\n        /* 将”表项“加入”表“中 */\n        this.registry.put(mapping, new mappingregistration<>(mapping, handlermethod, directpaths, name));\n    }\n    finally {\n        /* 释放写锁 */\n        this.readwritelock.writelock().unlock();\n    }\n}\n\n// abstractmethodhandlermapping.mappingregistry#validatemethodmapping()\nprivate void validatemethodmapping(handlermethod handlermethod, t mapping) {\n    /* 获取当前mapping对应的mappingregistration */\n    mappingregistration<t> registration = this.registry.get(mapping);\n    /* 获取当前mapping对应的mappingregistration中保存的handlermethod */\n    handlermethod existinghandlermethod = (registration != null ? registration.gethandlermethod() : null);\n    /*\n    判断当前mapping是否已经存在handlermethod，如果已经存在且不是当前的handlermethod,则抛出异常。\n    这也是为什么有时我们在不同的@requestmapping注解中设置了相同的url后，会抛出下列异常，原因是我们在不同的method上设置了两个完全一样的mapping。\n    */\n    if (existinghandlermethod != null && !existinghandlermethod.equals(handlermethod)) {\n        throw new illegalstateexception(\n            "ambiguous mapping. cannot map \'" + handlermethod.getbean() + "\' method \\n" +\n            handlermethod + "\\nto " + mapping + ": there is already \'" +\n            existinghandlermethod.getbean() + "\' bean method\\n" + existinghandlermethod + " mapped.");\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n为了方便，将获取逻辑的分析一并写在这一节。\n\nmappingregistry中lookuphandlermethod()方法中实现了查询逻辑：\n\n// abstracthandlermethodmapping.mappingregistry#lookuphandlermethod()\n@nullable\nprotected handlermethod lookuphandlermethod(string lookuppath, httpservletrequest request) throws exception {\n    /* 当前请求的匹配列表 */\n    list<match> matches = new arraylist<>();\n    /* 获取与直接路径匹配的mapping */\n    list<t> directpathmatches = this.mappingregistry.getmappingsbydirectpath(lookuppath);\n    if (directpathmatches != null) {\n        addmatchingmappings(directpathmatches, matches, request);\n    }\n    /* 如果没有与直接路径相关的mapping，则获取所有的mappings，然后再进行匹配 */\n    if (matches.isempty()) {\n        addmatchingmappings(this.mappingregistry.getregistrations().keyset(), matches, request);\n    }\n    if (!matches.isempty()) {\n        match bestmatch = matches.get(0);\n        if (matches.size() > 1) {\n            /* mapping匹配比较器 */\n            comparator<match> comparator = new matchcomparator(getmappingcomparator(request));\n            matches.sort(comparator);\n            bestmatch = matches.get(0);\n            if (corsutils.ispreflightrequest(request)) {\n                return preflight_ambiguous_match;\n            }\n            match secondbestmatch = matches.get(1);\n            /* 如果最佳匹配和第二匹配优先级一样高，则说明配置有误，则抛出异常 */\n            if (comparator.compare(bestmatch, secondbestmatch) == 0) {\n                method m1 = bestmatch.handlermethod.getmethod();\n                method m2 = secondbestmatch.handlermethod.getmethod();\n                string uri = request.getrequesturi();\n                throw new illegalstateexception(\n                    "ambiguous handler methods mapped for \'" + uri + "\': {" + m1 + ", " + m2 + "}");\n            }\n        }\n        request.setattribute(best_matching_handler_attribute, bestmatch.handlermethod);\n        /* 处理首个match对象 */\n        handlematch(bestmatch.mapping, lookuppath, request);\n        /* 返回最佳匹配关联的handlermethod */\n        return bestmatch.handlermethod;\n    }\n    else {\n        /* 处理没有匹配的情况 */\n        return handlenomatch(this.mappingregistry.getregistrations().keyset(), lookuppath, request);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n# requestmappinginfohandlermapping中获取handler\nrequestmappinginfohandlermapping重写了父类abstracthandlermethodmapping中的gethandlerinternal()方法。\n\n// requestmappinginfohandlermapping#gethandlerinternal()\n@override\nprotected handlermethod gethandlerinternal(httpservletrequest request) throws exception {\n    request.removeattribute(producible_media_types_attribute);\n    try {\n        /* 调用父类的该方法 */\n        return super.gethandlerinternal(request);\n    }\n    finally {\n        producesrequestcondition.clearmediatypesattribute(request);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# abstracthandlermethodmapping中获取handler\n// abstracthandlermethodmapping#gethandlerinternal()\n@override\nprotected handlermethod gethandlerinternal(httpservletrequest request) throws exception {\n    /* 初始化查询路径 */\n    string lookuppath = initlookuppath(request);\n    /* 获取读锁 */\n    this.mappingregistry.acquirereadlock();\n    try {\n        /* 获取handlermethod，请参考上文mappingregistry节中关于lookuphandlermethod的讲解 */\n        handlermethod handlermethod = lookuphandlermethod(lookuppath, request);\n        return (handlermethod != null ? handlermethod.createwithresolvedbean() : null);\n    }\n    finally {\n        /* 释放读锁 */\n        this.mappingregistry.releasereadlock();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# 总结\n本文已分析了大部分关于handlermapping的内容，只分析了abstracthandlermethodmapping这一派系，因为这是最常使用的。\n\n关于handlermapping可以分为两部分，初始化和获取。初始化是在servlet容器初始化dispatcherservlet时进行的，而获取是在请求到来时进行的。\n\nhandlerexecutionchain包含了handlermethod和handlerinterceptor，关于后者的初始化是由handlermapping的直接实现类abstracthandlermapping进行的，而前者由各个子类进行。对于abstracthandlermethodmapping，主要的逻辑还是在其自身内实现的，其子类requestmappinginfohandlermapping以requestmappinginfo作为mapping类型。所有的handlermapping保存在了abstracthandlermethodmapping中的内部类mappingregistry中，该内部类定义了注册和获取handlermapping的逻辑。mappingregistry就像是一张注册表一样，其中每一项类型为mappingregistration。\n\n本文关于获取handlermapping的具体匹配逻辑没有进行深入的分析，只是讲到了直接路径的匹配，路径中有参数等情况没有涉及，后面有时间再补充吧。\n\n获取到了handlerexecutionchain只是请求在dispatcherservlet中的第一步，后面还有大量的操作（比如handleradapter）才能完成一个请求。\n\n# 参考\n * springmvc源码分析三、组件一handlermapping源码分析\n * 精尽spring mvc源码分析 - handlermapping 组件（三）之 abstracthandlermethodmapping',charsets:{cjk:!0}},{title:"SpringMVC源码分析之HandlerAdapter",frontmatter:{title:"SpringMVC源码分析之HandlerAdapter",categories:["后端框架"],tags:["SpringMVC"],date:"2021-01-15T17:48:28.000Z",permalink:"/pages/b2649d/"},regularPath:"/22.%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/01.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/01.Spring%20Framework/03.Web/04.%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BHandlerAdapter.html",relativePath:"22.后端框架/01.Spring全家桶/01.Spring Framework/03.Web/04.源码分析之HandlerAdapter.md",key:"v-edfc93ba",path:"/pages/b2649d/",headers:[{level:2,title:"HandlerAdapter体系",slug:"handleradapter体系",normalizedTitle:"handleradapter体系",charIndex:273},{level:2,title:"RequestMappingHandlerAdapter",slug:"requestmappinghandleradapter",normalizedTitle:"requestmappinghandleradapter",charIndex:700},{level:3,title:"相关属性",slug:"相关属性",normalizedTitle:"相关属性",charIndex:925},{level:3,title:"构造方法",slug:"构造方法",normalizedTitle:"构造方法",charIndex:4521},{level:3,title:"afterProperties()",slug:"afterproperties",normalizedTitle:"afterproperties()",charIndex:7742},{level:3,title:"handlerInternal()",slug:"handlerinternal",normalizedTitle:"handlerinternal()",charIndex:10961},{level:3,title:"invokeHandlerMethod()",slug:"invokehandlermethod",normalizedTitle:"invokehandlermethod()",charIndex:12708},{level:3,title:"getDataBinderFactory()",slug:"getdatabinderfactory",normalizedTitle:"getdatabinderfactory()",charIndex:16205},{level:3,title:"getModelFactory()",slug:"getmodelfactory",normalizedTitle:"getmodelfactory()",charIndex:17702},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:19351},{level:2,title:"ServletInvocableHandlerMethod",slug:"servletinvocablehandlermethod",normalizedTitle:"servletinvocablehandlermethod",charIndex:13369},{level:3,title:"HandlerMethod",slug:"handlermethod",normalizedTitle:"handlermethod",charIndex:105},{level:3,title:"InvocableHanlderMethod",slug:"invocablehanldermethod",normalizedTitle:"invocablehanldermethod",charIndex:22458},{level:3,title:"ServletInvocableHandlerMethod",slug:"servletinvocablehandlermethod-2",normalizedTitle:"servletinvocablehandlermethod",charIndex:13369},{level:2,title:"ModelAndViewContainer",slug:"modelandviewcontainer",normalizedTitle:"modelandviewcontainer",charIndex:14059},{level:3,title:"相关属性",slug:"相关属性-3",normalizedTitle:"相关属性",charIndex:925},{level:3,title:"addAllAttributes()",slug:"addallattributes",normalizedTitle:"addallattributes()",charIndex:28300},{level:2,title:"SessionAttriutesHandler",slug:"sessionattriuteshandler",normalizedTitle:"sessionattriuteshandler",charIndex:29840},{level:3,title:"相关属性",slug:"相关属性-4",normalizedTitle:"相关属性",charIndex:925},{level:3,title:"构造方法",slug:"构造方法-2",normalizedTitle:"构造方法",charIndex:4521},{level:2,title:"ModelFactory",slug:"modelfactory",normalizedTitle:"modelfactory",charIndex:13262},{level:3,title:"构造方法",slug:"构造方法-3",normalizedTitle:"构造方法",charIndex:4521},{level:3,title:"初始化Model",slug:"初始化model",normalizedTitle:"初始化model",charIndex:32390},{level:3,title:"更新Model",slug:"更新model",normalizedTitle:"更新model",charIndex:38323},{level:2,title:"HandlerMethodArgumentResolver",slug:"handlermethodargumentresolver",normalizedTitle:"handlermethodargumentresolver",charIndex:1153},{level:2,title:"HandlerMethodReturnValueHandler",slug:"handlermethodreturnvaluehandler",normalizedTitle:"handlermethodreturnvaluehandler",charIndex:1589},{level:2,title:"总结",slug:"总结-2",normalizedTitle:"总结",charIndex:19351},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:2536}],excerpt:'<p>前面一篇<a href="https://harrisonlee.net/pages/f2c795/" target="_blank" rel="noopener noreferrer">文章<OutboundLink/></a>分析了<code>DispatcherServlet</code>初始化和获取<code>HandlerExecutionChain</code>的过程，接下来就是要执行handler了。因为handler有很多种，不同的handler不一定都会通过<code>HandlerMethod</code>来执行方法，所以SpringMVC引入了<code>HandlerAdapter</code>，顾名思义，这是handler的适配器，目的是适配获取到的多种handler。</p>\n',lastUpdated:"2021-01-18",headersStr:"HandlerAdapter体系 RequestMappingHandlerAdapter 相关属性 构造方法 afterProperties() handlerInternal() invokeHandlerMethod() getDataBinderFactory() getModelFactory() 总结 ServletInvocableHandlerMethod HandlerMethod InvocableHanlderMethod ServletInvocableHandlerMethod ModelAndViewContainer 相关属性 addAllAttributes() SessionAttriutesHandler 相关属性 构造方法 ModelFactory 构造方法 初始化Model 更新Model HandlerMethodArgumentResolver HandlerMethodReturnValueHandler 总结 参考",content:'前面一篇文章分析了DispatcherServlet初始化和获取HandlerExecutionChain的过程，接下来就是要执行handler了。因为handler有很多种，不同的handler不一定都会通过HandlerMethod来执行方法，所以SpringMVC引入了HandlerAdapter，顾名思义，这是handler的适配器，目的是适配获取到的多种handler。\n\n注意\n\n本文中的Spring源码版本为5.3.2，不过本文中涉及的大部分内容相比之前版本都是大同小异。另外，本文中所展示的源码可能会有些删减，避免冗长。\n\n# HandlerAdapter体系\n因为有多种handler，所以就有多种对用的adapter。相比HandlerMapping体系，HandlerAdapter就比较扁平化了。\n\n\n\n在DispatcherServlet.properties中，定义了默认使用的HandlerAdapter，如果没有配置其他的适配器，那么在SpringMVC容器刷新时就会初始化下列这些适配器：\n\norg.springframework.web.servlet.HandlerAdapter=org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\\\n\torg.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\\\n\torg.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter,\\\n\torg.springframework.web.servlet.function.support.HandlerFunctionAdapter\n\n\n1\n2\n3\n4\nAbstractHandlerMethodAdapter分支处理包含HandlerMethod类型的HandlerMapping，我们会重点分析该分支。\n\n# RequestMappingHandlerAdapter\n# 相关属性\n先来看一下RequestMappingHandlerAdapter中的主要属性。\n\n# 参数解析器\n/* \ncustomArgumentResolvers 保存了开发者手动注入的参数解析器或者是SpringMVC提供的默认解析器,当初始化RequestMappingHandlerAdapter的时候，就会将customArgumentResolvers中的所有解析器整合到argumentResolvers中，Composite就是整合的意思。HandlerMethodArgumentResolverComposite内部有一个维护HandlerMethodArgumentResolver的集合。\n*/\nprivate List<HandlerMethodArgumentResolver> customArgumentResolvers;\nprivate HandlerMethodArgumentResolverComposite argumentResolvers;\n\n/*\ninitBinderArgumentResolvers中保存了解析由@InitBinder修饰的方法的参数的解析器。\n*/\nprivate HandlerMethodArgumentResolverComposite initBinderArgumentResolvers;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 返回值解析器\n/*\n下面两个属性与返回值解析器有关，和参数解析器类似。\n*/\nprivate List<HandlerMethodReturnValueHandler> customReturnValueHandlers;\nprivate HandlerMethodReturnValueHandlerComposite returnValueHandlers;\n\n\n1\n2\n3\n4\n5\n# 消息转换器\n/*\n消息转换器，在SpringMVC中及其重要。作用是将消息从某种类型转换为目标类型。比如前端传入JSON格式的数据，后端接口以DOMAIN对象接收，则需要将JSON数据转换为各种类型的对象属性。这就需要消息转换器。\n*/\nprivate List<HttpMessageConverter<?>> messageConverters;\n\n\n1\n2\n3\n4\n# Session相关\n/*\nSessionAttributeStore是一个工具类，方便存取键值对到session中。\n*/\nprivate SessionAttributeStore sessionAttributeStore = new DefaultSessionAttributeStore();\n\n/*\nSessionAttributesHandler类是@SessionAttributes注解的类表示形式，该注解只能作用域类上，所以该map属性表示的是类名与@SessionAttributes注解表示类直接的映射。\n*/\nprivate final Map<Class<?>, SessionAttributesHandler> sessionAttributesHandlerCache = new ConcurrentHashMap<>(64);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n笔记\n\n@SessionAttributes注解表示Model中哪些属性应该存取到session中，声明在类上。该注解有两个参数，names和types，前者表示对应Model中哪些名称的参数应该被存放进session中，后者表示哪些类型的参数应该被放进session中。注意@SessionAttributes注解不会与视图为redirect的model进行交互。\n\n关于SessionAttributesHandler请参考下文。\n\n@SessionAttribute（注意区分）注解作用在参数上，表示将session属性中的数据绑定到该参数上。\n\n# initBinder相关\n/*\ninitBinderCache保存了类与类中@InitBinder注解修饰的方法组成的集合之间的映射。\ninitBinderAdviceCache类似，只不过这里的类是指由@ControllerAdvice修饰的类。\n*/\nprivate final Map<Class<?>, Set<Method>> initBinderCache = new ConcurrentHashMap<>(64);\nprivate final Map<ControllerAdviceBean, Set<Method>> initBinderAdviceCache = new LinkedHashMap<>();\n\n\n1\n2\n3\n4\n5\n6\n笔记\n\n@ControllerAdvice注解修饰的类中的由@ExceptionHandler，@InitBinder，@ModelAttribute注解修饰的方法会对多个controller有效。可以通过某些@ControllerAdvice中的basePackages属性指定对哪些包下面的controller有效；也可以通过assignableTypes属性指定对哪些类型的controller有效；同时可以通过annotations属性指定对由哪些注解修饰的controller有效。\n\n笔记\n\n@InitBinder注解修饰controller或controllerAdvice中的方法，一般可以用来注册自定义的参数解析器。在当前controller中其他所有handlerMethod执行之前都会先执行该方法。\n\n# modelAttribute相关\n/*\nmodelAttributeCache表示类与类中由@ModelAttrubite注解修饰的方法组成的集合之间的映射。\nmodelAttributeAdviceCache表示由@ControllerAdvice注解修饰的类中由@ModelAttrubite注解修饰的方法组成的集合之间的映射。\n*/\nprivate final Map<Class<?>, Set<Method>> modelAttributeCache = new ConcurrentHashMap<>(64);\nprivate final Map<ControllerAdviceBean, Set<Method>> modelAttributeAdviceCache = new LinkedHashMap<>();\n\n\n1\n2\n3\n4\n5\n6\n笔记\n\n被@ModelAttribute注解但没有被@RequestMapping注解修饰的方法在controller方法执行前，都会执行一次该注解标注的方法，并且方法的返回值被以键值对的方式放入Model中，键为注解中value的属性值（如果每指定该属性值，则按照一定规则生成，详情请参考API DOC），值为返回值；被它修饰的方法参数表示从Model中取出参数并赋值给该参数。\n\n注意，如果一个方法同时被@ModelAttribute和@RequestMapping修饰，不会被提前执行。\n\n这里的Model是一个贯穿SpringMVC的东西，其实就是一个map，封装参数。\n\n# 其他属性\n/* \nrequestResponseBodyAdvice保存了各种RequestBodyAdvice和ResponseBodyAdvice。\n注意RequestBodyAdvice和ResponseBodyAdvice是接口不是注解，这两个接口的实现类要被@ControllerAdvice修饰，否则不会被扫描到（在initControllerAdviceCache()中会看到具体逻辑。）。\nRequestBodyAdvice表示在请求体被读取和被转换为目标类型之前允许进行自定义处理，也允许被转换后的参数在被绑定到由@RequestBody或@HttpEntity注解修饰的参数之前进行自定义处理。\nResponseBodyAdvice则是表示在由@ResponseBody或@ResponseEntity修饰的方法之后且在响应体被HttpMessageConverter处理之前进行自定义处理。\n这两个接口可以用来对请求体解密和对响应体进行加密（不过我目前没用过），比使用拦截器更优雅。\n*/\nprivate final List<Object> requestResponseBodyAdvice = new ArrayList<>();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 构造方法\npublic RequestMappingHandlerAdapter() {\n    /* 其实构造器中就这是完成了设置消息转换器的工作 */\n    this.messageConverters = new ArrayList<>(4);\n    this.messageConverters.add(new ByteArrayHttpMessageConverter());\n    this.messageConverters.add(new StringHttpMessageConverter());\n    if (!shouldIgnoreXml) {\n        try {\n            this.messageConverters.add(new SourceHttpMessageConverter<>());\n        }\n        catch (Error err) {\n            // Ignore when no TransformerFactory implementation is available\n        }\n    }\n    /* 重点关注该类型的解析器 */\n    this.messageConverters.add(new AllEncompassingFormHttpMessageConverter());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\npublic class AllEncompassingFormHttpMessageConverter extends FormHttpMessageConverter {\n    /* 加载当前类时加载各种转换器用到的依赖 */\n    static {\n        ClassLoader classLoader = AllEncompassingFormHttpMessageConverter.class.getClassLoader();\n        jaxb2Present = ClassUtils.isPresent("javax.xml.bind.Binder", classLoader);\n        jackson2Present = ClassUtils.isPresent("com.fasterxml.jackson.databind.ObjectMapper", classLoader) &&\n            ClassUtils.isPresent("com.fasterxml.jackson.core.JsonGenerator", classLoader);\n        jackson2XmlPresent = ClassUtils.isPresent("com.fasterxml.jackson.dataformat.xml.XmlMapper", classLoader);\n        jackson2SmilePresent = ClassUtils.isPresent("com.fasterxml.jackson.dataformat.smile.SmileFactory", classLoader);\n        gsonPresent = ClassUtils.isPresent("com.google.gson.Gson", classLoader);\n        jsonbPresent = ClassUtils.isPresent("javax.json.bind.Jsonb", classLoader);\n        kotlinSerializationJsonPresent = ClassUtils.isPresent("kotlinx.serialization.json.Json", classLoader);\n    }\n    \n    /* \n    添加各种转换器，addPartConverter是父类的方法，这些转换器保存在父类中定义的partConverters属性中。\n    private List<HttpMessageConverter<?>> partConverters = new ArrayList<>();\n    */\n    public AllEncompassingFormHttpMessageConverter() {\n        if (!shouldIgnoreXml) {\n            try {\n                addPartConverter(new SourceHttpMessageConverter<>());\n            }\n            catch (Error err) {\n                // Ignore when no TransformerFactory implementation is available\n            }\n\n            if (jaxb2Present && !jackson2XmlPresent) {\n                addPartConverter(new Jaxb2RootElementHttpMessageConverter());\n            }\n        }\n\n        if (jackson2Present) {\n            addPartConverter(new MappingJackson2HttpMessageConverter());\n        }\n        else if (gsonPresent) {\n            addPartConverter(new GsonHttpMessageConverter());\n        }\n        else if (jsonbPresent) {\n            addPartConverter(new JsonbHttpMessageConverter());\n        }\n        else if (kotlinSerializationJsonPresent) {\n            addPartConverter(new KotlinSerializationJsonHttpMessageConverter());\n        }\n\n        if (jackson2XmlPresent && !shouldIgnoreXml) {\n            addPartConverter(new MappingJackson2XmlHttpMessageConverter());\n        }\n\n        if (jackson2SmilePresent) {\n            addPartConverter(new MappingJackson2SmileHttpMessageConverter());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n# afterProperties()\nRequestMappingHandlerAdapter实现了InitializingBean，所以创建该类型的bean时会调用下列回调方法：\n\n// RequestMappingHandlerAdapter#afterPropertiesSet()\n@Override\npublic void afterPropertiesSet() {\n    /*\n    初始化处理由@ControllerAdvice修饰的类中的@ModelAttribute以及@InitBinder注解，建立这些被修饰的方法与对应类型的映射关系并存放到上面提到的各种以cache结尾的map属性中。\n    */\n    initControllerAdviceCache();\n\n    if (this.argumentResolvers == null) {\n        /* \n        获取默认的参数解析器并放入复合类中。\n        getDefaultArgumentResolvers()中的逻辑很简单，就不贴代码了，主要是创建列表，然后添加各种默认的参数解析器，添加的默认的解析器也比较多。\n        */\n        List<HandlerMethodArgumentResolver> resolvers = getDefaultArgumentResolvers();\n        this.argumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);\n    }\n    if (this.initBinderArgumentResolvers == null) {\n        /* \n        获取处理解析由@InitBinder注解修饰的方法的参数的解析器。\n        getDefaultInitBinderArgumentResolvers()的逻辑和getDefaultArgumentResolvers()类似。\n        */\n        List<HandlerMethodArgumentResolver> resolvers = getDefaultInitBinderArgumentResolvers();\n        this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite().addResolvers(resolvers);\n    }\n    if (this.returnValueHandlers == null) {\n        /* \n        获取处理默认的返回值解析器。\n        getDefaultReturnValueHandlers()的逻辑也很简单，就不贴代码了。\n        */\n        List<HandlerMethodReturnValueHandler> handlers = getDefaultReturnValueHandlers();\n        this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite().addHandlers(handlers);\n    }\n}\n\n// RequestMappingHandlerAdapter#initControllerAdviceCache()\nprivate void initControllerAdviceCache() {\n    if (getApplicationContext() == null) {\n        return;\n    }\n\n    List<ControllerAdviceBean> adviceBeans = ControllerAdviceBean.findAnnotatedBeans(getApplicationContext());\n\n    List<Object> requestResponseBodyAdviceBeans = new ArrayList<>();\n\n    /* 解析由@ControllerAdvice注解修饰的类中的各种注解修饰的方法 */\n    for (ControllerAdviceBean adviceBean : adviceBeans) {\n        Class<?> beanType = adviceBean.getBeanType();\n        if (beanType == null) {\n            throw new IllegalStateException("Unresolvable type for ControllerAdviceBean: " + adviceBean);\n        }\n        Set<Method> attrMethods = MethodIntrospector.selectMethods(beanType, MODEL_ATTRIBUTE_METHODS);\n        if (!attrMethods.isEmpty()) {\n            this.modelAttributeAdviceCache.put(adviceBean, attrMethods);\n        }\n        Set<Method> binderMethods = MethodIntrospector.selectMethods(beanType, INIT_BINDER_METHODS);\n        if (!binderMethods.isEmpty()) {\n            this.initBinderAdviceCache.put(adviceBean, binderMethods);\n        }\n        if (RequestBodyAdvice.class.isAssignableFrom(beanType) || ResponseBodyAdvice.class.isAssignableFrom(beanType)) {\n            requestResponseBodyAdviceBeans.add(adviceBean);\n        }\n    }\n\n    /* 如果扫描到了自定义的Request(Response)BodyAdvice，则加入到requestResponseBodyAdvice属性中。*/\n    if (!requestResponseBodyAdviceBeans.isEmpty()) {\n        this.requestResponseBodyAdvice.addAll(0, requestResponseBodyAdviceBeans);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n# handlerInternal()\n在DispatcherServlet的doDispatch()方法中，获取到适配器后，就调用适配器的handle()方法，该方法是HanlderAdapter接口所定义的。AbstractHandlerMethodAdapter实现了handle()方法，不过调用了自己定义的模板方法handleInternal()方法（是不是和上一篇文章中讲到的getHandlerInternal()很类似，都属于模板方法），该方法留给子类实现。\n\n下面来看RequestMappingHandlerAdapter定义的handlerInternal()方法：\n\n// RequestMappingHandlerAdapter#handlerInternal()\n@Override\nprotected ModelAndView handleInternal(HttpServletRequest request,\n                                      HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\n    ModelAndView mav;\n    /* 检查请求，判断请求方法是否在所支持的方法内，以及是否要求当前请求必须属于某个session中 */\n    checkRequest(request);\n\n    /* session同步，暂时不分析，先不管 */\n    if (this.synchronizeOnSession) {\n        HttpSession session = request.getSession(false);\n        if (session != null) {\n            Object mutex = WebUtils.getSessionMutex(session);\n            synchronized (mutex) {\n                mav = invokeHandlerMethod(request, response, handlerMethod);\n            }\n        }\n        else {\n            // No HttpSession available -> no mutex necessary\n            mav = invokeHandlerMethod(request, response, handlerMethod);\n        }\n    }\n    else {\n        // No synchronization on session demanded at all...\n        mav = invokeHandlerMethod(request, response, handlerMethod);\n    }\n\n    if (!response.containsHeader(HEADER_CACHE_CONTROL)) {\n        if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) {\n            applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers);\n        }\n        else {\n            prepareResponse(response);\n        }\n    }\n\n    return mav;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n# invokeHandlerMethod()\n下面关注invokeHandlerMethod()方法：\n\n// RequestMappingHandlerAdapter#invokeHandlerMethod()\n@Nullable\nprotected ModelAndView invokeHandlerMethod(HttpServletRequest request,\n                                           HttpServletResponse response, HandlerMethod handlerMethod) throws Exception {\n\n    ServletWebRequest webRequest = new ServletWebRequest(request, response);\n    try {\n        /* 处理@InitBinder与@ModelAttribute（包括@SessionAttributes）注解 */\n        WebDataBinderFactory binderFactory = getDataBinderFactory(handlerMethod);\n        ModelFactory modelFactory = getModelFactory(handlerMethod, binderFactory);\n\n        /* 将真正的handlerMethod转换成ServletInvocableHandlerMethod */\n        ServletInvocableHandlerMethod invocableMethod = createInvocableHandlerMethod(handlerMethod);\n        \n        /* 给handlerMethod设置参数解析器 */\n        if (this.argumentResolvers != null) {\n            invocableMethod.setHandlerMethodArgumentResolvers(this.argumentResolvers);\n        }\n        /* 给handlerMethod设置返回值解析器 */\n        if (this.returnValueHandlers != null) {\n\t\t\t invocableMethod.setHandlerMethodReturnValueHandlers(this.returnValueHandlers);\n        }\n        /* 给handlerMethod设置数据绑定器工厂 */\n        invocableMethod.setDataBinderFactory(binderFactory);\n        invocableMethod.setParameterNameDiscoverer(this.parameterNameDiscoverer);\n\n        ModelAndViewContainer mavContainer = new ModelAndViewContainer();\n        mavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));\n        /* 再次整合请求携带的数据，最终modelFactory包含了本次请求中所有的数据 */\n        modelFactory.initModel(webRequest, mavContainer, invocableMethod);\n        mavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);\n\n        /* 异步相关，暂时不分析 */\n        AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);\n        asyncWebRequest.setTimeout(this.asyncRequestTimeout);\n\n        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);\n        asyncManager.setTaskExecutor(this.taskExecutor);\n        asyncManager.setAsyncWebRequest(asyncWebRequest);\n        asyncManager.registerCallableInterceptors(this.callableInterceptors);\n        asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);\n\n        if (asyncManager.hasConcurrentResult()) {\n            Object result = asyncManager.getConcurrentResult();\n            mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0];\n            asyncManager.clearConcurrentResult();\n            LogFormatUtils.traceDebug(logger, traceOn -> {\n                String formatted = LogFormatUtils.formatValue(result, !traceOn);\n                return "Resume with async result [" + formatted + "]";\n            });\n            invocableMethod = invocableMethod.wrapConcurrentResult(result);\n        }\n\t\t\n        /*\n        =======================================\n        调用最终的目标handlerMethod\n        =======================================\n        */\n        invocableMethod.invokeAndHandle(webRequest, mavContainer);\n        if (asyncManager.isConcurrentHandlingStarted()) {\n            return null;\n        }\n\n        return getModelAndView(mavContainer, modelFactory, webRequest);\n    }\n    finally {\n        webRequest.requestCompleted();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n# getDataBinderFactory()\n// RequestMappingHandlerAdapter#getDataBinderFactory()\nprivate WebDataBinderFactory getDataBinderFactory(HandlerMethod handlerMethod) throws Exception {\n    Class<?> handlerType = handlerMethod.getBeanType();\n    /* 获取handlerMethod所在类中的由@InitBinder所修饰的方法 */\n    Set<Method> methods = this.initBinderCache.get(handlerType);\n    /* 如果缓存中没有handlerMethod所在类中的由@InitBinder所修饰的方法，则扫描类，然后加入缓存中 */\n    if (methods == null) {\n        methods = MethodIntrospector.selectMethods(handlerType, INIT_BINDER_METHODS);\n        this.initBinderCache.put(handlerType, methods);\n    }\n    List<InvocableHandlerMethod> initBinderMethods = new ArrayList<>();\n    /* 首先加入全局的由@InitBinder所修饰的方法 */\n    this.initBinderAdviceCache.forEach((controllerAdviceBean, methodSet) -> {\n        if (controllerAdviceBean.isApplicableToBeanType(handlerType)) {\n            Object bean = controllerAdviceBean.resolveBean();\n            for (Method method : methodSet) {\n                initBinderMethods.add(createInitBinderMethod(bean, method));\n            }\n        }\n    });\n    /* 然后再加入当前handlerMethod所在类中局部定义的相关方法 */\n    for (Method method : methods) {\n        Object bean = handlerMethod.getBean();\n        initBinderMethods.add(createInitBinderMethod(bean, method));\n    }\n    /* 直到这一步，所有的@InitBinder所修饰的方法都被封装为了InvocableHandlerMethod */\n    \n    /* 创建数据绑定器工厂 */\n    return createDataBinderFactory(initBinderMethods);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n# getModelFactory()\n// RequestMappingHandlerAdapter#getModelFactory()\nprivate ModelFactory getModelFactory(HandlerMethod handlerMethod, WebDataBinderFactory binderFactory) {\n    SessionAttributesHandler sessionAttrHandler = getSessionAttributesHandler(handlerMethod);\n    Class<?> handlerType = handlerMethod.getBeanType();\n    /* 获取局部的@ModelAttribute注解所修饰的相关方法 */\n    Set<Method> methods = this.modelAttributeCache.get(handlerType);\n    if (methods == null) {\n        methods = MethodIntrospector.selectMethods(handlerType, MODEL_ATTRIBUTE_METHODS);\n        this.modelAttributeCache.put(handlerType, methods);\n    }\n    List<InvocableHandlerMethod> attrMethods = new ArrayList<>();\n    /*\n    获取全局的@ModelAttribute注解所修饰的相关方法，同时也封装为InvocableHandlerMethod\n    全局的先加入列表\n    */\n    this.modelAttributeAdviceCache.forEach((controllerAdviceBean, methodSet) -> {\n        if (controllerAdviceBean.isApplicableToBeanType(handlerType)) {\n            Object bean = controllerAdviceBean.resolveBean();\n            for (Method method : methodSet) {\n                attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));\n            }\n        }\n    });\n    /* 局部的后加入 */\n    for (Method method : methods) {\n        Object bean = handlerMethod.getBean();\n        attrMethods.add(createModelAttributeMethod(binderFactory, bean, method));\n    }\n    /* 可以看出ModelFactory不仅保存了@ModelAttribute注解相关信息，而且还保存了WebDataBinderFactory以及与该类型所关联的SessionAttributesHandler（@SessionAttributes的类表示） */\n    return new ModelFactory(attrMethods, binderFactory, sessionAttrHandler);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n# 总结\n关于RequestMappingHandlerAdapter的分析差不多就这些，但是还涉及到其他很多组件没有分析，比如InvocableHandlerMethod, 消息转换器，参数和返回值解析器等组件。深入分析这些组件仍然很有必要。\n\n# ServletInvocableHandlerMethod\n关于ServletInvocableHandlerMethod的类体系结构如下图所示：\n\n\n\n我们依次来分析三个类。\n\n# HandlerMethod\n# 相关属性\n/* handler */\nprivate final Object bean;\n\n/* 用于新建HandlerMethod时传入的handler是String的情况，则需要根据该string作为beanName获取到对应的bean，并设置为handler */\n@Nullable\nprivate final BeanFactory beanFactory;\n\n/* handler的类型 */\nprivate final Class<?> beanType;\n\n/* 请求具体映射的方法 */\nprivate final Method method;\n\n/* 如果method是桥接方法，则bridgedMethod表示被桥的方法，如果不涉及泛型，则两者相等 */\nprivate final Method bridgedMethod;\n\n/* 请求方法所对应的参数 */\nprivate final MethodParameter[] parameters;\n/* 响应的状态码 */\n@Nullable\nprivate HttpStatus responseStatus;\n\n/* 响应的状态原因 */\n@Nullable\nprivate String responseStatusReason;\n\n/* 解析自哪个HandlerMethod，仅适用于构造方法中传入HandlerMethod对象的情况 */\n@Nullable\nprivate HandlerMethod resolvedFromHandlerMethod;\n\n/* 父接口的方法参数注解数组 */\n@Nullable\nprivate volatile List<Annotation[][]> interfaceParameterAnnotations;\n\n/* 描述信息 */\nprivate final String description;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n如果传入的bean是String类型的话，则会调用createWithResolvedBean()方法：\n\n// RequestMappingHandlerAdapter#createWithResolvedBean()\npublic HandlerMethod createWithResolvedBean() {\n    Object handler = this.bean;\n    if (this.bean instanceof String) {\n        Assert.state(this.beanFactory != null, "Cannot resolve bean name without BeanFactory");\n        String beanName = (String) this.bean;\n        handler = this.beanFactory.getBean(beanName);\n    }\n    /* 调用构造方法，比较简单，this表示的handlerMethod的属性赋值给新创建的handlerMethod，并将handler赋值给新handlerMethod的bean属性 */\n    return new HandlerMethod(this, handler);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n另外，HandlerMethod中方法参数的类型为MethodParameter。\n\n# MethodParameter\n下面是MethodParameter中的一些属性：\n\n/* 所属所在的方法，Executable是Method和Constructor的抽象父类 */\nprivate final Executable executable;\n\n/* 参数的序号，也就是第几个参数，从0开始计数 */\nprivate final int parameterIndex;\n\n/* 保存了方法参数的基本信息，如方法名称，权限修饰符等 */\n@Nullable\nprivate volatile Parameter parameter;\n\n/* 嵌套级别，如果是复合参数会用到。如对于List<String>params，params的嵌套级别是1，List内部String的嵌套级别是2。 */\nprivate int nestingLevel;\n\n/* 表示每层嵌套参数的序数 */\n@Nullable\nMap<Integer, Integer> typeIndexesPerLevel;\n\n/* 参数所属方法所在的类的类型 */\n@Nullable\nprivate volatile Class<?> containingClass;\n\n/* 参数的类型 */\n@Nullable\nprivate volatile Class<?> parameterType;\n\n/* Type型的参数类型，如果参数类型包含泛型的话，则表示原始类型 */\n@Nullable\nprivate volatile Type genericParameterType;\n\n/* 参数的注解 */\n@Nullable\nprivate volatile Annotation[] parameterAnnotations;\n\n/* 参数名称查找器 */\n@Nullable\nprivate volatile ParameterNameDiscoverer parameterNameDiscoverer;\n\n/* 参数名称 */\n@Nullable\nprivate volatile String parameterName;\n\n@Nullable\nprivate volatile MethodParameter nestedMethodParameter;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n对于MethodParameter，最重要的属性是method和parameterIndex。parameterNameDiscover的作用是查找参数名，这是因为在Java8以前，反射不能获取到参数的名称，所以需要其他手段来解决这个问题。但是Java8在class文件中保留了参数名，Parameter类中保存了参数的名称，不过，保留参数名需要打开编译开关javac -parameters，默认是关闭的。\n\n# InvocableHanlderMethod\nInvocableHandlerMethod在HandlerMethod的基础上添加了方法调用的功能，也就是说前者可以直接调用内部的method属性。另外，前者还增加了三个属性：\n\n/* 参数解析器 */\nprivate HandlerMethodArgumentResolverComposite resolvers = new HandlerMethodArgumentResolverComposite();\n\n/* 用来获取参数名称 */\nprivate ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();\n\n/* 数据绑定器工厂，被参数解析器使用 */\n@Nullable\nprivate WebDataBinderFactory dataBinderFactory;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n由@InitBinder和@ModelAttribute注解修饰的方法最后就会被封装为InvocableHandlerMethod类型的对象；但handlerMethod最后被封装为了ServletInvocableHandlerMethod类型的对象。\n\nInvocableHandlerMethod中的invokeForRequest()方法进行方法的调用：\n\n// InvokableHandlerMethod#invokeForRequest()\n@Nullable\npublic Object invokeForRequest(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n                               Object... providedArgs) throws Exception {\n\n    /* 获取方法的参数 */\n    Object[] args = getMethodArgumentValues(request, mavContainer, providedArgs);\n    if (logger.isTraceEnabled()) {\n        logger.trace("Arguments: " + Arrays.toString(args));\n    }\n    /* 反射调用方法并返回结果 */\n    return doInvoke(args);\n}\n\n// InvokableHandlerMethod#getMethodArgumentValues()\nprotected Object[] getMethodArgumentValues(NativeWebRequest request, @Nullable ModelAndViewContainer mavContainer,\n                                           Object... providedArgs) throws Exception {\n\n    /* 获取父类HandlerMethod中定义的parameters属性 */\n    MethodParameter[] parameters = getMethodParameters();\n    /* 无参则返回空数组 */\n    if (ObjectUtils.isEmpty(parameters)) {\n        return EMPTY_ARGS;\n    }\n\t\n    /* 将参数解析为对应的类型 */\n    Object[] args = new Object[parameters.length];\n    /* 遍历解析每一个参数 */\n    for (int i = 0; i < parameters.length; i++) {\n        MethodParameter parameter = parameters[i];\n        /* 给参数设置参数名解析器 */\n        parameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n        /* 先从providedArgs中获取参数，但是默认情况下不会传递providedArgs*/\n        args[i] = findProvidedArgument(parameter, providedArgs);\n        if (args[i] != null) {\n            continue;\n        }\n        /* 判断resolvers是否支持当前的参数解析 */\n        if (!this.resolvers.supportsParameter(parameter)) {\n            throw new IllegalStateException(formatArgumentError(parameter, "No suitable resolver"));\n        }\n        try {\n            /* 执行解析 */\n            args[i] = this.resolvers.resolveArgument(parameter, mavContainer, request, this.dataBinderFactory);\n        }\n        catch (Exception ex) {\n            /* 如果参数解析中出现错误，则抛出异常 */\n            // ...\n            throw ex;\n        }\n    }\n    return args;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n下面来看整个请求最核心的地方，即我们所写的handlerMethod真正被调用的地方：\n\n// InvokableHandlerMethod#doInvoke()\n@Nullable\nprotected Object doInvoke(Object... args) throws Exception {\n    Method method = getBridgedMethod();\n    /* 设置方法为可访问 */\n    ReflectionUtils.makeAccessible(method);\n    try {\n        // ...\n        /* 反射调用方法 */\n        return method.invoke(getBean(), args);\n    }\n    catch (IllegalArgumentException ex) {\n        // ...\n    }\n    catch (InvocationTargetException ex) {\n        // ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# ServletInvocableHandlerMethod\nServletInvocableHandlerMethod在父类的基础上增加了对@ResponseStatus的支持，返回值处理，异步处理等功能。\n\n笔记\n\n@ResponseStatus注解用于处理器方法或者返回值上，作用是对请求响应的状态（value和reason）进行设置。具体使用可以参考其他资料，实际用得并不多。\n\n在RequestMappingHandlerAdapter类中是把handlerMethod封装为ServletInvocableHandlerMethod的，然后调用其invokeAndHandle()方法：\n\n// ServletInvocableHandlerMethod#invokeAndHandle()\npublic void invokeAndHandle(ServletWebRequest webRequest, ModelAndViewContainer mavContainer,\n                            Object... providedArgs) throws Exception {\n\n    /* 调用父类中的方法进行实际调用，并获取返回值 */\n    Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);\n    /* 设置响应状态，内部处理了@ResponseStatus注解 */\n    setResponseStatus(webRequest);\n\n    /* 设置ModelAndViewContainer相关 */\n    if (returnValue == null) {\n        if (isRequestNotModified(webRequest) || getResponseStatus() != null || mavContainer.isRequestHandled()) {\n            disableContentCachingIfNecessary(webRequest);\n            mavContainer.setRequestHandled(true);\n            return;\n        }\n    }\n    else if (StringUtils.hasText(getResponseStatusReason())) {\n        mavContainer.setRequestHandled(true);\n        return;\n    }\n\n    mavContainer.setRequestHandled(false);\n    Assert.state(this.returnValueHandlers != null, "No return value handlers");\n    try {\n        /* 处理返回值 */\n        this.returnValueHandlers.handleReturnValue(\n            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);\n    }\n    catch (Exception ex) {\n        if (logger.isTraceEnabled()) {\n            logger.trace(formatErrorForReturnValue(returnValue), ex);\n        }\n        throw ex;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n# ModelAndViewContainer\nModelAndViewContainer在整个请求过程中起着数据传递的作用。\n\n# 相关属性\n/* 是否在处理器返回redirect视图时一定不使用defaultModel */\nprivate boolean ignoreDefaultModelOnRedirect = false;\n\n/* 视图，可以是实际视图也可以是String类型的逻辑视图 */\n@Nullable\nprivate Object view;\n\n/* 默认使用的Model */\nprivate final ModelMap defaultModel = new BindingAwareModelMap();\n\n/* redirect类型的Model */\n@Nullable\nprivate ModelMap redirectModel;\n\n/* 处理器返回redirect视图的标志 */\nprivate boolean redirectModelScenario = false;\n\n@Nullable\nprivate HttpStatus status;\n\nprivate final Set<String> noBinding = new HashSet<>(4);\n\nprivate final Set<String> bindingDisabled = new HashSet<>(4);\n\n/* 用于设置SessionAttribute使用完成的标志 */\nprivate final SessionStatus sessionStatus = new SimpleSessionStatus();\n\n/* 请求是否已处理完成的标志 */\nprivate boolean requestHandled = false;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n# addAllAttributes()\n在RequestMappingHandlerAdapter中的invokeHandlerMethod()方法中创建了ModelAndViewContainer，并调用了几个方法，下面来看一下。\n\n// ModelAndViewContainer#addAllAttributes()\n/* \nModelAndViewContainer mavContainer = new ModelAndViewContainer();\nmavContainer.addAllAttributes(RequestContextUtils.getInputFlashMap(request));\n*/\npublic ModelAndViewContainer addAllAttributes(@Nullable Map<String, ?> attributes) {\n    /* 将所有请求的参数保存到model中 */\n    getModel().addAllAttributes(attributes);\n    return this;\n}\n\n/* 返回使用哪个model */\npublic ModelMap getModel() {\n    if (useDefaultModel()) {\n        return this.defaultModel;\n    }\n    else {\n        if (this.redirectModel == null) {\n            this.redirectModel = new ModelMap();\n        }\n        return this.redirectModel;\n    }\n}\n\n// ModelAndViewContainer#useDefaultModel()\n/* \n判断是使用defaultModel还是redirectModel ，总结如下：\n返回defaultModel的情况：\n  1. 处理器返回的不是redirect视图\n  2. 处理器返回的是redirect视图，但是redirectModel为null，而且ignoreDefaultModelOnRedirect也是false\n返回redirectModel的情况：\n  1. 处理器返回的是redirect视图，且redirectModel不是null\n  2. 处理器返回的是redirect视图，且ignoreDefaultModelOnRedirect不是false\n*/\n/* \n在处理handlerMethod的返回值时会判断是不是redirect视图，然后会设置ignoreDefaultModelOnRedirect的值,有下面的方法调用\nmavContainer.setIgnoreDefaultModelOnRedirect(this.ignoreDefaultModelOnRedirect);\n*/\nprivate boolean useDefaultModel() {\n    return (!this.redirectModelScenario || (this.redirectModel == null && !this.ignoreDefaultModelOnRedirect));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n# SessionAttriutesHandler\n前面提到，SessionAttributesHandler是@SessionAttributes注解的类表示。\n\n# 相关属性\n/* 存储了@SessionAttributes中value对应的值 */\nprivate final Set<String> attributeNames = new HashSet<>();\n\n/* 存储了@SessionAttributes中types对应的值 */\nprivate final Set<Class<?>> attributeTypes = new HashSet<>();\n\n/* \n存储所有已知可以被当前SessionAttriutesHandler处理的属性名，在attributeNames和attributeTypes的基础上进行判断和转换。\n*/\nprivate final Set<String> knownAttributeNames = Collections.newSetFromMap(new ConcurrentHashMap<>(4));\n\n/* \nSessionAttributeStore是SessionAttributes的存储工具，但不是存储到SessionAttributeStore中的，\nSessionAttributes是在Model和session中存储，不过可以重写SessionAttributeStore来改变存储位置。\n*/\nprivate final SessionAttributeStore sessionAttributeStore;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n# 构造方法\n/* \n当在RequestMappingHandlerAdapter中创建SessionAttributesHandler时，传递过来的sessionAttributeStore是RequestMappingHandlerAdapter属性，是SessionAttributeStore的唯一子类DefaultSessionAttributeStore类型的实例。\n*/\npublic SessionAttributesHandler(Class<?> handlerType, SessionAttributeStore sessionAttributeStore) {\n    Assert.notNull(sessionAttributeStore, "SessionAttributeStore may not be null");\n    this.sessionAttributeStore = sessionAttributeStore;\n\n    /* 获取@SessionAttributes注解信息。 */\n    SessionAttributes ann = AnnotatedElementUtils.findMergedAnnotation(handlerType, SessionAttributes.class);\n    /* 如果存在该注解，则保存注解中的信息到该处理器中。 */\n    if (ann != null) {\n        Collections.addAll(this.attributeNames, ann.names());\n        Collections.addAll(this.attributeTypes, ann.types());\n    }\n    this.knownAttributeNames.addAll(this.attributeNames);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n# ModelFactory\n# 构造方法\n在RequestMappingHandlerAdapter的invokeHandlerMethod()方法中，通过调用自己的getModelFactory()方法解析与当前handlerType相关的@ModelAttribute注解并获取ModelFactory实例。\n\n（可以再往上翻，复习一下getModelFactory()方法）\n\n/* \nhandlerMethods中保存了需要提前执行的方法 \n*/\npublic ModelFactory(@Nullable List<InvocableHandlerMethod> handlerMethods,\n                    WebDataBinderFactory binderFactory, SessionAttributesHandler attributeHandler) {\n\n    if (handlerMethods != null) {\n        for (InvocableHandlerMethod handlerMethod : handlerMethods) {\n            /* \n            将InvocableHandlerMethod封装为ModelMethod \n            ModelMethod的构造方法中进行了handlerMethod的依赖判断，这里的依赖指的是方法的参数。\n            ModelMethod就是封装了HandlerMethod和方法的参数。\n            */\n            this.modelMethods.add(new ModelMethod(handlerMethod));\n        }\n    }\n    this.dataBinderFactory = binderFactory;\n    this.sessionAttributesHandler = attributeHandler;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 初始化Model\n然后调用ModelFactory的initModel()方法进行初始化。\n\n// ModelFactory#initModel()\npublic void initModel(NativeWebRequest request, ModelAndViewContainer container, HandlerMethod handlerMethod)\n    throws Exception {\n\n    /* \n    第一步：\n    从sessionAttributes中取出与当前请求有关的参数及合并到Model中 \n    */\n    Map<String, ?> sessionAttributes = this.sessionAttributesHandler.retrieveAttributes(request);\n    /* 注意，只会放入model中不存在的属性 */\n    container.mergeAttributes(sessionAttributes);\n    /* \n    第二步：\n    执行注释了@ModelAttribute注解修饰的方法并将结果设置到Model中 \n    */\n    invokeModelAttributeMethods(request, container);\n\n    /* \n    第三步：\n    findSessionAttributeArguments获取到了handlerMethod中所有被@ModelAttribute修饰且被@SessionAttributes注解所配置的参数名。\n    特别注意，这一步目前还不能理解，感觉和第一步的操作重合了。\n    为什么这里不直接判断如果不在model中就抛出异常，而非要再去sessionAttributesHandler中获取一次？\n    现在就请记住如果同时使用@ModelAttributes和@SessionAttributes修饰的参数，就要确保在session中确实存在，否则报错。\n    */\n    for (String name : findSessionAttributeArguments(handlerMethod)) {\n        /* 如果该参数不在Model中 */\n        if (!container.containsAttribute(name)) {\n            /* 则根据@ModelAttribute中value属性值作为参数名去sessionAttributes中获取值 */\n            Object value = this.sessionAttributesHandler.retrieveAttribute(request, name);\n            /* 如果获取不到就抛出异常 */\n            if (value == null) {\n                throw new HttpSessionRequiredException("Expected session attribute \'" + name + "\'", name);\n            }\n            /* 如果获取到了就加入Model中 */\n            container.addAttribute(name, value);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\ninitModel()方法可以分为三步，其中第二步是调用invokeModelAttributeMethods()来完成的。\n\n// ModelFactory#invokeModelAttributeMethods()\nprivate void invokeModelAttributeMethods(NativeWebRequest request, ModelAndViewContainer container)\n    throws Exception {\n\n    while (!this.modelMethods.isEmpty()) {\n        /* 获取由@ModelAttributes修饰的方法，调用了getNextModelMethod() */\n        InvocableHandlerMethod modelMethod = getNextModelMethod(container).getHandlerMethod();\n        /* 获取该方法上的@ModelAttribute注解 */\n        ModelAttribute ann = modelMethod.getMethodAnnotation(ModelAttribute.class);\n        Assert.state(ann != null, "No ModelAttribute annotation");\n        /* 如果Model中已经存在与@ModelAttribute注解中同名的数据，则跳过 */\n        if (container.containsAttribute(ann.name())) {\n            if (!ann.binding()) {\n                container.setBindingDisabled(ann.name());\n            }\n            continue;\n        }\n\t\t/* 调用方法 */\n        Object returnValue = modelMethod.invokeForRequest(request, container);\n        /* 如果返回值为空，则跳过继续 */\n        if (modelMethod.isVoid()) {\n            if (StringUtils.hasText(ann.value())) {\n                if (logger.isDebugEnabled()) {\n                    logger.debug("Name in @ModelAttribute is ignored because method returns void: " +\n                                 modelMethod.getShortLogMessage());\n                }\n            }\n            continue;\n        }\n\t\t\n        /* 如果返回值非空，则获取返回值的名称 */\n        String returnValueName = getNameForReturnValue(returnValue, modelMethod.getReturnType());\n        if (!ann.binding()) {\n            container.setBindingDisabled(returnValueName);\n        }\n        /* 如果Model中不存在returnValueName该属性，那么添加进去 */\n        if (!container.containsAttribute(returnValueName)) {\n            container.addAttribute(returnValueName, returnValue);\n        }\n    }\n}\n\n// ModelFactory#getNextModelMethod()\nprivate ModelMethod getNextModelMethod(ModelAndViewContainer container) {\n    for (ModelMethod modelMethod : this.modelMethods) {\n        /* \n        检查方法的参数是否已经在ModelAndViewContainer中了，如果在则移除并返回，\n        checkDependencies()是根据参数的名称来判断的。\n        */\n        if (modelMethod.checkDependencies(container)) {\n            this.modelMethods.remove(modelMethod);\n            return modelMethod;\n        }\n    }\n    /* 如果所有的方法都不能满足方法参数，则返回第一个。 */\n    ModelMethod modelMethod = this.modelMethods.get(0);\n    this.modelMethods.remove(modelMethod);\n    return modelMethod;\n}\n\n// ModelFactory#getNameForReturnValue()\npublic static String getNameForReturnValue(@Nullable Object returnValue, MethodParameter returnType) {\n    ModelAttribute ann = returnType.getMethodAnnotation(ModelAttribute.class);\n    /* 如果@ModelAttribute注解有值，那么则使用该值作为返回值的名称 */\n    if (ann != null && StringUtils.hasText(ann.value())) {\n        return ann.value();\n    }\n    else {\n        Method method = returnType.getMethod();\n        Assert.state(method != null, "No handler method");\n        Class<?> containingClass = returnType.getContainingClass();\n        Class<?> resolvedType = GenericTypeResolver.resolveReturnType(method, containingClass);\n        /* 根据方法，返回值类型和返回值获取参数名，这里就不分析具体的细节了。记住如果不指定@ModelAttribute的value值的话，那么会根据规则生成。 */\n        return Conventions.getVariableNameForReturnType(method, resolvedType, returnValue);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\ninitModel()方法的第三步调用了findSessionAttributeArguments()方法：\n\n// ModelFactory#findSessionAttributeArguments()\nprivate List<String> findSessionAttributeArguments(HandlerMethod handlerMethod) {\n    List<String> result = new ArrayList<>();\n    for (MethodParameter parameter : handlerMethod.getMethodParameters()) {\n        /* 如果该方法参数被@ModelAttribute注解修饰，则继续 */\n        if (parameter.hasParameterAnnotation(ModelAttribute.class)) {\n            /* 如果@ModelAttribute注解中指定了参数名，则使用；否则根据规则生成。*/\n            String name = getNameForParameter(parameter);\n            Class<?> paramType = parameter.getParameterType();\n            /* 如果该参数同时在@SessionAttributes注解中配置了（通过指定参数名或参数类型） */\n            if (this.sessionAttributesHandler.isHandlerSessionAttribute(name, paramType)) {\n                result.add(name);\n            }\n        }\n    }\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# 更新Model\n在RequestMappingHandlerAdapter中的getModelAndView（）方法中，调用了ModelFactory中的updateModel()方法来更新Model。\n\n// ModelFactory#updateModel()\npublic void updateModel(NativeWebRequest request, ModelAndViewContainer container) throws Exception {\n    ModelMap defaultModel = container.getDefaultModel();\n    if (container.getSessionStatus().isComplete()){\n        this.sessionAttributesHandler.cleanupAttributes(request);\n    }\n    else {\n        this.sessionAttributesHandler.storeAttributes(request, defaultModel);\n    }\n    if (!container.isRequestHandled() && container.getModel() == defaultModel) {\n        updateBindingResult(request, defaultModel);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# HandlerMethodArgumentResolver\nHandlerMethodArgumentResolver接口定义了两个方法：\n\npublic interface HandlerMethodArgumentResolver {\n\t/* 是否支持解析某种类型的参数 */\n\tboolean supportsParameter(MethodParameter parameter);\n\n    /* 执行参数解析 */\n\t@Nullable\n\tObject resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n\t\t\tNativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nhandlerMethod方法的解析是在InvokableHandlerMethod中的getMethodArgumentValues()方法中通过HandlerMethodArgumentResolverComposite实例来解析的。因为有很多解析器，所以SpringMVC采用了复合类的方式。\n\n下面来看一下HandlerMethodArgumentResolverComposite中的主要方法：\n\n// HandlerMethodArgumentResolverComposite#supportsParameter()\n@Override\npublic boolean supportsParameter(MethodParameter parameter) {\n    /* 如果获取到了对应的解析器，则表示支持解析 */\n    return getArgumentResolver(parameter) != null;\n}\n\n// HandlerMethodArgumentResolverComposite#getArgumentResolver()\n@Nullable\nprivate HandlerMethodArgumentResolver getArgumentResolver(MethodParameter parameter) {\n    /* \n    argumentResolverCache中缓存了MethodParameter与HandlerMethodArgumentResolver的映射，不用每次都遍历所有的解析器。\n    */\n    HandlerMethodArgumentResolver result = this.argumentResolverCache.get(parameter);\n    if (result == null) {\n        for (HandlerMethodArgumentResolver resolver : this.argumentResolvers) {\n            /* 获取到了已匹配的解析器 */\n            if (resolver.supportsParameter(parameter)) {\n                result = resolver;\n                this.argumentResolverCache.put(parameter, result);\n                break;\n            }\n        }\n    }\n    return result;\n}\n\n// HandlerMethodArgumentResolverComposite#resolveArgument()\n@Override\n@Nullable\npublic Object resolveArgument(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,\n                              NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory) throws Exception {\n\n    /* 获取解析器 */\n    HandlerMethodArgumentResolver resolver = getArgumentResolver(parameter);\n    if (resolver == null) {\n        throw new IllegalArgumentException("Unsupported parameter type [" +\n                                           parameter.getParameterType().getName() + "]. supportsParameter should be called first.");\n    }\n    /* 调用具体的解析器进行解析 */\n    return resolver.resolveArgument(parameter, mavContainer, webRequest, binderFactory);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\nSpringMVC中的解析器有两种命名方式，一种是XXXMethodArgumentResolver，另一种是XXXMethodProcess的。前者表示一个参数解析器，后者除了可以解析参数外还可以处理相应类型的返回值，也就是HandlerMethodReturnValueHandler。\n\n由于参数解析器种类繁多，所以后面单独写文分析每一种解析器。搞懂参数解析器有利于解释为什么参数不能绑定这样的疑惑。\n\n# HandlerMethodReturnValueHandler\n返回值的处理是在ServletInvocableHandlerMethod的invokeAndHandle()方法中进行的。和参数解析类似，也是通过复合类HandlerMethodReturnValueHandlerComposite进行的。\n\nHandlerMethodReturnValueHandler接口中定义了两个方法：\n\npublic interface HandlerMethodReturnValueHandler {\n\t/* 是否支持该某种返回值类型 */\n\tboolean supportsReturnType(MethodParameter returnType);\n\t\n    /* 处理返回值 */\n\tvoid handleReturnValue(@Nullable Object returnValue, MethodParameter returnType,\n\t\t\tModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nHandlerMethodReturnValueHandlerComposite中的逻辑和HandlerMethodArgumentResolverComposite中的比较类似，这里就不贴代码了。\n\n同样地，返回值处理器也有很多种，后面单独写文分析每一种。\n\n# 总结\n本文分析了HandlerAdapter体系中最重要也是最复杂的分支ReqeustMappingHandlerAdapter，该适配器处理HandlerMethod，也就是我们用@RequestMapping修饰的方法。整个过程可以分为三步：解析参数，执行请求和处理返回值。\n\n最复杂的莫属参数解析了，因为参数来源有很多个，大体可以分为两大类，一类是从Model来，另一类从request中来。整个处理过程ModelAndViewContainer起着参数传递的作用。\n\n执行请求是通过ServletInvocableHandlerMethod的invokeAndHandler()进行的（实际上是通过父类InvocableHandlerMethod中的invokeForRequest()方法），该方法中同时还进行了返回值的处理。\n\n一定要把本文所述的处理流程搞明白，才能避免一些基础性问题，如参数绑定失败。\n\n# 参考\n * HandlerAdapter前置知识点\n * HandlerAdapter源码分析\n * 《看透SpringMVC 源码分析与实战》\n * 从原理层面掌握@SessionAttributes注解',normalizedContent:'前面一篇文章分析了dispatcherservlet初始化和获取handlerexecutionchain的过程，接下来就是要执行handler了。因为handler有很多种，不同的handler不一定都会通过handlermethod来执行方法，所以springmvc引入了handleradapter，顾名思义，这是handler的适配器，目的是适配获取到的多种handler。\n\n注意\n\n本文中的spring源码版本为5.3.2，不过本文中涉及的大部分内容相比之前版本都是大同小异。另外，本文中所展示的源码可能会有些删减，避免冗长。\n\n# handleradapter体系\n因为有多种handler，所以就有多种对用的adapter。相比handlermapping体系，handleradapter就比较扁平化了。\n\n\n\n在dispatcherservlet.properties中，定义了默认使用的handleradapter，如果没有配置其他的适配器，那么在springmvc容器刷新时就会初始化下列这些适配器：\n\norg.springframework.web.servlet.handleradapter=org.springframework.web.servlet.mvc.httprequesthandleradapter,\\\n\torg.springframework.web.servlet.mvc.simplecontrollerhandleradapter,\\\n\torg.springframework.web.servlet.mvc.method.annotation.requestmappinghandleradapter,\\\n\torg.springframework.web.servlet.function.support.handlerfunctionadapter\n\n\n1\n2\n3\n4\nabstracthandlermethodadapter分支处理包含handlermethod类型的handlermapping，我们会重点分析该分支。\n\n# requestmappinghandleradapter\n# 相关属性\n先来看一下requestmappinghandleradapter中的主要属性。\n\n# 参数解析器\n/* \ncustomargumentresolvers 保存了开发者手动注入的参数解析器或者是springmvc提供的默认解析器,当初始化requestmappinghandleradapter的时候，就会将customargumentresolvers中的所有解析器整合到argumentresolvers中，composite就是整合的意思。handlermethodargumentresolvercomposite内部有一个维护handlermethodargumentresolver的集合。\n*/\nprivate list<handlermethodargumentresolver> customargumentresolvers;\nprivate handlermethodargumentresolvercomposite argumentresolvers;\n\n/*\ninitbinderargumentresolvers中保存了解析由@initbinder修饰的方法的参数的解析器。\n*/\nprivate handlermethodargumentresolvercomposite initbinderargumentresolvers;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n# 返回值解析器\n/*\n下面两个属性与返回值解析器有关，和参数解析器类似。\n*/\nprivate list<handlermethodreturnvaluehandler> customreturnvaluehandlers;\nprivate handlermethodreturnvaluehandlercomposite returnvaluehandlers;\n\n\n1\n2\n3\n4\n5\n# 消息转换器\n/*\n消息转换器，在springmvc中及其重要。作用是将消息从某种类型转换为目标类型。比如前端传入json格式的数据，后端接口以domain对象接收，则需要将json数据转换为各种类型的对象属性。这就需要消息转换器。\n*/\nprivate list<httpmessageconverter<?>> messageconverters;\n\n\n1\n2\n3\n4\n# session相关\n/*\nsessionattributestore是一个工具类，方便存取键值对到session中。\n*/\nprivate sessionattributestore sessionattributestore = new defaultsessionattributestore();\n\n/*\nsessionattributeshandler类是@sessionattributes注解的类表示形式，该注解只能作用域类上，所以该map属性表示的是类名与@sessionattributes注解表示类直接的映射。\n*/\nprivate final map<class<?>, sessionattributeshandler> sessionattributeshandlercache = new concurrenthashmap<>(64);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n笔记\n\n@sessionattributes注解表示model中哪些属性应该存取到session中，声明在类上。该注解有两个参数，names和types，前者表示对应model中哪些名称的参数应该被存放进session中，后者表示哪些类型的参数应该被放进session中。注意@sessionattributes注解不会与视图为redirect的model进行交互。\n\n关于sessionattributeshandler请参考下文。\n\n@sessionattribute（注意区分）注解作用在参数上，表示将session属性中的数据绑定到该参数上。\n\n# initbinder相关\n/*\ninitbindercache保存了类与类中@initbinder注解修饰的方法组成的集合之间的映射。\ninitbinderadvicecache类似，只不过这里的类是指由@controlleradvice修饰的类。\n*/\nprivate final map<class<?>, set<method>> initbindercache = new concurrenthashmap<>(64);\nprivate final map<controlleradvicebean, set<method>> initbinderadvicecache = new linkedhashmap<>();\n\n\n1\n2\n3\n4\n5\n6\n笔记\n\n@controlleradvice注解修饰的类中的由@exceptionhandler，@initbinder，@modelattribute注解修饰的方法会对多个controller有效。可以通过某些@controlleradvice中的basepackages属性指定对哪些包下面的controller有效；也可以通过assignabletypes属性指定对哪些类型的controller有效；同时可以通过annotations属性指定对由哪些注解修饰的controller有效。\n\n笔记\n\n@initbinder注解修饰controller或controlleradvice中的方法，一般可以用来注册自定义的参数解析器。在当前controller中其他所有handlermethod执行之前都会先执行该方法。\n\n# modelattribute相关\n/*\nmodelattributecache表示类与类中由@modelattrubite注解修饰的方法组成的集合之间的映射。\nmodelattributeadvicecache表示由@controlleradvice注解修饰的类中由@modelattrubite注解修饰的方法组成的集合之间的映射。\n*/\nprivate final map<class<?>, set<method>> modelattributecache = new concurrenthashmap<>(64);\nprivate final map<controlleradvicebean, set<method>> modelattributeadvicecache = new linkedhashmap<>();\n\n\n1\n2\n3\n4\n5\n6\n笔记\n\n被@modelattribute注解但没有被@requestmapping注解修饰的方法在controller方法执行前，都会执行一次该注解标注的方法，并且方法的返回值被以键值对的方式放入model中，键为注解中value的属性值（如果每指定该属性值，则按照一定规则生成，详情请参考api doc），值为返回值；被它修饰的方法参数表示从model中取出参数并赋值给该参数。\n\n注意，如果一个方法同时被@modelattribute和@requestmapping修饰，不会被提前执行。\n\n这里的model是一个贯穿springmvc的东西，其实就是一个map，封装参数。\n\n# 其他属性\n/* \nrequestresponsebodyadvice保存了各种requestbodyadvice和responsebodyadvice。\n注意requestbodyadvice和responsebodyadvice是接口不是注解，这两个接口的实现类要被@controlleradvice修饰，否则不会被扫描到（在initcontrolleradvicecache()中会看到具体逻辑。）。\nrequestbodyadvice表示在请求体被读取和被转换为目标类型之前允许进行自定义处理，也允许被转换后的参数在被绑定到由@requestbody或@httpentity注解修饰的参数之前进行自定义处理。\nresponsebodyadvice则是表示在由@responsebody或@responseentity修饰的方法之后且在响应体被httpmessageconverter处理之前进行自定义处理。\n这两个接口可以用来对请求体解密和对响应体进行加密（不过我目前没用过），比使用拦截器更优雅。\n*/\nprivate final list<object> requestresponsebodyadvice = new arraylist<>();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 构造方法\npublic requestmappinghandleradapter() {\n    /* 其实构造器中就这是完成了设置消息转换器的工作 */\n    this.messageconverters = new arraylist<>(4);\n    this.messageconverters.add(new bytearrayhttpmessageconverter());\n    this.messageconverters.add(new stringhttpmessageconverter());\n    if (!shouldignorexml) {\n        try {\n            this.messageconverters.add(new sourcehttpmessageconverter<>());\n        }\n        catch (error err) {\n            // ignore when no transformerfactory implementation is available\n        }\n    }\n    /* 重点关注该类型的解析器 */\n    this.messageconverters.add(new allencompassingformhttpmessageconverter());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\npublic class allencompassingformhttpmessageconverter extends formhttpmessageconverter {\n    /* 加载当前类时加载各种转换器用到的依赖 */\n    static {\n        classloader classloader = allencompassingformhttpmessageconverter.class.getclassloader();\n        jaxb2present = classutils.ispresent("javax.xml.bind.binder", classloader);\n        jackson2present = classutils.ispresent("com.fasterxml.jackson.databind.objectmapper", classloader) &&\n            classutils.ispresent("com.fasterxml.jackson.core.jsongenerator", classloader);\n        jackson2xmlpresent = classutils.ispresent("com.fasterxml.jackson.dataformat.xml.xmlmapper", classloader);\n        jackson2smilepresent = classutils.ispresent("com.fasterxml.jackson.dataformat.smile.smilefactory", classloader);\n        gsonpresent = classutils.ispresent("com.google.gson.gson", classloader);\n        jsonbpresent = classutils.ispresent("javax.json.bind.jsonb", classloader);\n        kotlinserializationjsonpresent = classutils.ispresent("kotlinx.serialization.json.json", classloader);\n    }\n    \n    /* \n    添加各种转换器，addpartconverter是父类的方法，这些转换器保存在父类中定义的partconverters属性中。\n    private list<httpmessageconverter<?>> partconverters = new arraylist<>();\n    */\n    public allencompassingformhttpmessageconverter() {\n        if (!shouldignorexml) {\n            try {\n                addpartconverter(new sourcehttpmessageconverter<>());\n            }\n            catch (error err) {\n                // ignore when no transformerfactory implementation is available\n            }\n\n            if (jaxb2present && !jackson2xmlpresent) {\n                addpartconverter(new jaxb2rootelementhttpmessageconverter());\n            }\n        }\n\n        if (jackson2present) {\n            addpartconverter(new mappingjackson2httpmessageconverter());\n        }\n        else if (gsonpresent) {\n            addpartconverter(new gsonhttpmessageconverter());\n        }\n        else if (jsonbpresent) {\n            addpartconverter(new jsonbhttpmessageconverter());\n        }\n        else if (kotlinserializationjsonpresent) {\n            addpartconverter(new kotlinserializationjsonhttpmessageconverter());\n        }\n\n        if (jackson2xmlpresent && !shouldignorexml) {\n            addpartconverter(new mappingjackson2xmlhttpmessageconverter());\n        }\n\n        if (jackson2smilepresent) {\n            addpartconverter(new mappingjackson2smilehttpmessageconverter());\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n# afterproperties()\nrequestmappinghandleradapter实现了initializingbean，所以创建该类型的bean时会调用下列回调方法：\n\n// requestmappinghandleradapter#afterpropertiesset()\n@override\npublic void afterpropertiesset() {\n    /*\n    初始化处理由@controlleradvice修饰的类中的@modelattribute以及@initbinder注解，建立这些被修饰的方法与对应类型的映射关系并存放到上面提到的各种以cache结尾的map属性中。\n    */\n    initcontrolleradvicecache();\n\n    if (this.argumentresolvers == null) {\n        /* \n        获取默认的参数解析器并放入复合类中。\n        getdefaultargumentresolvers()中的逻辑很简单，就不贴代码了，主要是创建列表，然后添加各种默认的参数解析器，添加的默认的解析器也比较多。\n        */\n        list<handlermethodargumentresolver> resolvers = getdefaultargumentresolvers();\n        this.argumentresolvers = new handlermethodargumentresolvercomposite().addresolvers(resolvers);\n    }\n    if (this.initbinderargumentresolvers == null) {\n        /* \n        获取处理解析由@initbinder注解修饰的方法的参数的解析器。\n        getdefaultinitbinderargumentresolvers()的逻辑和getdefaultargumentresolvers()类似。\n        */\n        list<handlermethodargumentresolver> resolvers = getdefaultinitbinderargumentresolvers();\n        this.initbinderargumentresolvers = new handlermethodargumentresolvercomposite().addresolvers(resolvers);\n    }\n    if (this.returnvaluehandlers == null) {\n        /* \n        获取处理默认的返回值解析器。\n        getdefaultreturnvaluehandlers()的逻辑也很简单，就不贴代码了。\n        */\n        list<handlermethodreturnvaluehandler> handlers = getdefaultreturnvaluehandlers();\n        this.returnvaluehandlers = new handlermethodreturnvaluehandlercomposite().addhandlers(handlers);\n    }\n}\n\n// requestmappinghandleradapter#initcontrolleradvicecache()\nprivate void initcontrolleradvicecache() {\n    if (getapplicationcontext() == null) {\n        return;\n    }\n\n    list<controlleradvicebean> advicebeans = controlleradvicebean.findannotatedbeans(getapplicationcontext());\n\n    list<object> requestresponsebodyadvicebeans = new arraylist<>();\n\n    /* 解析由@controlleradvice注解修饰的类中的各种注解修饰的方法 */\n    for (controlleradvicebean advicebean : advicebeans) {\n        class<?> beantype = advicebean.getbeantype();\n        if (beantype == null) {\n            throw new illegalstateexception("unresolvable type for controlleradvicebean: " + advicebean);\n        }\n        set<method> attrmethods = methodintrospector.selectmethods(beantype, model_attribute_methods);\n        if (!attrmethods.isempty()) {\n            this.modelattributeadvicecache.put(advicebean, attrmethods);\n        }\n        set<method> bindermethods = methodintrospector.selectmethods(beantype, init_binder_methods);\n        if (!bindermethods.isempty()) {\n            this.initbinderadvicecache.put(advicebean, bindermethods);\n        }\n        if (requestbodyadvice.class.isassignablefrom(beantype) || responsebodyadvice.class.isassignablefrom(beantype)) {\n            requestresponsebodyadvicebeans.add(advicebean);\n        }\n    }\n\n    /* 如果扫描到了自定义的request(response)bodyadvice，则加入到requestresponsebodyadvice属性中。*/\n    if (!requestresponsebodyadvicebeans.isempty()) {\n        this.requestresponsebodyadvice.addall(0, requestresponsebodyadvicebeans);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n# handlerinternal()\n在dispatcherservlet的dodispatch()方法中，获取到适配器后，就调用适配器的handle()方法，该方法是hanlderadapter接口所定义的。abstracthandlermethodadapter实现了handle()方法，不过调用了自己定义的模板方法handleinternal()方法（是不是和上一篇文章中讲到的gethandlerinternal()很类似，都属于模板方法），该方法留给子类实现。\n\n下面来看requestmappinghandleradapter定义的handlerinternal()方法：\n\n// requestmappinghandleradapter#handlerinternal()\n@override\nprotected modelandview handleinternal(httpservletrequest request,\n                                      httpservletresponse response, handlermethod handlermethod) throws exception {\n\n    modelandview mav;\n    /* 检查请求，判断请求方法是否在所支持的方法内，以及是否要求当前请求必须属于某个session中 */\n    checkrequest(request);\n\n    /* session同步，暂时不分析，先不管 */\n    if (this.synchronizeonsession) {\n        httpsession session = request.getsession(false);\n        if (session != null) {\n            object mutex = webutils.getsessionmutex(session);\n            synchronized (mutex) {\n                mav = invokehandlermethod(request, response, handlermethod);\n            }\n        }\n        else {\n            // no httpsession available -> no mutex necessary\n            mav = invokehandlermethod(request, response, handlermethod);\n        }\n    }\n    else {\n        // no synchronization on session demanded at all...\n        mav = invokehandlermethod(request, response, handlermethod);\n    }\n\n    if (!response.containsheader(header_cache_control)) {\n        if (getsessionattributeshandler(handlermethod).hassessionattributes()) {\n            applycacheseconds(response, this.cachesecondsforsessionattributehandlers);\n        }\n        else {\n            prepareresponse(response);\n        }\n    }\n\n    return mav;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n# invokehandlermethod()\n下面关注invokehandlermethod()方法：\n\n// requestmappinghandleradapter#invokehandlermethod()\n@nullable\nprotected modelandview invokehandlermethod(httpservletrequest request,\n                                           httpservletresponse response, handlermethod handlermethod) throws exception {\n\n    servletwebrequest webrequest = new servletwebrequest(request, response);\n    try {\n        /* 处理@initbinder与@modelattribute（包括@sessionattributes）注解 */\n        webdatabinderfactory binderfactory = getdatabinderfactory(handlermethod);\n        modelfactory modelfactory = getmodelfactory(handlermethod, binderfactory);\n\n        /* 将真正的handlermethod转换成servletinvocablehandlermethod */\n        servletinvocablehandlermethod invocablemethod = createinvocablehandlermethod(handlermethod);\n        \n        /* 给handlermethod设置参数解析器 */\n        if (this.argumentresolvers != null) {\n            invocablemethod.sethandlermethodargumentresolvers(this.argumentresolvers);\n        }\n        /* 给handlermethod设置返回值解析器 */\n        if (this.returnvaluehandlers != null) {\n\t\t\t invocablemethod.sethandlermethodreturnvaluehandlers(this.returnvaluehandlers);\n        }\n        /* 给handlermethod设置数据绑定器工厂 */\n        invocablemethod.setdatabinderfactory(binderfactory);\n        invocablemethod.setparameternamediscoverer(this.parameternamediscoverer);\n\n        modelandviewcontainer mavcontainer = new modelandviewcontainer();\n        mavcontainer.addallattributes(requestcontextutils.getinputflashmap(request));\n        /* 再次整合请求携带的数据，最终modelfactory包含了本次请求中所有的数据 */\n        modelfactory.initmodel(webrequest, mavcontainer, invocablemethod);\n        mavcontainer.setignoredefaultmodelonredirect(this.ignoredefaultmodelonredirect);\n\n        /* 异步相关，暂时不分析 */\n        asyncwebrequest asyncwebrequest = webasyncutils.createasyncwebrequest(request, response);\n        asyncwebrequest.settimeout(this.asyncrequesttimeout);\n\n        webasyncmanager asyncmanager = webasyncutils.getasyncmanager(request);\n        asyncmanager.settaskexecutor(this.taskexecutor);\n        asyncmanager.setasyncwebrequest(asyncwebrequest);\n        asyncmanager.registercallableinterceptors(this.callableinterceptors);\n        asyncmanager.registerdeferredresultinterceptors(this.deferredresultinterceptors);\n\n        if (asyncmanager.hasconcurrentresult()) {\n            object result = asyncmanager.getconcurrentresult();\n            mavcontainer = (modelandviewcontainer) asyncmanager.getconcurrentresultcontext()[0];\n            asyncmanager.clearconcurrentresult();\n            logformatutils.tracedebug(logger, traceon -> {\n                string formatted = logformatutils.formatvalue(result, !traceon);\n                return "resume with async result [" + formatted + "]";\n            });\n            invocablemethod = invocablemethod.wrapconcurrentresult(result);\n        }\n\t\t\n        /*\n        =======================================\n        调用最终的目标handlermethod\n        =======================================\n        */\n        invocablemethod.invokeandhandle(webrequest, mavcontainer);\n        if (asyncmanager.isconcurrenthandlingstarted()) {\n            return null;\n        }\n\n        return getmodelandview(mavcontainer, modelfactory, webrequest);\n    }\n    finally {\n        webrequest.requestcompleted();\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n# getdatabinderfactory()\n// requestmappinghandleradapter#getdatabinderfactory()\nprivate webdatabinderfactory getdatabinderfactory(handlermethod handlermethod) throws exception {\n    class<?> handlertype = handlermethod.getbeantype();\n    /* 获取handlermethod所在类中的由@initbinder所修饰的方法 */\n    set<method> methods = this.initbindercache.get(handlertype);\n    /* 如果缓存中没有handlermethod所在类中的由@initbinder所修饰的方法，则扫描类，然后加入缓存中 */\n    if (methods == null) {\n        methods = methodintrospector.selectmethods(handlertype, init_binder_methods);\n        this.initbindercache.put(handlertype, methods);\n    }\n    list<invocablehandlermethod> initbindermethods = new arraylist<>();\n    /* 首先加入全局的由@initbinder所修饰的方法 */\n    this.initbinderadvicecache.foreach((controlleradvicebean, methodset) -> {\n        if (controlleradvicebean.isapplicabletobeantype(handlertype)) {\n            object bean = controlleradvicebean.resolvebean();\n            for (method method : methodset) {\n                initbindermethods.add(createinitbindermethod(bean, method));\n            }\n        }\n    });\n    /* 然后再加入当前handlermethod所在类中局部定义的相关方法 */\n    for (method method : methods) {\n        object bean = handlermethod.getbean();\n        initbindermethods.add(createinitbindermethod(bean, method));\n    }\n    /* 直到这一步，所有的@initbinder所修饰的方法都被封装为了invocablehandlermethod */\n    \n    /* 创建数据绑定器工厂 */\n    return createdatabinderfactory(initbindermethods);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n# getmodelfactory()\n// requestmappinghandleradapter#getmodelfactory()\nprivate modelfactory getmodelfactory(handlermethod handlermethod, webdatabinderfactory binderfactory) {\n    sessionattributeshandler sessionattrhandler = getsessionattributeshandler(handlermethod);\n    class<?> handlertype = handlermethod.getbeantype();\n    /* 获取局部的@modelattribute注解所修饰的相关方法 */\n    set<method> methods = this.modelattributecache.get(handlertype);\n    if (methods == null) {\n        methods = methodintrospector.selectmethods(handlertype, model_attribute_methods);\n        this.modelattributecache.put(handlertype, methods);\n    }\n    list<invocablehandlermethod> attrmethods = new arraylist<>();\n    /*\n    获取全局的@modelattribute注解所修饰的相关方法，同时也封装为invocablehandlermethod\n    全局的先加入列表\n    */\n    this.modelattributeadvicecache.foreach((controlleradvicebean, methodset) -> {\n        if (controlleradvicebean.isapplicabletobeantype(handlertype)) {\n            object bean = controlleradvicebean.resolvebean();\n            for (method method : methodset) {\n                attrmethods.add(createmodelattributemethod(binderfactory, bean, method));\n            }\n        }\n    });\n    /* 局部的后加入 */\n    for (method method : methods) {\n        object bean = handlermethod.getbean();\n        attrmethods.add(createmodelattributemethod(binderfactory, bean, method));\n    }\n    /* 可以看出modelfactory不仅保存了@modelattribute注解相关信息，而且还保存了webdatabinderfactory以及与该类型所关联的sessionattributeshandler（@sessionattributes的类表示） */\n    return new modelfactory(attrmethods, binderfactory, sessionattrhandler);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n# 总结\n关于requestmappinghandleradapter的分析差不多就这些，但是还涉及到其他很多组件没有分析，比如invocablehandlermethod, 消息转换器，参数和返回值解析器等组件。深入分析这些组件仍然很有必要。\n\n# servletinvocablehandlermethod\n关于servletinvocablehandlermethod的类体系结构如下图所示：\n\n\n\n我们依次来分析三个类。\n\n# handlermethod\n# 相关属性\n/* handler */\nprivate final object bean;\n\n/* 用于新建handlermethod时传入的handler是string的情况，则需要根据该string作为beanname获取到对应的bean，并设置为handler */\n@nullable\nprivate final beanfactory beanfactory;\n\n/* handler的类型 */\nprivate final class<?> beantype;\n\n/* 请求具体映射的方法 */\nprivate final method method;\n\n/* 如果method是桥接方法，则bridgedmethod表示被桥的方法，如果不涉及泛型，则两者相等 */\nprivate final method bridgedmethod;\n\n/* 请求方法所对应的参数 */\nprivate final methodparameter[] parameters;\n/* 响应的状态码 */\n@nullable\nprivate httpstatus responsestatus;\n\n/* 响应的状态原因 */\n@nullable\nprivate string responsestatusreason;\n\n/* 解析自哪个handlermethod，仅适用于构造方法中传入handlermethod对象的情况 */\n@nullable\nprivate handlermethod resolvedfromhandlermethod;\n\n/* 父接口的方法参数注解数组 */\n@nullable\nprivate volatile list<annotation[][]> interfaceparameterannotations;\n\n/* 描述信息 */\nprivate final string description;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n如果传入的bean是string类型的话，则会调用createwithresolvedbean()方法：\n\n// requestmappinghandleradapter#createwithresolvedbean()\npublic handlermethod createwithresolvedbean() {\n    object handler = this.bean;\n    if (this.bean instanceof string) {\n        assert.state(this.beanfactory != null, "cannot resolve bean name without beanfactory");\n        string beanname = (string) this.bean;\n        handler = this.beanfactory.getbean(beanname);\n    }\n    /* 调用构造方法，比较简单，this表示的handlermethod的属性赋值给新创建的handlermethod，并将handler赋值给新handlermethod的bean属性 */\n    return new handlermethod(this, handler);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n另外，handlermethod中方法参数的类型为methodparameter。\n\n# methodparameter\n下面是methodparameter中的一些属性：\n\n/* 所属所在的方法，executable是method和constructor的抽象父类 */\nprivate final executable executable;\n\n/* 参数的序号，也就是第几个参数，从0开始计数 */\nprivate final int parameterindex;\n\n/* 保存了方法参数的基本信息，如方法名称，权限修饰符等 */\n@nullable\nprivate volatile parameter parameter;\n\n/* 嵌套级别，如果是复合参数会用到。如对于list<string>params，params的嵌套级别是1，list内部string的嵌套级别是2。 */\nprivate int nestinglevel;\n\n/* 表示每层嵌套参数的序数 */\n@nullable\nmap<integer, integer> typeindexesperlevel;\n\n/* 参数所属方法所在的类的类型 */\n@nullable\nprivate volatile class<?> containingclass;\n\n/* 参数的类型 */\n@nullable\nprivate volatile class<?> parametertype;\n\n/* type型的参数类型，如果参数类型包含泛型的话，则表示原始类型 */\n@nullable\nprivate volatile type genericparametertype;\n\n/* 参数的注解 */\n@nullable\nprivate volatile annotation[] parameterannotations;\n\n/* 参数名称查找器 */\n@nullable\nprivate volatile parameternamediscoverer parameternamediscoverer;\n\n/* 参数名称 */\n@nullable\nprivate volatile string parametername;\n\n@nullable\nprivate volatile methodparameter nestedmethodparameter;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n对于methodparameter，最重要的属性是method和parameterindex。parameternamediscover的作用是查找参数名，这是因为在java8以前，反射不能获取到参数的名称，所以需要其他手段来解决这个问题。但是java8在class文件中保留了参数名，parameter类中保存了参数的名称，不过，保留参数名需要打开编译开关javac -parameters，默认是关闭的。\n\n# invocablehanldermethod\ninvocablehandlermethod在handlermethod的基础上添加了方法调用的功能，也就是说前者可以直接调用内部的method属性。另外，前者还增加了三个属性：\n\n/* 参数解析器 */\nprivate handlermethodargumentresolvercomposite resolvers = new handlermethodargumentresolvercomposite();\n\n/* 用来获取参数名称 */\nprivate parameternamediscoverer parameternamediscoverer = new defaultparameternamediscoverer();\n\n/* 数据绑定器工厂，被参数解析器使用 */\n@nullable\nprivate webdatabinderfactory databinderfactory;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n由@initbinder和@modelattribute注解修饰的方法最后就会被封装为invocablehandlermethod类型的对象；但handlermethod最后被封装为了servletinvocablehandlermethod类型的对象。\n\ninvocablehandlermethod中的invokeforrequest()方法进行方法的调用：\n\n// invokablehandlermethod#invokeforrequest()\n@nullable\npublic object invokeforrequest(nativewebrequest request, @nullable modelandviewcontainer mavcontainer,\n                               object... providedargs) throws exception {\n\n    /* 获取方法的参数 */\n    object[] args = getmethodargumentvalues(request, mavcontainer, providedargs);\n    if (logger.istraceenabled()) {\n        logger.trace("arguments: " + arrays.tostring(args));\n    }\n    /* 反射调用方法并返回结果 */\n    return doinvoke(args);\n}\n\n// invokablehandlermethod#getmethodargumentvalues()\nprotected object[] getmethodargumentvalues(nativewebrequest request, @nullable modelandviewcontainer mavcontainer,\n                                           object... providedargs) throws exception {\n\n    /* 获取父类handlermethod中定义的parameters属性 */\n    methodparameter[] parameters = getmethodparameters();\n    /* 无参则返回空数组 */\n    if (objectutils.isempty(parameters)) {\n        return empty_args;\n    }\n\t\n    /* 将参数解析为对应的类型 */\n    object[] args = new object[parameters.length];\n    /* 遍历解析每一个参数 */\n    for (int i = 0; i < parameters.length; i++) {\n        methodparameter parameter = parameters[i];\n        /* 给参数设置参数名解析器 */\n        parameter.initparameternamediscovery(this.parameternamediscoverer);\n        /* 先从providedargs中获取参数，但是默认情况下不会传递providedargs*/\n        args[i] = findprovidedargument(parameter, providedargs);\n        if (args[i] != null) {\n            continue;\n        }\n        /* 判断resolvers是否支持当前的参数解析 */\n        if (!this.resolvers.supportsparameter(parameter)) {\n            throw new illegalstateexception(formatargumenterror(parameter, "no suitable resolver"));\n        }\n        try {\n            /* 执行解析 */\n            args[i] = this.resolvers.resolveargument(parameter, mavcontainer, request, this.databinderfactory);\n        }\n        catch (exception ex) {\n            /* 如果参数解析中出现错误，则抛出异常 */\n            // ...\n            throw ex;\n        }\n    }\n    return args;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n下面来看整个请求最核心的地方，即我们所写的handlermethod真正被调用的地方：\n\n// invokablehandlermethod#doinvoke()\n@nullable\nprotected object doinvoke(object... args) throws exception {\n    method method = getbridgedmethod();\n    /* 设置方法为可访问 */\n    reflectionutils.makeaccessible(method);\n    try {\n        // ...\n        /* 反射调用方法 */\n        return method.invoke(getbean(), args);\n    }\n    catch (illegalargumentexception ex) {\n        // ...\n    }\n    catch (invocationtargetexception ex) {\n        // ...\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n# servletinvocablehandlermethod\nservletinvocablehandlermethod在父类的基础上增加了对@responsestatus的支持，返回值处理，异步处理等功能。\n\n笔记\n\n@responsestatus注解用于处理器方法或者返回值上，作用是对请求响应的状态（value和reason）进行设置。具体使用可以参考其他资料，实际用得并不多。\n\n在requestmappinghandleradapter类中是把handlermethod封装为servletinvocablehandlermethod的，然后调用其invokeandhandle()方法：\n\n// servletinvocablehandlermethod#invokeandhandle()\npublic void invokeandhandle(servletwebrequest webrequest, modelandviewcontainer mavcontainer,\n                            object... providedargs) throws exception {\n\n    /* 调用父类中的方法进行实际调用，并获取返回值 */\n    object returnvalue = invokeforrequest(webrequest, mavcontainer, providedargs);\n    /* 设置响应状态，内部处理了@responsestatus注解 */\n    setresponsestatus(webrequest);\n\n    /* 设置modelandviewcontainer相关 */\n    if (returnvalue == null) {\n        if (isrequestnotmodified(webrequest) || getresponsestatus() != null || mavcontainer.isrequesthandled()) {\n            disablecontentcachingifnecessary(webrequest);\n            mavcontainer.setrequesthandled(true);\n            return;\n        }\n    }\n    else if (stringutils.hastext(getresponsestatusreason())) {\n        mavcontainer.setrequesthandled(true);\n        return;\n    }\n\n    mavcontainer.setrequesthandled(false);\n    assert.state(this.returnvaluehandlers != null, "no return value handlers");\n    try {\n        /* 处理返回值 */\n        this.returnvaluehandlers.handlereturnvalue(\n            returnvalue, getreturnvaluetype(returnvalue), mavcontainer, webrequest);\n    }\n    catch (exception ex) {\n        if (logger.istraceenabled()) {\n            logger.trace(formaterrorforreturnvalue(returnvalue), ex);\n        }\n        throw ex;\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n# modelandviewcontainer\nmodelandviewcontainer在整个请求过程中起着数据传递的作用。\n\n# 相关属性\n/* 是否在处理器返回redirect视图时一定不使用defaultmodel */\nprivate boolean ignoredefaultmodelonredirect = false;\n\n/* 视图，可以是实际视图也可以是string类型的逻辑视图 */\n@nullable\nprivate object view;\n\n/* 默认使用的model */\nprivate final modelmap defaultmodel = new bindingawaremodelmap();\n\n/* redirect类型的model */\n@nullable\nprivate modelmap redirectmodel;\n\n/* 处理器返回redirect视图的标志 */\nprivate boolean redirectmodelscenario = false;\n\n@nullable\nprivate httpstatus status;\n\nprivate final set<string> nobinding = new hashset<>(4);\n\nprivate final set<string> bindingdisabled = new hashset<>(4);\n\n/* 用于设置sessionattribute使用完成的标志 */\nprivate final sessionstatus sessionstatus = new simplesessionstatus();\n\n/* 请求是否已处理完成的标志 */\nprivate boolean requesthandled = false;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n# addallattributes()\n在requestmappinghandleradapter中的invokehandlermethod()方法中创建了modelandviewcontainer，并调用了几个方法，下面来看一下。\n\n// modelandviewcontainer#addallattributes()\n/* \nmodelandviewcontainer mavcontainer = new modelandviewcontainer();\nmavcontainer.addallattributes(requestcontextutils.getinputflashmap(request));\n*/\npublic modelandviewcontainer addallattributes(@nullable map<string, ?> attributes) {\n    /* 将所有请求的参数保存到model中 */\n    getmodel().addallattributes(attributes);\n    return this;\n}\n\n/* 返回使用哪个model */\npublic modelmap getmodel() {\n    if (usedefaultmodel()) {\n        return this.defaultmodel;\n    }\n    else {\n        if (this.redirectmodel == null) {\n            this.redirectmodel = new modelmap();\n        }\n        return this.redirectmodel;\n    }\n}\n\n// modelandviewcontainer#usedefaultmodel()\n/* \n判断是使用defaultmodel还是redirectmodel ，总结如下：\n返回defaultmodel的情况：\n  1. 处理器返回的不是redirect视图\n  2. 处理器返回的是redirect视图，但是redirectmodel为null，而且ignoredefaultmodelonredirect也是false\n返回redirectmodel的情况：\n  1. 处理器返回的是redirect视图，且redirectmodel不是null\n  2. 处理器返回的是redirect视图，且ignoredefaultmodelonredirect不是false\n*/\n/* \n在处理handlermethod的返回值时会判断是不是redirect视图，然后会设置ignoredefaultmodelonredirect的值,有下面的方法调用\nmavcontainer.setignoredefaultmodelonredirect(this.ignoredefaultmodelonredirect);\n*/\nprivate boolean usedefaultmodel() {\n    return (!this.redirectmodelscenario || (this.redirectmodel == null && !this.ignoredefaultmodelonredirect));\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n# sessionattriuteshandler\n前面提到，sessionattributeshandler是@sessionattributes注解的类表示。\n\n# 相关属性\n/* 存储了@sessionattributes中value对应的值 */\nprivate final set<string> attributenames = new hashset<>();\n\n/* 存储了@sessionattributes中types对应的值 */\nprivate final set<class<?>> attributetypes = new hashset<>();\n\n/* \n存储所有已知可以被当前sessionattriuteshandler处理的属性名，在attributenames和attributetypes的基础上进行判断和转换。\n*/\nprivate final set<string> knownattributenames = collections.newsetfrommap(new concurrenthashmap<>(4));\n\n/* \nsessionattributestore是sessionattributes的存储工具，但不是存储到sessionattributestore中的，\nsessionattributes是在model和session中存储，不过可以重写sessionattributestore来改变存储位置。\n*/\nprivate final sessionattributestore sessionattributestore;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n# 构造方法\n/* \n当在requestmappinghandleradapter中创建sessionattributeshandler时，传递过来的sessionattributestore是requestmappinghandleradapter属性，是sessionattributestore的唯一子类defaultsessionattributestore类型的实例。\n*/\npublic sessionattributeshandler(class<?> handlertype, sessionattributestore sessionattributestore) {\n    assert.notnull(sessionattributestore, "sessionattributestore may not be null");\n    this.sessionattributestore = sessionattributestore;\n\n    /* 获取@sessionattributes注解信息。 */\n    sessionattributes ann = annotatedelementutils.findmergedannotation(handlertype, sessionattributes.class);\n    /* 如果存在该注解，则保存注解中的信息到该处理器中。 */\n    if (ann != null) {\n        collections.addall(this.attributenames, ann.names());\n        collections.addall(this.attributetypes, ann.types());\n    }\n    this.knownattributenames.addall(this.attributenames);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n# modelfactory\n# 构造方法\n在requestmappinghandleradapter的invokehandlermethod()方法中，通过调用自己的getmodelfactory()方法解析与当前handlertype相关的@modelattribute注解并获取modelfactory实例。\n\n（可以再往上翻，复习一下getmodelfactory()方法）\n\n/* \nhandlermethods中保存了需要提前执行的方法 \n*/\npublic modelfactory(@nullable list<invocablehandlermethod> handlermethods,\n                    webdatabinderfactory binderfactory, sessionattributeshandler attributehandler) {\n\n    if (handlermethods != null) {\n        for (invocablehandlermethod handlermethod : handlermethods) {\n            /* \n            将invocablehandlermethod封装为modelmethod \n            modelmethod的构造方法中进行了handlermethod的依赖判断，这里的依赖指的是方法的参数。\n            modelmethod就是封装了handlermethod和方法的参数。\n            */\n            this.modelmethods.add(new modelmethod(handlermethod));\n        }\n    }\n    this.databinderfactory = binderfactory;\n    this.sessionattributeshandler = attributehandler;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n# 初始化model\n然后调用modelfactory的initmodel()方法进行初始化。\n\n// modelfactory#initmodel()\npublic void initmodel(nativewebrequest request, modelandviewcontainer container, handlermethod handlermethod)\n    throws exception {\n\n    /* \n    第一步：\n    从sessionattributes中取出与当前请求有关的参数及合并到model中 \n    */\n    map<string, ?> sessionattributes = this.sessionattributeshandler.retrieveattributes(request);\n    /* 注意，只会放入model中不存在的属性 */\n    container.mergeattributes(sessionattributes);\n    /* \n    第二步：\n    执行注释了@modelattribute注解修饰的方法并将结果设置到model中 \n    */\n    invokemodelattributemethods(request, container);\n\n    /* \n    第三步：\n    findsessionattributearguments获取到了handlermethod中所有被@modelattribute修饰且被@sessionattributes注解所配置的参数名。\n    特别注意，这一步目前还不能理解，感觉和第一步的操作重合了。\n    为什么这里不直接判断如果不在model中就抛出异常，而非要再去sessionattributeshandler中获取一次？\n    现在就请记住如果同时使用@modelattributes和@sessionattributes修饰的参数，就要确保在session中确实存在，否则报错。\n    */\n    for (string name : findsessionattributearguments(handlermethod)) {\n        /* 如果该参数不在model中 */\n        if (!container.containsattribute(name)) {\n            /* 则根据@modelattribute中value属性值作为参数名去sessionattributes中获取值 */\n            object value = this.sessionattributeshandler.retrieveattribute(request, name);\n            /* 如果获取不到就抛出异常 */\n            if (value == null) {\n                throw new httpsessionrequiredexception("expected session attribute \'" + name + "\'", name);\n            }\n            /* 如果获取到了就加入model中 */\n            container.addattribute(name, value);\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\ninitmodel()方法可以分为三步，其中第二步是调用invokemodelattributemethods()来完成的。\n\n// modelfactory#invokemodelattributemethods()\nprivate void invokemodelattributemethods(nativewebrequest request, modelandviewcontainer container)\n    throws exception {\n\n    while (!this.modelmethods.isempty()) {\n        /* 获取由@modelattributes修饰的方法，调用了getnextmodelmethod() */\n        invocablehandlermethod modelmethod = getnextmodelmethod(container).gethandlermethod();\n        /* 获取该方法上的@modelattribute注解 */\n        modelattribute ann = modelmethod.getmethodannotation(modelattribute.class);\n        assert.state(ann != null, "no modelattribute annotation");\n        /* 如果model中已经存在与@modelattribute注解中同名的数据，则跳过 */\n        if (container.containsattribute(ann.name())) {\n            if (!ann.binding()) {\n                container.setbindingdisabled(ann.name());\n            }\n            continue;\n        }\n\t\t/* 调用方法 */\n        object returnvalue = modelmethod.invokeforrequest(request, container);\n        /* 如果返回值为空，则跳过继续 */\n        if (modelmethod.isvoid()) {\n            if (stringutils.hastext(ann.value())) {\n                if (logger.isdebugenabled()) {\n                    logger.debug("name in @modelattribute is ignored because method returns void: " +\n                                 modelmethod.getshortlogmessage());\n                }\n            }\n            continue;\n        }\n\t\t\n        /* 如果返回值非空，则获取返回值的名称 */\n        string returnvaluename = getnameforreturnvalue(returnvalue, modelmethod.getreturntype());\n        if (!ann.binding()) {\n            container.setbindingdisabled(returnvaluename);\n        }\n        /* 如果model中不存在returnvaluename该属性，那么添加进去 */\n        if (!container.containsattribute(returnvaluename)) {\n            container.addattribute(returnvaluename, returnvalue);\n        }\n    }\n}\n\n// modelfactory#getnextmodelmethod()\nprivate modelmethod getnextmodelmethod(modelandviewcontainer container) {\n    for (modelmethod modelmethod : this.modelmethods) {\n        /* \n        检查方法的参数是否已经在modelandviewcontainer中了，如果在则移除并返回，\n        checkdependencies()是根据参数的名称来判断的。\n        */\n        if (modelmethod.checkdependencies(container)) {\n            this.modelmethods.remove(modelmethod);\n            return modelmethod;\n        }\n    }\n    /* 如果所有的方法都不能满足方法参数，则返回第一个。 */\n    modelmethod modelmethod = this.modelmethods.get(0);\n    this.modelmethods.remove(modelmethod);\n    return modelmethod;\n}\n\n// modelfactory#getnameforreturnvalue()\npublic static string getnameforreturnvalue(@nullable object returnvalue, methodparameter returntype) {\n    modelattribute ann = returntype.getmethodannotation(modelattribute.class);\n    /* 如果@modelattribute注解有值，那么则使用该值作为返回值的名称 */\n    if (ann != null && stringutils.hastext(ann.value())) {\n        return ann.value();\n    }\n    else {\n        method method = returntype.getmethod();\n        assert.state(method != null, "no handler method");\n        class<?> containingclass = returntype.getcontainingclass();\n        class<?> resolvedtype = generictyperesolver.resolvereturntype(method, containingclass);\n        /* 根据方法，返回值类型和返回值获取参数名，这里就不分析具体的细节了。记住如果不指定@modelattribute的value值的话，那么会根据规则生成。 */\n        return conventions.getvariablenameforreturntype(method, resolvedtype, returnvalue);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\ninitmodel()方法的第三步调用了findsessionattributearguments()方法：\n\n// modelfactory#findsessionattributearguments()\nprivate list<string> findsessionattributearguments(handlermethod handlermethod) {\n    list<string> result = new arraylist<>();\n    for (methodparameter parameter : handlermethod.getmethodparameters()) {\n        /* 如果该方法参数被@modelattribute注解修饰，则继续 */\n        if (parameter.hasparameterannotation(modelattribute.class)) {\n            /* 如果@modelattribute注解中指定了参数名，则使用；否则根据规则生成。*/\n            string name = getnameforparameter(parameter);\n            class<?> paramtype = parameter.getparametertype();\n            /* 如果该参数同时在@sessionattributes注解中配置了（通过指定参数名或参数类型） */\n            if (this.sessionattributeshandler.ishandlersessionattribute(name, paramtype)) {\n                result.add(name);\n            }\n        }\n    }\n    return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n# 更新model\n在requestmappinghandleradapter中的getmodelandview（）方法中，调用了modelfactory中的updatemodel()方法来更新model。\n\n// modelfactory#updatemodel()\npublic void updatemodel(nativewebrequest request, modelandviewcontainer container) throws exception {\n    modelmap defaultmodel = container.getdefaultmodel();\n    if (container.getsessionstatus().iscomplete()){\n        this.sessionattributeshandler.cleanupattributes(request);\n    }\n    else {\n        this.sessionattributeshandler.storeattributes(request, defaultmodel);\n    }\n    if (!container.isrequesthandled() && container.getmodel() == defaultmodel) {\n        updatebindingresult(request, defaultmodel);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n# handlermethodargumentresolver\nhandlermethodargumentresolver接口定义了两个方法：\n\npublic interface handlermethodargumentresolver {\n\t/* 是否支持解析某种类型的参数 */\n\tboolean supportsparameter(methodparameter parameter);\n\n    /* 执行参数解析 */\n\t@nullable\n\tobject resolveargument(methodparameter parameter, @nullable modelandviewcontainer mavcontainer,\n\t\t\tnativewebrequest webrequest, @nullable webdatabinderfactory binderfactory) throws exception;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\nhandlermethod方法的解析是在invokablehandlermethod中的getmethodargumentvalues()方法中通过handlermethodargumentresolvercomposite实例来解析的。因为有很多解析器，所以springmvc采用了复合类的方式。\n\n下面来看一下handlermethodargumentresolvercomposite中的主要方法：\n\n// handlermethodargumentresolvercomposite#supportsparameter()\n@override\npublic boolean supportsparameter(methodparameter parameter) {\n    /* 如果获取到了对应的解析器，则表示支持解析 */\n    return getargumentresolver(parameter) != null;\n}\n\n// handlermethodargumentresolvercomposite#getargumentresolver()\n@nullable\nprivate handlermethodargumentresolver getargumentresolver(methodparameter parameter) {\n    /* \n    argumentresolvercache中缓存了methodparameter与handlermethodargumentresolver的映射，不用每次都遍历所有的解析器。\n    */\n    handlermethodargumentresolver result = this.argumentresolvercache.get(parameter);\n    if (result == null) {\n        for (handlermethodargumentresolver resolver : this.argumentresolvers) {\n            /* 获取到了已匹配的解析器 */\n            if (resolver.supportsparameter(parameter)) {\n                result = resolver;\n                this.argumentresolvercache.put(parameter, result);\n                break;\n            }\n        }\n    }\n    return result;\n}\n\n// handlermethodargumentresolvercomposite#resolveargument()\n@override\n@nullable\npublic object resolveargument(methodparameter parameter, @nullable modelandviewcontainer mavcontainer,\n                              nativewebrequest webrequest, @nullable webdatabinderfactory binderfactory) throws exception {\n\n    /* 获取解析器 */\n    handlermethodargumentresolver resolver = getargumentresolver(parameter);\n    if (resolver == null) {\n        throw new illegalargumentexception("unsupported parameter type [" +\n                                           parameter.getparametertype().getname() + "]. supportsparameter should be called first.");\n    }\n    /* 调用具体的解析器进行解析 */\n    return resolver.resolveargument(parameter, mavcontainer, webrequest, binderfactory);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\nspringmvc中的解析器有两种命名方式，一种是xxxmethodargumentresolver，另一种是xxxmethodprocess的。前者表示一个参数解析器，后者除了可以解析参数外还可以处理相应类型的返回值，也就是handlermethodreturnvaluehandler。\n\n由于参数解析器种类繁多，所以后面单独写文分析每一种解析器。搞懂参数解析器有利于解释为什么参数不能绑定这样的疑惑。\n\n# handlermethodreturnvaluehandler\n返回值的处理是在servletinvocablehandlermethod的invokeandhandle()方法中进行的。和参数解析类似，也是通过复合类handlermethodreturnvaluehandlercomposite进行的。\n\nhandlermethodreturnvaluehandler接口中定义了两个方法：\n\npublic interface handlermethodreturnvaluehandler {\n\t/* 是否支持该某种返回值类型 */\n\tboolean supportsreturntype(methodparameter returntype);\n\t\n    /* 处理返回值 */\n\tvoid handlereturnvalue(@nullable object returnvalue, methodparameter returntype,\n\t\t\tmodelandviewcontainer mavcontainer, nativewebrequest webrequest) throws exception;\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nhandlermethodreturnvaluehandlercomposite中的逻辑和handlermethodargumentresolvercomposite中的比较类似，这里就不贴代码了。\n\n同样地，返回值处理器也有很多种，后面单独写文分析每一种。\n\n# 总结\n本文分析了handleradapter体系中最重要也是最复杂的分支reqeustmappinghandleradapter，该适配器处理handlermethod，也就是我们用@requestmapping修饰的方法。整个过程可以分为三步：解析参数，执行请求和处理返回值。\n\n最复杂的莫属参数解析了，因为参数来源有很多个，大体可以分为两大类，一类是从model来，另一类从request中来。整个处理过程modelandviewcontainer起着参数传递的作用。\n\n执行请求是通过servletinvocablehandlermethod的invokeandhandler()进行的（实际上是通过父类invocablehandlermethod中的invokeforrequest()方法），该方法中同时还进行了返回值的处理。\n\n一定要把本文所述的处理流程搞明白，才能避免一些基础性问题，如参数绑定失败。\n\n# 参考\n * handleradapter前置知识点\n * handleradapter源码分析\n * 《看透springmvc 源码分析与实战》\n * 从原理层面掌握@sessionattributes注解',charsets:{cjk:!0}},{title:"SpringMVC参数接收问题总结",frontmatter:{title:"SpringMVC参数接收问题总结",categories:["后端框架"],tags:["SpringMVC"],date:"2021-01-19T20:34:45.000Z",permalink:"/pages/cd47ce/"},regularPath:"/22.%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/01.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/01.Spring%20Framework/03.Web/05.%E5%8F%82%E6%95%B0%E6%8E%A5%E6%94%B6%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93.html",relativePath:"22.后端框架/01.Spring全家桶/01.Spring Framework/03.Web/05.参数接收问题总结.md",key:"v-7efc302c",path:"/pages/cd47ce/",headers:[{level:2,title:"URL中的参数",slug:"url中的参数",normalizedTitle:"url中的参数",charIndex:778},{level:3,title:"查询参数",slug:"查询参数",normalizedTitle:"查询参数",charIndex:788},{level:3,title:"路径参数",slug:"路径参数",normalizedTitle:"路径参数",charIndex:1207},{level:2,title:"表单参数",slug:"表单参数",normalizedTitle:"表单参数",charIndex:1193},{level:3,title:"普通表单参数",slug:"普通表单参数",normalizedTitle:"普通表单参数",charIndex:1191},{level:3,title:"文件上传",slug:"文件上传",normalizedTitle:"文件上传",charIndex:2265},{level:2,title:"请求头参数",slug:"请求头参数",normalizedTitle:"请求头参数",charIndex:3831},{level:2,title:"Cookie值",slug:"cookie值",normalizedTitle:"cookie值",charIndex:4054},{level:2,title:"其他参数",slug:"其他参数",normalizedTitle:"其他参数",charIndex:4183},{level:2,title:"日期类型处理",slug:"日期类型处理",normalizedTitle:"日期类型处理",charIndex:4257},{level:2,title:"参考",slug:"参考",normalizedTitle:"参考",charIndex:1185}],excerpt:"<p>前端请求参数类型和后端接收方式多种多样，前端传递的参数可能是普通表单数据，JSON格式或者是文件等，而后端关于参数绑定这一块又有很多注解。对于某种类型的数据到底使用哪个注解常常困惑笔者，说到底还是对SpringMVC的参数处理机制不太熟悉。所以，本文就来分析一下SpringMVC中参数的接收和校验问题，但愿不再被此类问题困扰。</p>\n",lastUpdated:"2021-01-21",headersStr:"URL中的参数 查询参数 路径参数 表单参数 普通表单参数 文件上传 请求头参数 Cookie值 其他参数 日期类型处理 参考",content:'前端请求参数类型和后端接收方式多种多样，前端传递的参数可能是普通表单数据，JSON格式或者是文件等，而后端关于参数绑定这一块又有很多注解。对于某种类型的数据到底使用哪个注解常常困惑笔者，说到底还是对SpringMVC的参数处理机制不太熟悉。所以，本文就来分析一下SpringMVC中参数的接收和校验问题，但愿不再被此类问题困扰。\n\nHttp请求的参数可能保存在请求头的URL中，也有可能在请求体中，但并不是所有的请求都有请求体，比如GET，HEAD，DELETE ，OPTIONS一般情况下就没有请求体（具体有没有取决于客户端如何发送请求，然后服务的是否进行解析）。所以在编写handlerMethod时一定要搞清楚请求的方法是什么（有没有请求体），Content-Type（或者是Content-Disposition）是什么。一般使用@RequestMapping的consumes属性可以指定请求的Content-Type应该是什么。\n\n在前面分析HandlerAdapter的文章中，知道请求的所有参数都被放入ModelAndViewContainer内部的ModelMap中。具体的参数解析是由参数解析器来进行的，参数解析器在解析的过程中可能会调用消息转换器，将解析后的参数进一步转换为参数目标类型。\n\n现在开发中主要使用以下几种MIME的数据：\n\n * 普通表单对应的Content-Type为application/x-www-form-urlencoded。\n * enctype属性为multipart/form-data的表单通常用于上传文件，其Content-Type表示文件的类型，而Content-Disposition中的值表示当前是for-date。\n * applicaton/json，这种方式是目前使用的最多的。\n\n# URL中的参数\n# 查询参数\n下面是一个http请求的URL：\n\nhttp://127.0.0.1:8080/ssm/user1?username=harrison&age=23\n\n\n1\n第一种方式可以使用@RequestParam，但是注意handlerMethod中的参数名必须和URL中的参数名对应，如果不对应则需要指定@RequestParam的value（或name）属性的值对应参数名。对于@RequestParam，SpringMVC使用RequestParamMethodArgumentResolver这个解析器进行参数解析。如果不想写多个参数，可以把这些都放入map中，如果使用map的话，使用的解析器是RequestParamMapMethodArgumentResolver类型的。\n\n第二种方式可以使用对象接收，不用加任何注解。但是请注意，对象的属性名称要和查询参数名对应。\n\n更多信息请参考下文分析普通表单参数那一节内容。\n\n# 路径参数\nURL路径参数是基于URL模板获取到的参数，例如/user/{id}中{id}是参数占位符。可以使用@PathVariable根据参数name（或者是注解的配置值）从URL中取出占位符所对应的参数，对应的参数处理器为PathVariableMethodArgumentResolver。另外，占位符中还可以使用正则表达式进行请求URL匹配。\n\n另外一个与路径参数有关的注解是@MatrixVariable，但很少使用，所以这里就不分析了。\n\n# 表单参数\n# 普通表单参数\n对于普通表单参数，其Content-Type一般为application/x-www-form-urlencoded，表示也会进行URL编码，对于不具有请求体的请求方式，如GET，浏览器会将其加入到URL中，对于其他存在请求体的数据会放入请求体中。当Conetent-Type为这种类型且请求方法为POST时，Servlet容器会在该请求第一次调用getParameterMap()时把请求体中所有URL编码的参数和URL中的查询参数一并放入某个map中，关于这一点，Servlet规范（本文参考的版本为4.0）中3.1小节（Http Protocol Parameters）有说明。\n\n上面也说到@RequestParam注解对应的解析器是RequestParamMethodArgumentResolver和RequestParamMapMethodArgumentResolver，前者通过request从上述的map中获取对应参数名的参数值，后者直接获取整个map，这也是为什么@RequestParam可以获取参数到URL编码参数的原因。\n\n::: waning\n\n经过上述分析，可以明白@RequestParam不是只能获取请求头中的参数的，也能获取请求体中的参数，只要请求方法是POST以及Content-Type为application/x-www-form-urlencoded。对于其他方法的表单参数，Servlet容器是不会将其传播到那个map中的，所以@RequestParam也不会获取到。\n\n:::\n\n警告\n\n对于POST或PUT等类型的普通表单请求，尽管其URL编码数据放在请求体中，也不能使用@RequestBody注解，否则会抛出警告，以及请求不能被处理：\n\nContent type \'application/x-www-form-urlencoded\' not supported\n\n\n1\n# 文件上传\n通过表单上传文件时，其Content-Type为multipart/form-data。在接收文件时变量的类型为MultipartFile，可以使用注解也可以不使用注解，而且既可以使用@RequestParam也可以使用@RequestPart。当使用@RequestPart注解时，对应的解析器为RequestPartMethodArgumentResolver；当使用@RequestParam或者不加注解，使用的是RequestParamMethodArgumentResolver解析器。注意，变量的参数名或者注解的value值都必须与Content-Disposition描述的name一致。如果用对象来接收的话不用添加任何注解即可接收。\n\n除此之外，还可以通过获取MultipartHttpServletRequest对象来手动调用getFile()或者是getFiles()方法来获取文件。\n\n当上传多个文件时，也可以使用上述方式，可以把所有文件的key都指定为一样的，然后通过数组来接收。如在postman中上传多个文件：\n\n\n\n后端接收代码为：\n\n@GetMapping("upload")\npublic String hello7(MultipartFile[] files) {\n    return "success";\n}\n\n\n1\n2\n3\n4\n其实，get请求也能上传文件，不一定非得用post。\n\n笔记\n\n其实关于文件上传，上面说的两种解析器中使用了代理解析器来解析。在SpringMVC中真正解析文件的解析器有两个，StandardServletMultipartResolver和CommonsMultipartResolver。前者是Servlet 3.0的标准上传方式，SpringMVC默认会注入该解析器，使用该解析器必须要在web.xml配置<multipart-config>或者在JavaConfig中使用@MultipartConfig注解；后者会依赖apache的common-fileupload包，如果要使用后者，需要手动注入该bean，bean的名称必须为“multipartResolver”。具体细节后面再写一篇关于文件上传原理的文章吧。\n\n下面是在web.xml中配置<multipart-config>的实例：\n\n<servlet>\n    <servlet-name>dispatcherServlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n    <init-param>\n        <param-name>contextConfigLocation</param-name>\n        <param-value>classpath:dispatcherServlet.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n    \x3c!-- 配置在servelt标签中 --\x3e\n    <multipart-config />\n</servlet>\n\n<servlet-mapping>\n    <servlet-name>dispatcherServlet</servlet-name>\n    <url-pattern>/*</url-pattern>\n</servlet-mapping>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n# 请求头参数\n请求头的值主要通过@RequestHeader注解的参数获取，参数处理器是RequestHeaderMethodArgumentResolver。注意，参数名或者是注解的value值必须和请求头的字段名称一致，如果没有这样名称的字段，那么会抛出警告并返回400的错误码。\n\n可以使用@RequestHeader修饰map类型参数，那么将会使用RequestHeaderMapMethodArgumentResolver解析器。\n\n# Cookie值\nCookie值可以使用@CookieValue注解的参数获取，由ServletCookieValueMethodArgumentResolver处理器进行处理。同样地，参数名或者注解的value值必须和存在的cookie字段名称对应。\n\n# 其他参数\n对于其他类型的参数，如Model类型参数，或者@ModelAttribute参数请参考之前分析HandlerAdapter的文章。\n\n# 日期类型处理\n日期类型的参数接收是很麻烦的，原因是通常是由字符串转换为日期对象，就涉及日期解析，由于日期格式多种多样，所以就需要我们根据期望的日期格式并提供相应的解析器。\n\n下面是几种对于接收日期类型的解决方案。\n\n * 以字符串形式接收，然后手动转换。\n   \n   \n * 可以使用@DateTimeFormat注解，但是只能用表单类型的提交（x-www-form-urlencoded和form-data均可）。\n   \n   class User {\n       String username;\n       Integer age;\n       @DateTimeFormat(pattern = "yyyy-MM-dd")\n       LocalDate birthday;\n   }\n   \n   @PostMapping("user2")\n   public String addUser2(User user) {\n       System.out.println(user); // 可以接收到数据\n       return "success";\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n * 使用@JsonFormat，没有@DateTimeFormat那种限制。\n   \n   static class User {\n       String username;\n       Integer age;\n       \n       /* 支持JSON格式，注意引入依赖：jackson-datatype-jsr310；否则报错 */\n       @JsonFormat(pattern = "yyyy-MM-dd", timezone = "GMT+8")\n       LocalDate birthday;\n   }\n   \n   @PostMapping("user2")\n   public String addUser2(@RequestBody User user) {\n       System.out.println(user);\n       return "success";\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n * Jackson序列化和反序列化定制\n   \n   @Data\n   static class User {\n       String username;\n       Integer age;\n       @JsonDeserialize(using = CustomLocalDateDeserializer.class)\n       LocalDate birthday;\n   }\n   /* \n   根据需求选择LocalTimeDeserializer，LocalDateDeserializer还是LocalDateTimeDeserializer\n   */\n   class CustomLocalDateDeserializer extends LocalDateDeserializer {\n       public CustomLocalDateDeserializer() {\n           super(DateTimeFormatter.ofPattern("yyyy-MM-dd"));\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n * 最佳实践\n   \n   直接修改MappingJackson2HttpMessageConverter中的ObjectMapper对于日期类型处理默认的序列化器和反序列化器，这样就可以对全局生效。\n   \n   @Bean\n   public Jackson2ObjectMapperBuilderCustomizer jackson2ObjectMapperBuilderCustomizer(){\n       return customizer->{\n           /* 根据需求设置需要更改序列化逻辑的类型 */\n           customizer.serializerByType(LocalDateTime.class,new LocalDateTimeSerializer(\n               DateTimeFormatter.ofPattern("yyyy-MM-dd")));\n           customizer.deserializerByType(LocalDateTime.class,new LocalDateTimeDeserializer(\n               DateTimeFormatter.ofPattern("yyyy-MM-dd")));\n       };\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n# 参考\n * SpringMVC请求参数接收总结(一)\n   \n   \n * SpringMVC文件上传原理',normalizedContent:'前端请求参数类型和后端接收方式多种多样，前端传递的参数可能是普通表单数据，json格式或者是文件等，而后端关于参数绑定这一块又有很多注解。对于某种类型的数据到底使用哪个注解常常困惑笔者，说到底还是对springmvc的参数处理机制不太熟悉。所以，本文就来分析一下springmvc中参数的接收和校验问题，但愿不再被此类问题困扰。\n\nhttp请求的参数可能保存在请求头的url中，也有可能在请求体中，但并不是所有的请求都有请求体，比如get，head，delete ，options一般情况下就没有请求体（具体有没有取决于客户端如何发送请求，然后服务的是否进行解析）。所以在编写handlermethod时一定要搞清楚请求的方法是什么（有没有请求体），content-type（或者是content-disposition）是什么。一般使用@requestmapping的consumes属性可以指定请求的content-type应该是什么。\n\n在前面分析handleradapter的文章中，知道请求的所有参数都被放入modelandviewcontainer内部的modelmap中。具体的参数解析是由参数解析器来进行的，参数解析器在解析的过程中可能会调用消息转换器，将解析后的参数进一步转换为参数目标类型。\n\n现在开发中主要使用以下几种mime的数据：\n\n * 普通表单对应的content-type为application/x-www-form-urlencoded。\n * enctype属性为multipart/form-data的表单通常用于上传文件，其content-type表示文件的类型，而content-disposition中的值表示当前是for-date。\n * applicaton/json，这种方式是目前使用的最多的。\n\n# url中的参数\n# 查询参数\n下面是一个http请求的url：\n\nhttp://127.0.0.1:8080/ssm/user1?username=harrison&age=23\n\n\n1\n第一种方式可以使用@requestparam，但是注意handlermethod中的参数名必须和url中的参数名对应，如果不对应则需要指定@requestparam的value（或name）属性的值对应参数名。对于@requestparam，springmvc使用requestparammethodargumentresolver这个解析器进行参数解析。如果不想写多个参数，可以把这些都放入map中，如果使用map的话，使用的解析器是requestparammapmethodargumentresolver类型的。\n\n第二种方式可以使用对象接收，不用加任何注解。但是请注意，对象的属性名称要和查询参数名对应。\n\n更多信息请参考下文分析普通表单参数那一节内容。\n\n# 路径参数\nurl路径参数是基于url模板获取到的参数，例如/user/{id}中{id}是参数占位符。可以使用@pathvariable根据参数name（或者是注解的配置值）从url中取出占位符所对应的参数，对应的参数处理器为pathvariablemethodargumentresolver。另外，占位符中还可以使用正则表达式进行请求url匹配。\n\n另外一个与路径参数有关的注解是@matrixvariable，但很少使用，所以这里就不分析了。\n\n# 表单参数\n# 普通表单参数\n对于普通表单参数，其content-type一般为application/x-www-form-urlencoded，表示也会进行url编码，对于不具有请求体的请求方式，如get，浏览器会将其加入到url中，对于其他存在请求体的数据会放入请求体中。当conetent-type为这种类型且请求方法为post时，servlet容器会在该请求第一次调用getparametermap()时把请求体中所有url编码的参数和url中的查询参数一并放入某个map中，关于这一点，servlet规范（本文参考的版本为4.0）中3.1小节（http protocol parameters）有说明。\n\n上面也说到@requestparam注解对应的解析器是requestparammethodargumentresolver和requestparammapmethodargumentresolver，前者通过request从上述的map中获取对应参数名的参数值，后者直接获取整个map，这也是为什么@requestparam可以获取参数到url编码参数的原因。\n\n::: waning\n\n经过上述分析，可以明白@requestparam不是只能获取请求头中的参数的，也能获取请求体中的参数，只要请求方法是post以及content-type为application/x-www-form-urlencoded。对于其他方法的表单参数，servlet容器是不会将其传播到那个map中的，所以@requestparam也不会获取到。\n\n:::\n\n警告\n\n对于post或put等类型的普通表单请求，尽管其url编码数据放在请求体中，也不能使用@requestbody注解，否则会抛出警告，以及请求不能被处理：\n\ncontent type \'application/x-www-form-urlencoded\' not supported\n\n\n1\n# 文件上传\n通过表单上传文件时，其content-type为multipart/form-data。在接收文件时变量的类型为multipartfile，可以使用注解也可以不使用注解，而且既可以使用@requestparam也可以使用@requestpart。当使用@requestpart注解时，对应的解析器为requestpartmethodargumentresolver；当使用@requestparam或者不加注解，使用的是requestparammethodargumentresolver解析器。注意，变量的参数名或者注解的value值都必须与content-disposition描述的name一致。如果用对象来接收的话不用添加任何注解即可接收。\n\n除此之外，还可以通过获取multiparthttpservletrequest对象来手动调用getfile()或者是getfiles()方法来获取文件。\n\n当上传多个文件时，也可以使用上述方式，可以把所有文件的key都指定为一样的，然后通过数组来接收。如在postman中上传多个文件：\n\n\n\n后端接收代码为：\n\n@getmapping("upload")\npublic string hello7(multipartfile[] files) {\n    return "success";\n}\n\n\n1\n2\n3\n4\n其实，get请求也能上传文件，不一定非得用post。\n\n笔记\n\n其实关于文件上传，上面说的两种解析器中使用了代理解析器来解析。在springmvc中真正解析文件的解析器有两个，standardservletmultipartresolver和commonsmultipartresolver。前者是servlet 3.0的标准上传方式，springmvc默认会注入该解析器，使用该解析器必须要在web.xml配置<multipart-config>或者在javaconfig中使用@multipartconfig注解；后者会依赖apache的common-fileupload包，如果要使用后者，需要手动注入该bean，bean的名称必须为“multipartresolver”。具体细节后面再写一篇关于文件上传原理的文章吧。\n\n下面是在web.xml中配置<multipart-config>的实例：\n\n<servlet>\n    <servlet-name>dispatcherservlet</servlet-name>\n    <servlet-class>org.springframework.web.servlet.dispatcherservlet</servlet-class>\n    <init-param>\n        <param-name>contextconfiglocation</param-name>\n        <param-value>classpath:dispatcherservlet.xml</param-value>\n    </init-param>\n    <load-on-startup>1</load-on-startup>\n    \x3c!-- 配置在servelt标签中 --\x3e\n    <multipart-config />\n</servlet>\n\n<servlet-mapping>\n    <servlet-name>dispatcherservlet</servlet-name>\n    <url-pattern>/*</url-pattern>\n</servlet-mapping>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n# 请求头参数\n请求头的值主要通过@requestheader注解的参数获取，参数处理器是requestheadermethodargumentresolver。注意，参数名或者是注解的value值必须和请求头的字段名称一致，如果没有这样名称的字段，那么会抛出警告并返回400的错误码。\n\n可以使用@requestheader修饰map类型参数，那么将会使用requestheadermapmethodargumentresolver解析器。\n\n# cookie值\ncookie值可以使用@cookievalue注解的参数获取，由servletcookievaluemethodargumentresolver处理器进行处理。同样地，参数名或者注解的value值必须和存在的cookie字段名称对应。\n\n# 其他参数\n对于其他类型的参数，如model类型参数，或者@modelattribute参数请参考之前分析handleradapter的文章。\n\n# 日期类型处理\n日期类型的参数接收是很麻烦的，原因是通常是由字符串转换为日期对象，就涉及日期解析，由于日期格式多种多样，所以就需要我们根据期望的日期格式并提供相应的解析器。\n\n下面是几种对于接收日期类型的解决方案。\n\n * 以字符串形式接收，然后手动转换。\n   \n   \n * 可以使用@datetimeformat注解，但是只能用表单类型的提交（x-www-form-urlencoded和form-data均可）。\n   \n   class user {\n       string username;\n       integer age;\n       @datetimeformat(pattern = "yyyy-mm-dd")\n       localdate birthday;\n   }\n   \n   @postmapping("user2")\n   public string adduser2(user user) {\n       system.out.println(user); // 可以接收到数据\n       return "success";\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n * 使用@jsonformat，没有@datetimeformat那种限制。\n   \n   static class user {\n       string username;\n       integer age;\n       \n       /* 支持json格式，注意引入依赖：jackson-datatype-jsr310；否则报错 */\n       @jsonformat(pattern = "yyyy-mm-dd", timezone = "gmt+8")\n       localdate birthday;\n   }\n   \n   @postmapping("user2")\n   public string adduser2(@requestbody user user) {\n       system.out.println(user);\n       return "success";\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n * jackson序列化和反序列化定制\n   \n   @data\n   static class user {\n       string username;\n       integer age;\n       @jsondeserialize(using = customlocaldatedeserializer.class)\n       localdate birthday;\n   }\n   /* \n   根据需求选择localtimedeserializer，localdatedeserializer还是localdatetimedeserializer\n   */\n   class customlocaldatedeserializer extends localdatedeserializer {\n       public customlocaldatedeserializer() {\n           super(datetimeformatter.ofpattern("yyyy-mm-dd"));\n       }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n * 最佳实践\n   \n   直接修改mappingjackson2httpmessageconverter中的objectmapper对于日期类型处理默认的序列化器和反序列化器，这样就可以对全局生效。\n   \n   @bean\n   public jackson2objectmapperbuildercustomizer jackson2objectmapperbuildercustomizer(){\n       return customizer->{\n           /* 根据需求设置需要更改序列化逻辑的类型 */\n           customizer.serializerbytype(localdatetime.class,new localdatetimeserializer(\n               datetimeformatter.ofpattern("yyyy-mm-dd")));\n           customizer.deserializerbytype(localdatetime.class,new localdatetimedeserializer(\n               datetimeformatter.ofpattern("yyyy-mm-dd")));\n       };\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n# 参考\n * springmvc请求参数接收总结(一)\n   \n   \n * springmvc文件上传原理',charsets:{cjk:!0}},{title:"SpringBoot自动配置原理",frontmatter:{title:"SpringBoot自动配置原理",categories:["后端框架"],tags:["SpringBoot"],date:"2021-01-20T22:20:46.000Z",permalink:"/pages/84c97b/"},regularPath:"/22.%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/01.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/02.Spring%20Boot/01.%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86.html",relativePath:"22.后端框架/01.Spring全家桶/02.Spring Boot/01.自动配置原理.md",key:"v-0ec4a241",path:"/pages/84c97b/",headers:[{level:2,title:"@SpringBootApplication",slug:"springbootapplication",normalizedTitle:"@springbootapplication",charIndex:275},{level:2,title:"@EnableAutoConfiguration",slug:"enableautoconfiguration",normalizedTitle:"@enableautoconfiguration",charIndex:37},{level:2,title:"@Import",slug:"import",normalizedTitle:"@import",charIndex:2363},{level:3,title:"ImportSelector",slug:"importselector",normalizedTitle:"importselector",charIndex:2389},{level:2,title:"AutoConfigurationImportSelector",slug:"autoconfigurationimportselector",normalizedTitle:"autoconfigurationimportselector",charIndex:2372},{level:2,title:"@Conditional",slug:"conditional",normalizedTitle:"@conditional",charIndex:139},{level:3,title:"衍生注解",slug:"衍生注解",normalizedTitle:"衍生注解",charIndex:521}],excerpt:"<p>可以用一句话来描述SpringBoot的自动配置：SpringBoot通过<code>@EnableAutoConfiguration</code>注解开启自动配置，加载spring.factories中注册的各种<code>AutoConfiguration</code>类，当某个<code>AutoConfiguration</code>类满足其注解<code>@Conditional</code>指定的生效条件时，就实例化该<code>AutoConfiguration</code>类中定义的Bean，并注入Spring容器，就可以完成依赖框架的自动配置。</p>\n",lastUpdated:"2021-03-21",headersStr:"@SpringBootApplication @EnableAutoConfiguration @Import ImportSelector AutoConfigurationImportSelector @Conditional 衍生注解",content:'可以用一句话来描述SpringBoot的自动配置：SpringBoot通过@EnableAutoConfiguration注解开启自动配置，加载spring.factories中注册的各种AutoConfiguration类，当某个AutoConfiguration类满足其注解@Conditional指定的生效条件时，就实例化该AutoConfiguration类中定义的Bean，并注入Spring容器，就可以完成依赖框架的自动配置。\n\n上面一段话中涉及到几个关键组件：\n\n * @EnableAutoConfiguration：该注解由组合注解@SpringBootApplication引入，完成自动配置开启，扫描各个jar包下的spring.factories文件，并加载文件中注册的AutoConfiguration类等。\n * spring.factories：配置文件，位于jar包的META-INF目录下，该文件内按照某种格式制定了一些AutoConfiguration类。该配置配置不仅位于spring-boot-autoconfigure模块中，也可能是其他模块中。\n * @Conditional：另外还有很多该注解的衍生注解。一般这些AutoConfiguration类上面都有该注解。表示满足某些条件时才被Spring进行加载和处理。\n * starters：一些组件的集合，既包括SpringBoot预置的组件，也包括第三方的依赖。一般starters中包含了spring.factories文件，AutoConfiguration类和其他相关配置类，这些配置表示需要从当前依赖中加入哪些配置。\n\n# @SpringBootApplication\n这个注解用于修饰项目的主类，是项目的核心注解，因为其内部组合了其他的几个重要注解。\n\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan(\n  excludeFilters = {@Filter(\n  type = FilterType.CUSTOM,\n  classes = {TypeExcludeFilter.class}\n), @Filter(\n  type = FilterType.CUSTOM,\n  classes = {AutoConfigurationExcludeFilter.class}\n)}\n)\npublic @interface SpringBootApplication {\n  // 排除指定的自动配置类\n  @AliasFor(annotation = EnableAutoConfiguration.class)\n  Class<?>[] exclude() default {};\n  // 排除指定的自动配置类名\n  @AliasFor(annotation = EnableAutoConfiguration.class)\n  String[] excludeName() default {};\n\t// 指定扫描的基础包，激活注解组件的初始化\n  @AliasFor(annotation = ComponentScan.class, attribute = "basePackages")\n  String[] scanBasePackages() default {};\n  // 指定扫描的类，用于初始化\n  @AliasFor(annotation = ComponentScan.class, attribute = "basePackageClasses")\n  Class<?>[] scanBasePackageClasses() default {};\n\t// 指定是否代理@Bean方法以强制执行bean的生命周期行为\n  @AliasFor(annotation = Configuration.class)\n  boolean proxyBeanMethods() default true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n可以发现，@SpringBootApplication注解中的很多属性都由@AliasFor注解修饰，表示该配置项桥接到所指定的注解（annotation属性）中的配置项（attribute属性）中。@SpringBootApplication的存在就是为了组合多个注解的，这样设计也是为了方便用户的配置。\n\n@SpringBootApplication注解组合了@EnableAutoConfiguration用于激活自动配置，@ComponentScan用于激活扫描@Component，激活配置类的@SpringBootConfiguration。\n\n# @EnableAutoConfiguration\n这个注解用来激活自动配置，是整个自动配置的开关，位于spring-boot-autoconfigure模块内。\n\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@AutoConfigurationPackage\n@Import({AutoConfigurationImportSelector.class})\npublic @interface EnableAutoConfiguration {\n  String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration";\n  // 与@SpringBootApplication中的exclude属性一致\n  Class<?>[] exclude() default {};\n  // 与@SpringBootApplication中的excludeName属性一致\n  String[] excludeName() default {};\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n被该注解修饰的类所在包及其子包会被自动扫描，这也是为什么我们写的类文件要位于主类一级所在包的子包内。另外该注解并不是只能作用于主类上，也可以在其他类中使用。\n\n# @Import\n这个注解也是自动配置的重要注解，在前面提到的@EnableAutoConfiguration注解上，就组合了该注解。其实在整个SpringBoot中，很多EnableXXX的类都使用了该注解。\n\n我们可以通过该注解引入由@Configuration注解的类，也可以导入实现了ImportSelector（其实是加载由selectImports()方法返回的字符串数组所表示的类）或ImportBeanDefinitionRegistrar的类，另外在Spring 4.2之后，还可以导入普通的POJO类将其注册为Bean。\n\n# ImportSelector\npublic interface ImportSelector {\n  /* \n  AnnotationMetadata包含了被@Import注解所修饰的类的注解信息，以数组的形式返回一些配置类的全限定名。\n  */\n  String[] selectImports(AnnotationMetadata var1);\n\n  @Nullable\n  default Predicate<String> getExclusionFilter() {\n    return null;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n如果通过@Import引入ImportSelector的实现类，那么这些实现类中的selectImports()方法会被调用执行。如果实现了该接口的类同时又实现了以下4个Aware接口，那么Spring会保证在调用selectImports()方法之前调用这些接口中的方法。这些接口包括：EnvironmentAware，BeanFactoryAware，BeanClassLoaderAware和ResourceLoaderAware。\n\n# AutoConfigurationImportSelector\n上面提到的@EnableAutoConfiguration注解通过@Import引入了该类。AutoConfigurationImportSelector实现了ImportSelector接口的子接口DeferredImportSelector。后者相与前者的区别是后者会在所有的@Configuration修饰的类完成加载之后再加载返回的配置类（这也是defer的含义）；而ImportSelector会在加载完@Configuration修饰的类之前先去加载返回的配置类。\n\n该类中的入口方法为selectImports()：\n\n@Override\npublic String[] selectImports(AnnotationMetadata annotationMetadata) {\n    /* \n    检查是否开启自动配置功能，默认为开启。\n    可以在配置文件中配置spring.boot.enableautoconfiguration=false来关闭自动配置。\n    */\n    if (!isEnabled(annotationMetadata)) {\n        return NO_IMPORTS;\n    }\n    /* 加载自动配置的元信息，配置文件为类路径中META-INF目录下的spring-autoconfigure-metadata.properties文件（在spring-boot-autoconfigure模块下） */\n    AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader\n        .loadMetadata(this.beanClassLoader);\n    /* 封装将被引入的自动配置信息 */\n    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(autoConfigurationMetadata,\n                                                                              annotationMetadata);\n    /* 返回符合条件的配置类的全限定名数组 */\n    return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nprotected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata,\n                                                           AnnotationMetadata annotationMetadata) {\n    if (!isEnabled(annotationMetadata)) {\n        return EMPTY_ENTRY;\n    }\n    AnnotationAttributes attributes = getAttributes(annotationMetadata);\n    /* 加载类路径下的所有spring.factories文件 */\n    List<String> configurations = getCandidateConfigurations(annotationMetadata, attributes);\n    /* 可能多个spring.factories文件有重复配置，所以进行去重 */\n    configurations = removeDuplicates(configurations);\n    /* \n    排除指定组件，会收集@EnableAutoConfiguration注解中配置的exclude属性值，excludeName属性值，以及名称为spring.autoconfigure.exclude的属性值\n    */\n    Set<String> exclusions = getExclusions(annotationMetadata, attributes);\n    /* 检查被排除类，确保被排除的类存在于当前的ClassLoader中，并包含在spring.factories中，否则会抛出异常 */\n    checkExcludedClasses(configurations, exclusions);\n    /* 从配置集合中移除被排除项 */\n    configurations.removeAll(exclusions);\n    /* 对配置组件中再次过滤 */\n    configurations = filter(configurations, autoConfigurationMetadata);\n    /* 进行相关事件的封装和广播 */\n    fireAutoConfigurationImportEvents(configurations, exclusions);\n    return new AutoConfigurationEntry(configurations, exclusions);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n关于上面的组件过滤的内容比较复杂，后面再补充。\n\n# @Conditional\n这是由Spring 4.0版本引入的新特性，可根据是否满足指定的条件来决定是否进行Bean的实例化及装配。\n\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Conditional {\n\t// 只有所有指定的Condition的实现类中的matches()返回true的情况下，被注解的类才会被加载。\n\tClass<? extends Condition>[] value();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 衍生注解\n@Conditional有很多衍生注解，大部分都很好理解是什么意思，下面举几个简单例子：\n\n * @ConditionalOnBean：容器中有指定Bean的条件下。\n * @ConditinalOnMissingBean：当容器里没有指定Bean的条件时。\n * ......',normalizedContent:'可以用一句话来描述springboot的自动配置：springboot通过@enableautoconfiguration注解开启自动配置，加载spring.factories中注册的各种autoconfiguration类，当某个autoconfiguration类满足其注解@conditional指定的生效条件时，就实例化该autoconfiguration类中定义的bean，并注入spring容器，就可以完成依赖框架的自动配置。\n\n上面一段话中涉及到几个关键组件：\n\n * @enableautoconfiguration：该注解由组合注解@springbootapplication引入，完成自动配置开启，扫描各个jar包下的spring.factories文件，并加载文件中注册的autoconfiguration类等。\n * spring.factories：配置文件，位于jar包的meta-inf目录下，该文件内按照某种格式制定了一些autoconfiguration类。该配置配置不仅位于spring-boot-autoconfigure模块中，也可能是其他模块中。\n * @conditional：另外还有很多该注解的衍生注解。一般这些autoconfiguration类上面都有该注解。表示满足某些条件时才被spring进行加载和处理。\n * starters：一些组件的集合，既包括springboot预置的组件，也包括第三方的依赖。一般starters中包含了spring.factories文件，autoconfiguration类和其他相关配置类，这些配置表示需要从当前依赖中加入哪些配置。\n\n# @springbootapplication\n这个注解用于修饰项目的主类，是项目的核心注解，因为其内部组合了其他的几个重要注解。\n\n@target({elementtype.type})\n@retention(retentionpolicy.runtime)\n@documented\n@inherited\n@springbootconfiguration\n@enableautoconfiguration\n@componentscan(\n  excludefilters = {@filter(\n  type = filtertype.custom,\n  classes = {typeexcludefilter.class}\n), @filter(\n  type = filtertype.custom,\n  classes = {autoconfigurationexcludefilter.class}\n)}\n)\npublic @interface springbootapplication {\n  // 排除指定的自动配置类\n  @aliasfor(annotation = enableautoconfiguration.class)\n  class<?>[] exclude() default {};\n  // 排除指定的自动配置类名\n  @aliasfor(annotation = enableautoconfiguration.class)\n  string[] excludename() default {};\n\t// 指定扫描的基础包，激活注解组件的初始化\n  @aliasfor(annotation = componentscan.class, attribute = "basepackages")\n  string[] scanbasepackages() default {};\n  // 指定扫描的类，用于初始化\n  @aliasfor(annotation = componentscan.class, attribute = "basepackageclasses")\n  class<?>[] scanbasepackageclasses() default {};\n\t// 指定是否代理@bean方法以强制执行bean的生命周期行为\n  @aliasfor(annotation = configuration.class)\n  boolean proxybeanmethods() default true;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n可以发现，@springbootapplication注解中的很多属性都由@aliasfor注解修饰，表示该配置项桥接到所指定的注解（annotation属性）中的配置项（attribute属性）中。@springbootapplication的存在就是为了组合多个注解的，这样设计也是为了方便用户的配置。\n\n@springbootapplication注解组合了@enableautoconfiguration用于激活自动配置，@componentscan用于激活扫描@component，激活配置类的@springbootconfiguration。\n\n# @enableautoconfiguration\n这个注解用来激活自动配置，是整个自动配置的开关，位于spring-boot-autoconfigure模块内。\n\n@target({elementtype.type})\n@retention(retentionpolicy.runtime)\n@documented\n@inherited\n@autoconfigurationpackage\n@import({autoconfigurationimportselector.class})\npublic @interface enableautoconfiguration {\n  string enabled_override_property = "spring.boot.enableautoconfiguration";\n  // 与@springbootapplication中的exclude属性一致\n  class<?>[] exclude() default {};\n  // 与@springbootapplication中的excludename属性一致\n  string[] excludename() default {};\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n被该注解修饰的类所在包及其子包会被自动扫描，这也是为什么我们写的类文件要位于主类一级所在包的子包内。另外该注解并不是只能作用于主类上，也可以在其他类中使用。\n\n# @import\n这个注解也是自动配置的重要注解，在前面提到的@enableautoconfiguration注解上，就组合了该注解。其实在整个springboot中，很多enablexxx的类都使用了该注解。\n\n我们可以通过该注解引入由@configuration注解的类，也可以导入实现了importselector（其实是加载由selectimports()方法返回的字符串数组所表示的类）或importbeandefinitionregistrar的类，另外在spring 4.2之后，还可以导入普通的pojo类将其注册为bean。\n\n# importselector\npublic interface importselector {\n  /* \n  annotationmetadata包含了被@import注解所修饰的类的注解信息，以数组的形式返回一些配置类的全限定名。\n  */\n  string[] selectimports(annotationmetadata var1);\n\n  @nullable\n  default predicate<string> getexclusionfilter() {\n    return null;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n如果通过@import引入importselector的实现类，那么这些实现类中的selectimports()方法会被调用执行。如果实现了该接口的类同时又实现了以下4个aware接口，那么spring会保证在调用selectimports()方法之前调用这些接口中的方法。这些接口包括：environmentaware，beanfactoryaware，beanclassloaderaware和resourceloaderaware。\n\n# autoconfigurationimportselector\n上面提到的@enableautoconfiguration注解通过@import引入了该类。autoconfigurationimportselector实现了importselector接口的子接口deferredimportselector。后者相与前者的区别是后者会在所有的@configuration修饰的类完成加载之后再加载返回的配置类（这也是defer的含义）；而importselector会在加载完@configuration修饰的类之前先去加载返回的配置类。\n\n该类中的入口方法为selectimports()：\n\n@override\npublic string[] selectimports(annotationmetadata annotationmetadata) {\n    /* \n    检查是否开启自动配置功能，默认为开启。\n    可以在配置文件中配置spring.boot.enableautoconfiguration=false来关闭自动配置。\n    */\n    if (!isenabled(annotationmetadata)) {\n        return no_imports;\n    }\n    /* 加载自动配置的元信息，配置文件为类路径中meta-inf目录下的spring-autoconfigure-metadata.properties文件（在spring-boot-autoconfigure模块下） */\n    autoconfigurationmetadata autoconfigurationmetadata = autoconfigurationmetadataloader\n        .loadmetadata(this.beanclassloader);\n    /* 封装将被引入的自动配置信息 */\n    autoconfigurationentry autoconfigurationentry = getautoconfigurationentry(autoconfigurationmetadata,\n                                                                              annotationmetadata);\n    /* 返回符合条件的配置类的全限定名数组 */\n    return stringutils.tostringarray(autoconfigurationentry.getconfigurations());\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\nprotected autoconfigurationentry getautoconfigurationentry(autoconfigurationmetadata autoconfigurationmetadata,\n                                                           annotationmetadata annotationmetadata) {\n    if (!isenabled(annotationmetadata)) {\n        return empty_entry;\n    }\n    annotationattributes attributes = getattributes(annotationmetadata);\n    /* 加载类路径下的所有spring.factories文件 */\n    list<string> configurations = getcandidateconfigurations(annotationmetadata, attributes);\n    /* 可能多个spring.factories文件有重复配置，所以进行去重 */\n    configurations = removeduplicates(configurations);\n    /* \n    排除指定组件，会收集@enableautoconfiguration注解中配置的exclude属性值，excludename属性值，以及名称为spring.autoconfigure.exclude的属性值\n    */\n    set<string> exclusions = getexclusions(annotationmetadata, attributes);\n    /* 检查被排除类，确保被排除的类存在于当前的classloader中，并包含在spring.factories中，否则会抛出异常 */\n    checkexcludedclasses(configurations, exclusions);\n    /* 从配置集合中移除被排除项 */\n    configurations.removeall(exclusions);\n    /* 对配置组件中再次过滤 */\n    configurations = filter(configurations, autoconfigurationmetadata);\n    /* 进行相关事件的封装和广播 */\n    fireautoconfigurationimportevents(configurations, exclusions);\n    return new autoconfigurationentry(configurations, exclusions);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n关于上面的组件过滤的内容比较复杂，后面再补充。\n\n# @conditional\n这是由spring 4.0版本引入的新特性，可根据是否满足指定的条件来决定是否进行bean的实例化及装配。\n\n@target({elementtype.type, elementtype.method})\n@retention(retentionpolicy.runtime)\n@documented\npublic @interface conditional {\n\t// 只有所有指定的condition的实现类中的matches()返回true的情况下，被注解的类才会被加载。\n\tclass<? extends condition>[] value();\n\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n# 衍生注解\n@conditional有很多衍生注解，大部分都很好理解是什么意思，下面举几个简单例子：\n\n * @conditionalonbean：容器中有指定bean的条件下。\n * @conditinalonmissingbean：当容器里没有指定bean的条件时。\n * ......',charsets:{cjk:!0}},{title:"SpringBoot跨域解决方案",frontmatter:{title:"SpringBoot跨域解决方案",categories:["后端框架"],tags:["SpringBoot"],date:"2021-01-27T16:15:36.000Z",permalink:"/pages/f79e9e/"},regularPath:"/22.%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/01.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/02.Spring%20Boot/21.SpringBoot%E8%B7%A8%E5%9F%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html",relativePath:"22.后端框架/01.Spring全家桶/02.Spring Boot/21.SpringBoot跨域解决方案.md",key:"v-4494dd70",path:"/pages/f79e9e/",headers:[{level:2,title:"CORS简介",slug:"cors简介",normalizedTitle:"cors简介",charIndex:255},{level:2,title:"SpringBoot中解决跨域",slug:"springboot中解决跨域",normalizedTitle:"springboot中解决跨域",charIndex:1623},{level:3,title:"过滤器",slug:"过滤器",normalizedTitle:"过滤器",charIndex:1641},{level:3,title:"@CrossOrigin注解",slug:"crossorigin注解",normalizedTitle:"@crossorigin注解",charIndex:2421}],excerpt:"<p>当我们在前后端分离的项目中，常常需要解决跨域问题。跨域是为了解决浏览器的同源限制，浏览器之所以提出同源策略，是为了避免跨站请求伪造（Cross-Site Request Forgery，简称CSRF）攻击。所谓CSRF，就是攻击者利用受害者的身份来执行一些需要受害者授权的操作。例如用户访问了合法网站A，并且用户主机还保留用户的会话信息，那么当用户访问非法网站B，网站B可以利用用户关于网站A的会话信息向网站A的后台发起请求。在同源策略的限制下，在网站B中执行的脚本不能向其他网站发起请求，确保了安全。</p>\n",lastUpdated:"2021-02-01",headersStr:"CORS简介 SpringBoot中解决跨域 过滤器 @CrossOrigin注解",content:'当我们在前后端分离的项目中，常常需要解决跨域问题。跨域是为了解决浏览器的同源限制，浏览器之所以提出同源策略，是为了避免跨站请求伪造（Cross-Site Request Forgery，简称CSRF）攻击。所谓CSRF，就是攻击者利用受害者的身份来执行一些需要受害者授权的操作。例如用户访问了合法网站A，并且用户主机还保留用户的会话信息，那么当用户访问非法网站B，网站B可以利用用户关于网站A的会话信息向网站A的后台发起请求。在同源策略的限制下，在网站B中执行的脚本不能向其他网站发起请求，确保了安全。\n\n# CORS简介\n虽然浏览器的同源策略避免了CSRF，但是我们有时候需要突破这种限制，比如当开发前后端分离的项目时。但是请注意前后端架构的项目中不一定非要解决跨域问题，例如可以使用代理，让代理向后端发起请求。所说的源（Origin）是指：协议+域名+端口。如果该三元组一致，则说明是同源，否则称为跨域。\n\n笔记\n\n浏览器允许以下几种情况的跨域：\n\n * <script>的src属性嵌入跨域脚本。\n * <link>的rel属性嵌入css。\n * 通过<img>引入的图片。\n * 通过<video>播放的多媒体资源。\n * 通过@font-face引入的字体。\n * 通过<iframe>载入的任何资源。\n\nCORS（Cross-Origin Resource Sharing）是一个W3C标准，表示全局资源共享。CORS标准将请求分为两类，简单请求和非简单请求。\n\n简单请求是指请求方法是以下三种之一：\n\n * GET\n * POST\n * HEAD\n\n请求的头信息不超出以下几种字段：\n\n * Accept\n * Accept-Language\n * Content-Language\n * Last-Event-ID\n * Content-Type：只限于三个值（application/x-www-form-urlencoded，multipart/form-data，text/plain）。\n\n不符合上述要求的请求属于非简单请求。浏览器对于简单请求和非简单请求的处理是不一样的。浏览器对于非简单请求会发送一次预检请求，该请求必须使用OPTIONS方法。\n\n在发起CORS请求时，浏览器会设置一个名为Origin的请求头，其值为当前请求所在的源信息。服务端可以根据该Origin请求头，在响应头中设置一些响应的字段，浏览器会检查响应头，如果没有响应的响应头则会丢弃该请求并抛出异常。与CORS有关的响应头包括下面几种：\n\n * Access-Control-Allow-Origin（必填）：表示服务端所能允许的源信息，如果接收任何源，则可以设置为*。\n * Access-Control-Allow-Methods（可选）：表示服务端所支持的所有跨域请求的方法，如果支持所有的方法那么设置为*。\n * Access-Control-Expose-Headers（可选）：一般情况下，请求方只能从响应中拿到6各基本字段（Cache-Control，Content-Language，Content-Type，Expire，Last-Modified，Pragma），如果服务端允许请求方获取其他字段，就必须在Access-Control-Expose-Headers里面指定。\n * Access-Control-Allow-Credentials（可选）：该字段的值为true或false，表示服务端是否允许浏览器发送Cookie。但是如果请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json，那么这个字段必须设置为true。\n * Access-Control-Max-Age（可选）：用来指定预检请求的有效期，单位为秒。浏览器会在有效期内不用发出另一条预检请求。\n\n# SpringBoot中解决跨域\n# 过滤器\n@WebFilter(filterName = "CorsFilter ")\n@Configuration\npublic class CorsFilter implements Filter {\n    @Override\n    public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {\n        HttpServletResponse response = (HttpServletResponse) res;\n        response.setHeader("Access-Control-Allow-Origin","*");\n        response.setHeader("Access-Control-Allow-Credentials", "true");\n        response.setHeader("Access-Control-Allow-Methods", "POST, PATCH, DELETE, PUT");\n        response.setHeader("Access-Control-Max-Age", "3600");\n        response.setHeader("Access-Control-Allow-Headers", "Origin, X-Requested-With, Content-Type, Accept");\n        chain.doFilter(req, res);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# @CrossOrigin注解\npublic class HelloController {\n@CrossOrigin(origins = "*")\n@GetMapping("hello")\npublic String hello(@RequestParam String goodsUrl) {\n    return "hello";\n} \n\n\n1\n2\n3\n4\n5\n6\n该注解可以作用在方法或类上，可以做到最小粒度的控制。',normalizedContent:'当我们在前后端分离的项目中，常常需要解决跨域问题。跨域是为了解决浏览器的同源限制，浏览器之所以提出同源策略，是为了避免跨站请求伪造（cross-site request forgery，简称csrf）攻击。所谓csrf，就是攻击者利用受害者的身份来执行一些需要受害者授权的操作。例如用户访问了合法网站a，并且用户主机还保留用户的会话信息，那么当用户访问非法网站b，网站b可以利用用户关于网站a的会话信息向网站a的后台发起请求。在同源策略的限制下，在网站b中执行的脚本不能向其他网站发起请求，确保了安全。\n\n# cors简介\n虽然浏览器的同源策略避免了csrf，但是我们有时候需要突破这种限制，比如当开发前后端分离的项目时。但是请注意前后端架构的项目中不一定非要解决跨域问题，例如可以使用代理，让代理向后端发起请求。所说的源（origin）是指：协议+域名+端口。如果该三元组一致，则说明是同源，否则称为跨域。\n\n笔记\n\n浏览器允许以下几种情况的跨域：\n\n * <script>的src属性嵌入跨域脚本。\n * <link>的rel属性嵌入css。\n * 通过<img>引入的图片。\n * 通过<video>播放的多媒体资源。\n * 通过@font-face引入的字体。\n * 通过<iframe>载入的任何资源。\n\ncors（cross-origin resource sharing）是一个w3c标准，表示全局资源共享。cors标准将请求分为两类，简单请求和非简单请求。\n\n简单请求是指请求方法是以下三种之一：\n\n * get\n * post\n * head\n\n请求的头信息不超出以下几种字段：\n\n * accept\n * accept-language\n * content-language\n * last-event-id\n * content-type：只限于三个值（application/x-www-form-urlencoded，multipart/form-data，text/plain）。\n\n不符合上述要求的请求属于非简单请求。浏览器对于简单请求和非简单请求的处理是不一样的。浏览器对于非简单请求会发送一次预检请求，该请求必须使用options方法。\n\n在发起cors请求时，浏览器会设置一个名为origin的请求头，其值为当前请求所在的源信息。服务端可以根据该origin请求头，在响应头中设置一些响应的字段，浏览器会检查响应头，如果没有响应的响应头则会丢弃该请求并抛出异常。与cors有关的响应头包括下面几种：\n\n * access-control-allow-origin（必填）：表示服务端所能允许的源信息，如果接收任何源，则可以设置为*。\n * access-control-allow-methods（可选）：表示服务端所支持的所有跨域请求的方法，如果支持所有的方法那么设置为*。\n * access-control-expose-headers（可选）：一般情况下，请求方只能从响应中拿到6各基本字段（cache-control，content-language，content-type，expire，last-modified，pragma），如果服务端允许请求方获取其他字段，就必须在access-control-expose-headers里面指定。\n * access-control-allow-credentials（可选）：该字段的值为true或false，表示服务端是否允许浏览器发送cookie。但是如果请求方法是put或delete，或者content-type字段的类型是application/json，那么这个字段必须设置为true。\n * access-control-max-age（可选）：用来指定预检请求的有效期，单位为秒。浏览器会在有效期内不用发出另一条预检请求。\n\n# springboot中解决跨域\n# 过滤器\n@webfilter(filtername = "corsfilter ")\n@configuration\npublic class corsfilter implements filter {\n    @override\n    public void dofilter(servletrequest req, servletresponse res, filterchain chain) throws ioexception, servletexception {\n        httpservletresponse response = (httpservletresponse) res;\n        response.setheader("access-control-allow-origin","*");\n        response.setheader("access-control-allow-credentials", "true");\n        response.setheader("access-control-allow-methods", "post, patch, delete, put");\n        response.setheader("access-control-max-age", "3600");\n        response.setheader("access-control-allow-headers", "origin, x-requested-with, content-type, accept");\n        chain.dofilter(req, res);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n# @crossorigin注解\npublic class hellocontroller {\n@crossorigin(origins = "*")\n@getmapping("hello")\npublic string hello(@requestparam string goodsurl) {\n    return "hello";\n} \n\n\n1\n2\n3\n4\n5\n6\n该注解可以作用在方法或类上，可以做到最小粒度的控制。',charsets:{cjk:!0}},{title:"SpringBoot中Filter的注册",frontmatter:{title:"SpringBoot中Filter的注册",categories:["后端框架"],tags:["SpringBoot","Filter"],date:"2021-02-07T20:43:06.000Z",permalink:"/pages/e0358f/"},regularPath:"/22.%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/01.Spring%E5%85%A8%E5%AE%B6%E6%A1%B6/02.Spring%20Boot/22.SpringBoot%E4%B8%ADFilter%E7%9A%84%E6%B3%A8%E5%86%8C.html",relativePath:"22.后端框架/01.Spring全家桶/02.Spring Boot/22.SpringBoot中Filter的注册.md",key:"v-6d65ba6a",path:"/pages/e0358f/",headers:[{level:2,title:"@WebFilter",slug:"webfilter",normalizedTitle:"@webfilter",charIndex:153},{level:2,title:"@Bean",slug:"bean",normalizedTitle:"@bean",charIndex:461},{level:2,title:"FilterRegistrationBean",slug:"filterregistrationbean",normalizedTitle:"filterregistrationbean",charIndex:677}],excerpt:"<p>在以前使用部署描述符web.xml时，配置过滤器是很明了的事情。我之前一直不是很重视过滤器（是因为不常手写），然而在Spring Security中，过滤器是核心实现原理之一，了解过滤器的执行原理是了解Spring Security执行原理的基础。本文就过滤器在Spring Boot中的注册说起。</p>\n",lastUpdated:"2021-02-07",headersStr:"@WebFilter @Bean FilterRegistrationBean",content:'在以前使用部署描述符web.xml时，配置过滤器是很明了的事情。我之前一直不是很重视过滤器（是因为不常手写），然而在Spring Security中，过滤器是核心实现原理之一，了解过滤器的执行原理是了解Spring Security执行原理的基础。本文就过滤器在Spring Boot中的注册说起。\n\n# @WebFilter\n该注解位于javax.servlet.annotation包下，属于Servlet规范定义的内容，与Spring体系无关。可以用该注解修饰javax.servlet.Filter的实现类，即可实现Filter的注册。可以通过该注解的value或urlPatterns属性传递该拦截器的拦截规则。另外，需要在项目主类上配置@ServletComponentScan注解，否则@WebFilter不生效。很明显，这种方式注册无法指定过滤器的优先级。\n\n注意\n\n在servlet容器启动时，容器会找到被该注解所修饰的类，至于是怎么找到的，目前不是很清楚，需要参考各自servlet容器的实现。\n\n# @Bean\n将过滤器配置成普通的bean，这种方法不再需要@ServletComponentScan。另外，可以通过@Order注解指定过滤器的优先级。这种方式配置的过滤器无法指定拦截规则，只能是/*，即拦截所有的请求。\n\n笔记\n\n拦截器的规则之区别：/和/*，前者不会拦截静态资源，而后者拦截所有请求。\n\n特别注意，不要加了@WebFilter，还让该filter成为Spring容器中的bean，否则会产生两次重复拦截。\n\n# FilterRegistrationBean\n这种方案本质上还是将filter封装成一个bean，但这个bean是FilterRegistrationBean。\n\n@Bean\nFilterRegistrationBean<MyFilter> myFilterFilterRegistrationBean() {\n    FilterRegistrationBean<MyFilter> bean = new FilterRegistrationBean<>();\n    bean.setFilter(new MyFilter());\n    bean.setOrder(-1);\n    bean.setUrlPatterns(Arrays.asList("/*"));\n    return bean;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n可以发现，FilterRegistrationBean封装了filter，并且还可以设置优先级和请求规则，两全其美。\n\n下面是FilterRegistrationBean的继承类图：\n\n\n\n在继承链的顶部有一个接口叫做ServletContextInitializer，该接口中定义了一个叫做onStartup()方法，在servlet容器启动的时候，该方法会被调用。还是老套路，在整个继承链中多次使用了模板方法的设计模式，看一下源码就知道过滤器是怎么被注册的了，最终是通过ServletContext中的addFilter()方法实现的。',normalizedContent:'在以前使用部署描述符web.xml时，配置过滤器是很明了的事情。我之前一直不是很重视过滤器（是因为不常手写），然而在spring security中，过滤器是核心实现原理之一，了解过滤器的执行原理是了解spring security执行原理的基础。本文就过滤器在spring boot中的注册说起。\n\n# @webfilter\n该注解位于javax.servlet.annotation包下，属于servlet规范定义的内容，与spring体系无关。可以用该注解修饰javax.servlet.filter的实现类，即可实现filter的注册。可以通过该注解的value或urlpatterns属性传递该拦截器的拦截规则。另外，需要在项目主类上配置@servletcomponentscan注解，否则@webfilter不生效。很明显，这种方式注册无法指定过滤器的优先级。\n\n注意\n\n在servlet容器启动时，容器会找到被该注解所修饰的类，至于是怎么找到的，目前不是很清楚，需要参考各自servlet容器的实现。\n\n# @bean\n将过滤器配置成普通的bean，这种方法不再需要@servletcomponentscan。另外，可以通过@order注解指定过滤器的优先级。这种方式配置的过滤器无法指定拦截规则，只能是/*，即拦截所有的请求。\n\n笔记\n\n拦截器的规则之区别：/和/*，前者不会拦截静态资源，而后者拦截所有请求。\n\n特别注意，不要加了@webfilter，还让该filter成为spring容器中的bean，否则会产生两次重复拦截。\n\n# filterregistrationbean\n这种方案本质上还是将filter封装成一个bean，但这个bean是filterregistrationbean。\n\n@bean\nfilterregistrationbean<myfilter> myfilterfilterregistrationbean() {\n    filterregistrationbean<myfilter> bean = new filterregistrationbean<>();\n    bean.setfilter(new myfilter());\n    bean.setorder(-1);\n    bean.seturlpatterns(arrays.aslist("/*"));\n    return bean;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n可以发现，filterregistrationbean封装了filter，并且还可以设置优先级和请求规则，两全其美。\n\n下面是filterregistrationbean的继承类图：\n\n\n\n在继承链的顶部有一个接口叫做servletcontextinitializer，该接口中定义了一个叫做onstartup()方法，在servlet容器启动的时候，该方法会被调用。还是老套路，在整个继承链中多次使用了模板方法的设计模式，看一下源码就知道过滤器是怎么被注册的了，最终是通过servletcontext中的addfilter()方法实现的。',charsets:{cjk:!0}},{title:"Maven依赖",frontmatter:{title:"Maven依赖",categories:["开发工具"],tags:["Maven"],date:"2021-01-21T20:20:20.000Z",permalink:"/pages/65a539/"},regularPath:"/99.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/01.maven/01.%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86.html",relativePath:"99.开发工具/01.maven/01.依赖管理.md",key:"v-7a35187e",path:"/pages/65a539/",headers:[{level:2,title:"项目的坐标",slug:"项目的坐标",normalizedTitle:"项目的坐标",charIndex:63},{level:2,title:"依赖的配置",slug:"依赖的配置",normalizedTitle:"依赖的配置",charIndex:591},{level:2,title:"依赖的范围",slug:"依赖的范围",normalizedTitle:"依赖的范围",charIndex:1144},{level:2,title:"传递性依赖",slug:"传递性依赖",normalizedTitle:"传递性依赖",charIndex:1191},{level:2,title:"依赖调解",slug:"依赖调解",normalizedTitle:"依赖调解",charIndex:2201},{level:2,title:"可选依赖",slug:"可选依赖",normalizedTitle:"可选依赖",charIndex:2489},{level:2,title:"排除依赖",slug:"排除依赖",normalizedTitle:"排除依赖",charIndex:2622},{level:2,title:"归类依赖",slug:"归类依赖",normalizedTitle:"归类依赖",charIndex:3097},{level:2,title:"优化依赖",slug:"优化依赖",normalizedTitle:"优化依赖",charIndex:3864}],excerpt:"<p>Maven的一大功能是管理项目依赖，避免了我们手动去下载依赖添加到项目中。本文就来探讨一下Maven是如何管理依赖的。</p>\n",lastUpdated:"2021-01-23",headersStr:"项目的坐标 依赖的配置 依赖的范围 传递性依赖 依赖调解 可选依赖 排除依赖 归类依赖 优化依赖",content:"Maven的一大功能是管理项目依赖，避免了我们手动去下载依赖添加到项目中。本文就来探讨一下Maven是如何管理依赖的。\n\n# 项目的坐标\n为了标识每一个项目，Maven引入了坐标的概念，在Maven的世界里一个确定的坐标是独一无二的，犹如在三维空间中P(a,b,c)P(a, b, c)P(a,b,c)坐标唯一标识一个点一样。就像三位坐标系规定了横纵轴坐标元素一样，Maven坐标也由很多元素定义：\n\n * groupId：定义当前Maven项目隶属的实际项目，当前项目有可能只是实际项目中的其中一个模块。比如spring-core（当前项目）就是SpringFramework（实际项目）的一个模块。\n * artifactId：定义实际项目中的一个Maven项目。推荐使用实际项目名称作为artifactId的前缀。\n * version：当前Maven项目所处的版本。Maven定义一套版本规范，最好遵循该规范。\n * packaging：该元素定义Maven项目的打包方式，当不定义该元素时，Maven会使用默认值jar。\n * classifier：该元素用来帮助定义构建输出的一些附属构件。注意，不能直接定义项目的classfier，因为项目的附属构件不是项目直接默认生成的，而是由附加的插件帮助生成的。\n\n上面5个元素中，前三个是必须的，属于坐标中的基本元素。\n\n# 依赖的配置\n下面是一个简单的依赖配置：\n\n<project>\n\t...\n  <dependencies>\n  \t<dependency>\n    \t<groupId>...</groupId>\n      <artifactId>...</artifactId>\n      <version>...</version>\n      <type>...</type>\n      <scope>...</scope>\n      <optional>...</optional>\n      <exclusions>\n      \t<exclusion>\n          ...\n        </exclusion>\n        ...\n      </exclusions>\n    </dependency>\n    ...\n  </dependencies>\n  ...\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n * groupId，artifactId，version，这三个元素是配置依赖是最重要的。\n * type，依赖的类型对应于项目坐标定义中的packaging。\n * scope，依赖的范围。\n * optional，标记依赖是否可选。\n * exclusions，用来排除传递性依赖，见下文。\n\n# 依赖的范围\n依赖范围是用来控制依赖与三种classpath的关系（编译classpath，测试classpath，运行classpath）。\n\nMaven中有以下几种依赖范围：\n\n * compile：编译依赖范围。如果没有指定，就会默认使用该依赖范围。这种范围对于编译，测试和运行三种classpath都有效。\n * test：测试依赖范围。使用此依赖范围的Maven依赖，只对于测试classpath有效。如JUnit，只在测试的时候需要。\n * provided：已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时无效。如servlet-api，编译和测试项目的时候需要该依赖，项目部署后，由于Servlet容器已经提供了，所以就不需要重复引入该依赖了。\n * runtime：运行时依赖范围。对于测试和运行classpath有效，但对编译classpath无效。如JDBC驱动，在编译时只需要提供JDK提供的JDBC相关接口即可，只有在指向测试或者运行项目的时候才会需要具体的JDBC驱动实现。\n * system：系统依赖范围。与classpath的关系和provided一样，但是使用这种类型的范围时，必须通过systemPath元素显式地指定依赖文件的路径。此类依赖不是maven仓库解析的，往往从本机系统导入。\n * import：导入依赖范围。该范围不会对三种classpath产生实际的影响。\n\n# 传递性依赖\n假如项目A依赖了项目B，项目B又依赖了项目C，那么A传递性依赖了项目C，B对于A是第一直接依赖，C对于B是第二直接依赖，C对于A就是传递性依赖。第一直接依赖的范围和第二直接依赖的范围决定了传递性依赖的范围。\n\n * 当第二直接依的赖范围是compile的时候，传递性依赖的范围与第一直接依赖的范围一致。\n * 当第二直接依赖的范围是test的时候，依赖不会得以传递，也就是不会产生传递性依赖。\n * 当第二直接依赖的范围是provided的时候，只有在第一直接依赖范围也为provided的时候才产生传递依赖。\n * 当第二直接依赖的范围是runtime的时候，传递性依赖的范围与第一直接依赖的范围一致，但compile例外，此时传递性依赖的范围为runtime。\n\n关于后两种确实不好理解，需要多想一下。\n\n# 依赖调解\n我们通常只用考虑第一直接依赖，一般情况下是不会重复引入的，但是传递性依赖可能会导致依赖冲突。比如对于下面两条依赖路径：\n\nA -> B -> C -> X(1.0)\nA -> D -> X(2.0)\n\n\n1\n2\nX属于A的传递性依赖，但是两条路径上有两个版本的X，此时就产生了冲突。所以需要Maven来进行依赖调解。\n\nMaven的第一原则是，路径最近者优先。在上例中，会引入2.0版本的X。但是第一原则不能解决所有的问题，比如路径长度相等时。\n\nMaven的第二原则是第一声明者优先，在依赖路径长度相等的情况下，在POM中依赖声明中顺序靠前的会被解析使用。\n\n# 可选依赖\n可选依赖是指在POM中声明了多个依赖，但是在使用中只会依赖其中一种依赖。可以将依赖的optional选项的值设置为true。假设项目B引入了MySQL和Oracle的可选依赖，项目A依赖项目B，这两个可选依赖不会传递，A中需要显式地声明所用的依赖。\n\n# 排除依赖\n当项目A依赖项目B，项目B依赖项目C（v1.0.0），但是我们想使用C(v2.0.0)，则可以在A项目中引入项目B时排除掉C（v1.0.0），同时在项目A中引入项目C（v2.0.0）。下面是在Spring Boot中移除内嵌tomcat的示例：\n\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-web</artifactId>\n  \x3c!-- 去除内嵌tomcat --\x3e\n  <exclusions>\n    <exclusion>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-tomcat</artifactId>\n    </exclusion>\n  </exclusions>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 归类依赖\n在声明依赖时，有很多某一类的依赖，可以将这一类的依赖版本进行统一，使用属性来代替显式的版本参数。如下面的例子所示，三个依赖使用同一个版本，将来升级时，只需要改一个地方就可以了。\n\n<properties>\n  <jackson.version>2.9.8</jackson.version>\n</properties>\n<dependencies>\n  <dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-core</artifactId>\n    <version>${jackson.version}</version>\n  </dependency>\n\t<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n    <version>${jackson.version}</version>\n   </dependency>\n   <dependency>\n    <groupId>com.fasterxml.jackson.datatype</groupId>\n    <artifactId>jackson-datatype-jsr310</artifactId>\n    <version>${jackson.version}</version>\n   </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 优化依赖\nMaven会自动解析所有项目的直接依赖和传递性依赖，并且根据规则正确判断每个依赖的范围，对于一些依赖冲突也能进行调节，以确保任何一个构件只有唯一的版本在依赖中存在。最后得到的依赖被称为已解析依赖。\n\n可以使用下列命令查看已解析依赖：\n\nmvn dependency:list\n\n\n1\n该命令会列出被maven解析的依赖（包括直接和传递性依赖）。另外，还可以通过下列命令查看依赖树：\n\nmvn dependency:tree\n\n\n1\n会已树形结构列出maven已解析的依赖。\n\n另外，还可以使用下列命令进行依赖分析：\n\nmvn dependency:analyze\n\n\n1\n可以查看到有哪些手动直接引入的依赖，有哪些引入了但没有使用的依赖等信息。",normalizedContent:"maven的一大功能是管理项目依赖，避免了我们手动去下载依赖添加到项目中。本文就来探讨一下maven是如何管理依赖的。\n\n# 项目的坐标\n为了标识每一个项目，maven引入了坐标的概念，在maven的世界里一个确定的坐标是独一无二的，犹如在三维空间中p(a,b,c)p(a, b, c)p(a,b,c)坐标唯一标识一个点一样。就像三位坐标系规定了横纵轴坐标元素一样，maven坐标也由很多元素定义：\n\n * groupid：定义当前maven项目隶属的实际项目，当前项目有可能只是实际项目中的其中一个模块。比如spring-core（当前项目）就是springframework（实际项目）的一个模块。\n * artifactid：定义实际项目中的一个maven项目。推荐使用实际项目名称作为artifactid的前缀。\n * version：当前maven项目所处的版本。maven定义一套版本规范，最好遵循该规范。\n * packaging：该元素定义maven项目的打包方式，当不定义该元素时，maven会使用默认值jar。\n * classifier：该元素用来帮助定义构建输出的一些附属构件。注意，不能直接定义项目的classfier，因为项目的附属构件不是项目直接默认生成的，而是由附加的插件帮助生成的。\n\n上面5个元素中，前三个是必须的，属于坐标中的基本元素。\n\n# 依赖的配置\n下面是一个简单的依赖配置：\n\n<project>\n\t...\n  <dependencies>\n  \t<dependency>\n    \t<groupid>...</groupid>\n      <artifactid>...</artifactid>\n      <version>...</version>\n      <type>...</type>\n      <scope>...</scope>\n      <optional>...</optional>\n      <exclusions>\n      \t<exclusion>\n          ...\n        </exclusion>\n        ...\n      </exclusions>\n    </dependency>\n    ...\n  </dependencies>\n  ...\n</project>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n * groupid，artifactid，version，这三个元素是配置依赖是最重要的。\n * type，依赖的类型对应于项目坐标定义中的packaging。\n * scope，依赖的范围。\n * optional，标记依赖是否可选。\n * exclusions，用来排除传递性依赖，见下文。\n\n# 依赖的范围\n依赖范围是用来控制依赖与三种classpath的关系（编译classpath，测试classpath，运行classpath）。\n\nmaven中有以下几种依赖范围：\n\n * compile：编译依赖范围。如果没有指定，就会默认使用该依赖范围。这种范围对于编译，测试和运行三种classpath都有效。\n * test：测试依赖范围。使用此依赖范围的maven依赖，只对于测试classpath有效。如junit，只在测试的时候需要。\n * provided：已提供依赖范围。使用此依赖范围的maven依赖，对于编译和测试classpath有效，但在运行时无效。如servlet-api，编译和测试项目的时候需要该依赖，项目部署后，由于servlet容器已经提供了，所以就不需要重复引入该依赖了。\n * runtime：运行时依赖范围。对于测试和运行classpath有效，但对编译classpath无效。如jdbc驱动，在编译时只需要提供jdk提供的jdbc相关接口即可，只有在指向测试或者运行项目的时候才会需要具体的jdbc驱动实现。\n * system：系统依赖范围。与classpath的关系和provided一样，但是使用这种类型的范围时，必须通过systempath元素显式地指定依赖文件的路径。此类依赖不是maven仓库解析的，往往从本机系统导入。\n * import：导入依赖范围。该范围不会对三种classpath产生实际的影响。\n\n# 传递性依赖\n假如项目a依赖了项目b，项目b又依赖了项目c，那么a传递性依赖了项目c，b对于a是第一直接依赖，c对于b是第二直接依赖，c对于a就是传递性依赖。第一直接依赖的范围和第二直接依赖的范围决定了传递性依赖的范围。\n\n * 当第二直接依的赖范围是compile的时候，传递性依赖的范围与第一直接依赖的范围一致。\n * 当第二直接依赖的范围是test的时候，依赖不会得以传递，也就是不会产生传递性依赖。\n * 当第二直接依赖的范围是provided的时候，只有在第一直接依赖范围也为provided的时候才产生传递依赖。\n * 当第二直接依赖的范围是runtime的时候，传递性依赖的范围与第一直接依赖的范围一致，但compile例外，此时传递性依赖的范围为runtime。\n\n关于后两种确实不好理解，需要多想一下。\n\n# 依赖调解\n我们通常只用考虑第一直接依赖，一般情况下是不会重复引入的，但是传递性依赖可能会导致依赖冲突。比如对于下面两条依赖路径：\n\na -> b -> c -> x(1.0)\na -> d -> x(2.0)\n\n\n1\n2\nx属于a的传递性依赖，但是两条路径上有两个版本的x，此时就产生了冲突。所以需要maven来进行依赖调解。\n\nmaven的第一原则是，路径最近者优先。在上例中，会引入2.0版本的x。但是第一原则不能解决所有的问题，比如路径长度相等时。\n\nmaven的第二原则是第一声明者优先，在依赖路径长度相等的情况下，在pom中依赖声明中顺序靠前的会被解析使用。\n\n# 可选依赖\n可选依赖是指在pom中声明了多个依赖，但是在使用中只会依赖其中一种依赖。可以将依赖的optional选项的值设置为true。假设项目b引入了mysql和oracle的可选依赖，项目a依赖项目b，这两个可选依赖不会传递，a中需要显式地声明所用的依赖。\n\n# 排除依赖\n当项目a依赖项目b，项目b依赖项目c（v1.0.0），但是我们想使用c(v2.0.0)，则可以在a项目中引入项目b时排除掉c（v1.0.0），同时在项目a中引入项目c（v2.0.0）。下面是在spring boot中移除内嵌tomcat的示例：\n\n<dependency>\n  <groupid>org.springframework.boot</groupid>\n  <artifactid>spring-boot-starter-web</artifactid>\n  \x3c!-- 去除内嵌tomcat --\x3e\n  <exclusions>\n    <exclusion>\n      <groupid>org.springframework.boot</groupid>\n      <artifactid>spring-boot-starter-tomcat</artifactid>\n    </exclusion>\n  </exclusions>\n</dependency>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n# 归类依赖\n在声明依赖时，有很多某一类的依赖，可以将这一类的依赖版本进行统一，使用属性来代替显式的版本参数。如下面的例子所示，三个依赖使用同一个版本，将来升级时，只需要改一个地方就可以了。\n\n<properties>\n  <jackson.version>2.9.8</jackson.version>\n</properties>\n<dependencies>\n  <dependency>\n    <groupid>com.fasterxml.jackson.core</groupid>\n    <artifactid>jackson-core</artifactid>\n    <version>${jackson.version}</version>\n  </dependency>\n\t<dependency>\n    <groupid>com.fasterxml.jackson.core</groupid>\n    <artifactid>jackson-databind</artifactid>\n    <version>${jackson.version}</version>\n   </dependency>\n   <dependency>\n    <groupid>com.fasterxml.jackson.datatype</groupid>\n    <artifactid>jackson-datatype-jsr310</artifactid>\n    <version>${jackson.version}</version>\n   </dependency>\n</dependencies>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n# 优化依赖\nmaven会自动解析所有项目的直接依赖和传递性依赖，并且根据规则正确判断每个依赖的范围，对于一些依赖冲突也能进行调节，以确保任何一个构件只有唯一的版本在依赖中存在。最后得到的依赖被称为已解析依赖。\n\n可以使用下列命令查看已解析依赖：\n\nmvn dependency:list\n\n\n1\n该命令会列出被maven解析的依赖（包括直接和传递性依赖）。另外，还可以通过下列命令查看依赖树：\n\nmvn dependency:tree\n\n\n1\n会已树形结构列出maven已解析的依赖。\n\n另外，还可以使用下列命令进行依赖分析：\n\nmvn dependency:analyze\n\n\n1\n可以查看到有哪些手动直接引入的依赖，有哪些引入了但没有使用的依赖等信息。",charsets:{cjk:!0}},{title:"Maven中的生命周期和插件",frontmatter:{title:"Maven中的生命周期和插件",categories:["开发工具"],tags:["Maven"],date:"2021-01-23T21:54:54.000Z",permalink:"/pages/a4afbf/"},regularPath:"/99.%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/01.maven/02.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8F%92%E4%BB%B6.html",relativePath:"99.开发工具/01.maven/02.生命周期和插件.md",key:"v-85b99504",path:"/pages/a4afbf/",headers:[{level:2,title:"生命周期",slug:"生命周期",normalizedTitle:"生命周期",charIndex:7},{level:3,title:"三套生命周期",slug:"三套生命周期",normalizedTitle:"三套生命周期",charIndex:173},{level:3,title:"clean生命周期",slug:"clean生命周期",normalizedTitle:"clean生命周期",charIndex:222},{level:3,title:"default生命周期",slug:"default生命周期",normalizedTitle:"default生命周期",charIndex:240},{level:3,title:"site生命周期",slug:"site生命周期",normalizedTitle:"site生命周期",charIndex:261},{level:3,title:"命令行",slug:"命令行",normalizedTitle:"命令行",charIndex:1563},{level:2,title:"插件",slug:"插件",normalizedTitle:"插件",charIndex:103},{level:3,title:"插件目标",slug:"插件目标",normalizedTitle:"插件目标",charIndex:1958},{level:3,title:"插件绑定",slug:"插件绑定",normalizedTitle:"插件绑定",charIndex:2078},{level:3,title:"插件配置",slug:"插件配置",normalizedTitle:"插件配置",charIndex:2256},{level:3,title:"获取插件信息",slug:"获取插件信息",normalizedTitle:"获取插件信息",charIndex:3169}],excerpt:"<p>Maven中的生命周期包含了项目的清理，初始化，编译，测试，打包，集成测试，验证，部署和站点生成等几乎所有的构建步骤。不过Maven的生命周期是抽象的，这意味着生命周期本身不做任何实际的工作，每个步骤都交给插件来完成。可以说生命周期定义了行为，而插件来实现这些行为。</p>\n",lastUpdated:"2021-01-23",headersStr:"生命周期 三套生命周期 clean生命周期 default生命周期 site生命周期 命令行 插件 插件目标 插件绑定 插件配置 获取插件信息",content:'Maven中的生命周期包含了项目的清理，初始化，编译，测试，打包，集成测试，验证，部署和站点生成等几乎所有的构建步骤。不过Maven的生命周期是抽象的，这意味着生命周期本身不做任何实际的工作，每个步骤都交给插件来完成。可以说生命周期定义了行为，而插件来实现这些行为。\n\n注意\n\n本文的内容大多总结自《Maven实战》这本书。\n\n# 生命周期\n# 三套生命周期\nMaven定义了三套相互独立的生命周期，分别为clean，default和site。clean生命周期的目的是清理项目，default生命周期的目的是构建项目，而site生命周期的目的是建立项目站点。每个生命周期包含一些阶段，这些阶段是有顺序的，位于后面的阶段依赖于前面的阶段。\n\n这三套生命周期是相互独立的，调用其中一套，不会触发另外一套。\n\n# clean生命周期\nclean生命周期包括三个阶段：\n\n * pre-clean：执行一些清理前需要完成的工作。\n * clean：清理上一次构建生成的文件。\n * post-clean：执行一些清理后需要完成的工作。\n\n# default生命周期\ndefault生命周期是所有生命周期中最核心的部分，定义了真正构建时需要执行的所有步骤。\n\n * validate\n * initialize\n * generate-sources\n * process-sources：处理项目主资源文件，对src/main/resources目录的内容进行变量替换等工作后，复制到项目输出的主classpath目录中。\n * generate-resources\n * process-resources\n * compile：编译项目的主源码，编译src/main/java目录下的Java文件至项目输出的主classpath目录中。\n * process-classes\n * generate-test-sources\n * process-test-sources：处理项目测试资源文件，对src/test/resources目录的内容进行变量替换等工作后，复制到项目输出的测试classpath目录中。\n * generate-test-resources\n * process-test-resources\n * test-compile：编译项目的测试源码，编译src/test/java目录下的Java文件至项目输出的测试classpath目录中。\n * process-test-classes\n * test：使用单元测试框架运行测试，测试代码不会被打包或部署。\n * prepare-package\n * package：接收编译好的代码，打包成可发布的格式，如Jar。\n * pre-integration-test\n * integration-test\n * post-integration-test\n * verify\n * install：将包安装到Maven本地仓库，供本地其他Maven项目使用。\n * deploy：将最终的包复制到远程仓库，供其他开发人员和Maven项目使用。\n\n可见整个生命周期包含了很多阶段，对于每一个阶段更详细的介绍可以参考官方文档。\n\n# site生命周期\nsite生命周期的目的是建立和发布项目站点，Maven能够基于POM所包含的信息，自动生成一个友好的站点，方便团队交流和发布项目信息。主要包含下面几个阶段：\n\n * pre-site：执行一些在生成项目站点之前需要完成的工作。\n * site：生成项目站点文档。\n * post-site：执行一些在生成项目站点之后需要完成的工作。\n * site-deploy：将生成的项目站点发布到服务器上。\n\n# 命令行\n下面是一些与Maven生命周期相关的命令：\n\n * mvn clean：该命令调用clean生命周期的clean阶段，实际执行的阶段为clean生命周期的pre-clean和clean阶段。\n * mvn test：该命令调用default生命周期的test阶段，该命令会执行default上面周期一开始直到test阶段的所有阶段。\n * mvn clean install：该命令调用clean生命周期的clean阶段和default阶段的install阶段，同样地，是从每种生命周期一开始的阶段直到对应的阶段。\n * mvn clean deploy site-deploy：该命令调用clean生命周期的clean阶段和default生命周期的deploy阶段以及site阶段的site-deploy阶段。同样地，是从每种生命周期一开始的阶段直到对应的阶段。\n\n# 插件\n# 插件目标\n一般每个插件都具有多种功能，而每种功能被称为插件的目标。比如maven-dependency-plugin:analyze对应了maven-dependency-plugin插件的analyze目标（analyze功能）。\n\n# 插件绑定\nMaven的生命周期和插件相互绑定，用以完成实际的构建任务。例如default生命周期中的compile这一阶段可以与maven-compiler-plugin这一插件的compile目标所绑定。Maven默认已经内置了很多绑定了，另外也可以自定义插件绑定。当多个插件目标绑定到统一阶段的时候，这些插件声明的先后顺序决定了目标的执行顺序。\n\n# 插件配置\n下面是一个简单的自定义的插件绑定配置：\n\n<build>\n\t<plugins>\n\t\t<plugin>\n\t\t\t\x3c!-- 插件依赖 --\x3e\n\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t<artifactId>maven-shade-plugin</artifactId>\n\t\t\t\x3c!-- executions下的每一个execution对应一个任务 --\x3e\n\t\t\t<executions>\n\t\t\t\t<execution>\n\t\t\t\t\t\x3c!-- 绑定到package生命周期阶段上 --\x3e\n\t\t\t\t\t<phase>package</phase>\n\t\t\t\t\t\x3c!-- 指定插件的执行目标 --\x3e\n\t\t\t\t\t<goals>\n\t\t\t\t\t\t\x3c!-- 在package生命周期时，执行本插件中的shade目标 --\x3e\n\t\t\t\t\t\t<goal>shade</goal>\n\t\t\t\t\t</goals>\n\t\t\t\t\t\x3c!-- 插件任务配置 --\x3e\n\t\t\t\t\t<configuration>\n\t\t\t\t\t\t<finalName>benchmarks</finalName>\n\t\t\t\t\t\t<transformers>\n\t\t\t\t\t\t\t<transformer implementation="org.apache.maven.plugins.shade.resource.\n\t\t\t\t\t\t\t\tManifestResourceTransformer">\n\t\t\t\t\t\t\t\t<mainClass>org.openjdk.jmh.Main</mainClass>\n\t\t\t\t\t\t\t</transformer>\n\t\t\t\t\t\t</transformers>\n\t\t\t\t\t</configuration>\n\t\t\t\t</execution>\n\t\t\t</executions>\n\t\t</plugin>\n\t</plugins>\n</build>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n# 获取插件信息\n可以访问Maven官网插件主页获取插件的信息。',normalizedContent:'maven中的生命周期包含了项目的清理，初始化，编译，测试，打包，集成测试，验证，部署和站点生成等几乎所有的构建步骤。不过maven的生命周期是抽象的，这意味着生命周期本身不做任何实际的工作，每个步骤都交给插件来完成。可以说生命周期定义了行为，而插件来实现这些行为。\n\n注意\n\n本文的内容大多总结自《maven实战》这本书。\n\n# 生命周期\n# 三套生命周期\nmaven定义了三套相互独立的生命周期，分别为clean，default和site。clean生命周期的目的是清理项目，default生命周期的目的是构建项目，而site生命周期的目的是建立项目站点。每个生命周期包含一些阶段，这些阶段是有顺序的，位于后面的阶段依赖于前面的阶段。\n\n这三套生命周期是相互独立的，调用其中一套，不会触发另外一套。\n\n# clean生命周期\nclean生命周期包括三个阶段：\n\n * pre-clean：执行一些清理前需要完成的工作。\n * clean：清理上一次构建生成的文件。\n * post-clean：执行一些清理后需要完成的工作。\n\n# default生命周期\ndefault生命周期是所有生命周期中最核心的部分，定义了真正构建时需要执行的所有步骤。\n\n * validate\n * initialize\n * generate-sources\n * process-sources：处理项目主资源文件，对src/main/resources目录的内容进行变量替换等工作后，复制到项目输出的主classpath目录中。\n * generate-resources\n * process-resources\n * compile：编译项目的主源码，编译src/main/java目录下的java文件至项目输出的主classpath目录中。\n * process-classes\n * generate-test-sources\n * process-test-sources：处理项目测试资源文件，对src/test/resources目录的内容进行变量替换等工作后，复制到项目输出的测试classpath目录中。\n * generate-test-resources\n * process-test-resources\n * test-compile：编译项目的测试源码，编译src/test/java目录下的java文件至项目输出的测试classpath目录中。\n * process-test-classes\n * test：使用单元测试框架运行测试，测试代码不会被打包或部署。\n * prepare-package\n * package：接收编译好的代码，打包成可发布的格式，如jar。\n * pre-integration-test\n * integration-test\n * post-integration-test\n * verify\n * install：将包安装到maven本地仓库，供本地其他maven项目使用。\n * deploy：将最终的包复制到远程仓库，供其他开发人员和maven项目使用。\n\n可见整个生命周期包含了很多阶段，对于每一个阶段更详细的介绍可以参考官方文档。\n\n# site生命周期\nsite生命周期的目的是建立和发布项目站点，maven能够基于pom所包含的信息，自动生成一个友好的站点，方便团队交流和发布项目信息。主要包含下面几个阶段：\n\n * pre-site：执行一些在生成项目站点之前需要完成的工作。\n * site：生成项目站点文档。\n * post-site：执行一些在生成项目站点之后需要完成的工作。\n * site-deploy：将生成的项目站点发布到服务器上。\n\n# 命令行\n下面是一些与maven生命周期相关的命令：\n\n * mvn clean：该命令调用clean生命周期的clean阶段，实际执行的阶段为clean生命周期的pre-clean和clean阶段。\n * mvn test：该命令调用default生命周期的test阶段，该命令会执行default上面周期一开始直到test阶段的所有阶段。\n * mvn clean install：该命令调用clean生命周期的clean阶段和default阶段的install阶段，同样地，是从每种生命周期一开始的阶段直到对应的阶段。\n * mvn clean deploy site-deploy：该命令调用clean生命周期的clean阶段和default生命周期的deploy阶段以及site阶段的site-deploy阶段。同样地，是从每种生命周期一开始的阶段直到对应的阶段。\n\n# 插件\n# 插件目标\n一般每个插件都具有多种功能，而每种功能被称为插件的目标。比如maven-dependency-plugin:analyze对应了maven-dependency-plugin插件的analyze目标（analyze功能）。\n\n# 插件绑定\nmaven的生命周期和插件相互绑定，用以完成实际的构建任务。例如default生命周期中的compile这一阶段可以与maven-compiler-plugin这一插件的compile目标所绑定。maven默认已经内置了很多绑定了，另外也可以自定义插件绑定。当多个插件目标绑定到统一阶段的时候，这些插件声明的先后顺序决定了目标的执行顺序。\n\n# 插件配置\n下面是一个简单的自定义的插件绑定配置：\n\n<build>\n\t<plugins>\n\t\t<plugin>\n\t\t\t\x3c!-- 插件依赖 --\x3e\n\t\t\t<groupid>org.apache.maven.plugins</groupid>\n\t\t\t<artifactid>maven-shade-plugin</artifactid>\n\t\t\t\x3c!-- executions下的每一个execution对应一个任务 --\x3e\n\t\t\t<executions>\n\t\t\t\t<execution>\n\t\t\t\t\t\x3c!-- 绑定到package生命周期阶段上 --\x3e\n\t\t\t\t\t<phase>package</phase>\n\t\t\t\t\t\x3c!-- 指定插件的执行目标 --\x3e\n\t\t\t\t\t<goals>\n\t\t\t\t\t\t\x3c!-- 在package生命周期时，执行本插件中的shade目标 --\x3e\n\t\t\t\t\t\t<goal>shade</goal>\n\t\t\t\t\t</goals>\n\t\t\t\t\t\x3c!-- 插件任务配置 --\x3e\n\t\t\t\t\t<configuration>\n\t\t\t\t\t\t<finalname>benchmarks</finalname>\n\t\t\t\t\t\t<transformers>\n\t\t\t\t\t\t\t<transformer implementation="org.apache.maven.plugins.shade.resource.\n\t\t\t\t\t\t\t\tmanifestresourcetransformer">\n\t\t\t\t\t\t\t\t<mainclass>org.openjdk.jmh.main</mainclass>\n\t\t\t\t\t\t\t</transformer>\n\t\t\t\t\t\t</transformers>\n\t\t\t\t\t</configuration>\n\t\t\t\t</execution>\n\t\t\t</executions>\n\t\t</plugin>\n\t</plugins>\n</build>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n# 获取插件信息\n可以访问maven官网插件主页获取插件的信息。',charsets:{cjk:!0}},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-17f5e21f",path:"/archives/",lastUpdated:"2020-12-12",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-172dff02",path:"/categories/",lastUpdated:"2020-12-12",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-7a7efcc2",path:"/tags/",lastUpdated:"2020-12-12",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"Home",frontmatter:{home:!0,tagline:"Be a serendipper, and find your own serendipity!",bannerBg:"https://w.wallhaven.cc/full/vg/wallhaven-vgdj28.jpg"},regularPath:"/",relativePath:"index.md",key:"v-6a44bbb8",path:"/",lastUpdated:"2021-01-03",headersStr:null,content:"",normalizedContent:"",charsets:{}}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"分类",link:"/categories/",items:[]},{text:"标签",link:"/tags/",items:[]},{text:"归档",link:"/archives/",items:[]},{text:"收藏",items:[{text:"网站",link:"/collections/websites/"}]}],sidebarDepth:2,logo:"/img/HL-logo.png",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!1,editLinkText:"Edit",contentBgStyle:1,sidebar:{"/01.编程语言/":[{title:"Java",collapsable:!0,children:[{title:"基础",collapsable:!0,children:[["01.Java/01.基础/02.Java中String的存储.md","Java中String的存储","/pages/aaba75/"],["01.Java/01.基础/03.Java中的内部类.md","Java中的内部类","/pages/39d636/"],["01.Java/01.基础/04.Java中的代理.md","Java中的代理","/pages/6cec3e/"],["01.Java/01.基础/05.Java中的日志体系.md","Java中的日志体系概述","/pages/95a02e/"],["01.Java/01.基础/06.Java8新日期API.md","Java8新日期API","/pages/b725c0/"],["01.Java/01.基础/07.Java中的枚举.md","Java中的枚举","/pages/405394/"],["01.Java/01.基础/08.Java中的Lambda表达式及实现原理.md","Java中的Lambda表达式及原理","/pages/226a87/"],["01.Java/01.基础/21.Java中的方法句柄.md","Java中的方法句柄","/pages/6ff86f/"],["01.Java/01.基础/22.Java反射.md","Java中的反射","/pages/0a8d09/"],["01.Java/01.基础/100.Java中的强软弱虚引用.md","Java中的强软弱虚引用","/pages/72f0d2/"]]},{title:"集合",collapsable:!0,children:[["01.Java/02.集合/01.Java集合概述.md","Java集合概述","/pages/3bb6cb/"],["01.Java/02.集合/100.Java集合中的ConcurrentModificationException.md","Java集合中的ConcurrentModificationException","/pages/574b5f/"]]},{title:"线程与并发",collapsable:!0,children:[["01.Java/03.线程与并发/01.volatile关键字.md","Java中的volatile关键字","/pages/d1fc66/"],["01.Java/03.线程与并发/11.ThreadLocal.md","Java中的ThreadLocal","/pages/994e0e/"],["01.Java/03.线程与并发/12.Java中的LockSupport.md","Java中的LockSupport","/pages/140566/"],["01.Java/03.线程与并发/21.AtomicInteger.md","Java中的AtomicInteger","/pages/4d7f44/"]]},{title:"JVM",collapsable:!0,children:[{title:"执行子系统",collapsable:!0,children:[["01.Java/05.JVM/01.执行子系统/01.Java方法调用.md","Java方法调用","/pages/5825a9/"]]}]},{title:"JDBC",collapsable:!0,children:[["01.Java/06.JDBC/01.API概述.md","JDBC API概述","/pages/e71797/"]]}]},{title:"JavaScript",collapsable:!0,children:[{title:"变量",collapsable:!0,children:[["02.JavaScript/01.变量/01.变量.md","JavaScript中的变量与作用域","/pages/856738/"]]},{title:"数组",collapsable:!0,children:[["02.JavaScript/02.数组/01.数组.md","JavaScript中的数组","/pages/fb73c5/"]]},{title:"字符串",collapsable:!0,children:[["02.JavaScript/03.字符串/01.字符串.md","JavaScript中的字符串","/pages/62d559"]]}]}],catalogue:{},"/02.数据结构与算法/":[["01.二叉树的遍历.md","二叉树的遍历","/pages/73d51c/"],["02.从遍历结果中构建二叉树.md","从遍历结果中构建二叉树","/pages/cc0ee9/"],["03.二叉查找树.md","二叉查找树","/pages/3bb416/"],["04.判断一棵二叉树是否是平衡二叉树.md","判断一棵二叉树是否是平衡二叉树","/pages/eca41b/"],["05.将有序数组转化为平衡二叉查找树.md","将有序数组转化为平衡二叉查找树","/pages/3d68de/"],["06.将二叉查找树调整平衡.md","将二叉查找树调整平衡","/pages/cf9f2b/"],["07.AVL树.md","AVL树","/pages/927005/"],["08.全排列.md","全排列","/pages/e812d0/"],["09.子集生成.md","子集生成","/pages/a056bd/"]],"/03.计算机体系结构/":[{title:"缓存",collapsable:!0,children:[["01.缓存/01.CPU缓存的基础架构.md","CPU缓存的基础架构","/pages/4e8b73/"],["01.缓存/02.CPU缓存一致性协议概述.md","CPU缓存一致性协议概述","/pages/856225/"],["01.缓存/03.CPU缓存一致性协议之MSI.md","CPU缓存一致性协议之MSI","/pages/35e881/"],["01.缓存/04.CPU缓存一致性协议之MESI.md","CPU缓存一致性协议之MESI","/pages/5709ee/"],["01.缓存/05.CPU中的StoreBuffers.md","CPU中的Store Buffers","/pages/b770ae/"]]}],"/04.计算机网络与安全/":[{title:"数据链路层",collapsable:!0,children:[["02.数据链路层/01.数据链路层概述.md","数据链路层概述","/pages/1f274f/"]]},{title:"网络层",collapsable:!0,children:[["03.网络层/01.网络层概述.md","网络层概述","/pages/548a38/"]]},{title:"传输层",collapsable:!0,children:[["04.传输层/01.UDP概述.md","UDP概述","/pages/81b034/"]]}],"/102.收藏夹/":[["01.网站.md","网站","/collections/websites"],["02.书籍.md","书籍","/collections/books"]],"/22.后端框架/":[{title:"Spring全家桶",collapsable:!0,children:[{title:"Spring Framework",collapsable:!0,children:[{title:"AOP",collapsable:!0,children:[["01.Spring全家桶/01.Spring Framework/02.AOP/01.AOP基础.md","Spring AOP基础","/pages/0c4c2e/"]]},{title:"Web",collapsable:!0,children:[["01.Spring全家桶/01.Spring Framework/03.Web/01.注册DispatcherServlet.md","注册DispatcherServlet","/pages/f167d9/"],["01.Spring全家桶/01.Spring Framework/03.Web/02.Xml配置容器启动.md","web.xml配置Spring容器启动","/pages/668c92/"],["01.Spring全家桶/01.Spring Framework/03.Web/03.源码分析之HandlerMapping.md","SpringMVC源码分析之HandlerMapping","/pages/f2c795/"],["01.Spring全家桶/01.Spring Framework/03.Web/04.源码分析之HandlerAdapter.md","SpringMVC源码分析之HandlerAdapter","/pages/b2649d/"],["01.Spring全家桶/01.Spring Framework/03.Web/05.参数接收问题总结.md","SpringMVC参数接收问题总结","/pages/cd47ce/"]]}]},{title:"Spring Boot",collapsable:!0,children:[["01.Spring全家桶/02.Spring Boot/01.自动配置原理.md","SpringBoot自动配置原理","/pages/84c97b/"],["01.Spring全家桶/02.Spring Boot/21.SpringBoot跨域解决方案.md","SpringBoot跨域解决方案","/pages/f79e9e/"],["01.Spring全家桶/02.Spring Boot/22.SpringBoot中Filter的注册.md","SpringBoot中Filter的注册","/pages/e0358f/"]]}]}],"/99.开发工具/":[{title:"maven",collapsable:!0,children:[["01.maven/01.依赖管理.md","Maven依赖","/pages/65a539/"],["01.maven/02.生命周期和插件.md","Maven中的生命周期和插件","/pages/a4afbf/"]]}]},author:{name:"Harrison Lee",link:"https://github.com/HarrisonLee1998"},blogger:{avatar:"https://cdn.jsdelivr.net/gh/HarrisonLee1998/image/avatar.jpg",name:"Harrison Lee",slogan:"玻璃晴朗，橘子辉煌"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:lzipant@gmail.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/HarrisonLee1998"},{iconClass:"icon-erji",title:"听音乐",link:"https://music.163.com/#/playlist?id=755597173"}]},footer:{createYear:2020,copyrightInfo:'Harrison Lee | <a href="https://github.com/xugaoyi/vuepress-theme-vdoing/blob/master/LICENSE" target="_blank">MIT License</a>'}}},ol=(t(170),t(219)),il=t(220),sl=t(54);var ll={computed:{$filterPosts:function(){return this.$site.pages.filter((function(n){var e=n.frontmatter,t=e.pageComponent,r=e.article,a=e.home;return!(t||!1===r||!0===a)}))},$sortPosts:function(){return(n=this.$filterPosts).sort((function(n,e){var t=n.frontmatter.sticky,r=e.frontmatter.sticky;return t&&r?t==r?Object(sl.a)(n,e):t-r:t&&!r?-1:!t&&r?1:Object(sl.a)(n,e)})),n;var n},$sortPostsByDate:function(){return(n=this.$filterPosts).sort((function(n,e){return Object(sl.a)(n,e)})),n;var n},$groupPosts:function(){return function(n){for(var e={},t={},r=function(r,a){var o=n[r].frontmatter,i=o.categories,s=o.tags;"array"===Object(sl.n)(i)&&i.forEach((function(t){t&&(e[t]||(e[t]=[]),e[t].push(n[r]))})),"array"===Object(sl.n)(s)&&s.forEach((function(e){e&&(t[e]||(t[e]=[]),t[e].push(n[r]))}))},a=0,o=n.length;a<o;a++)r(a);return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags:function(){return function(n){var e=[],t=[];for(var r in n.categories)e.push({key:r,length:n.categories[r].length});for(var a in n.tags)t.push({key:a,length:n.tags[a].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Pa.component(ol.default),Pa.component(il.default);function cl(n){return n.toString().padStart(2,"0")}t(367);Pa.component("Badge",(function(){return Promise.all([t.e(0),t.e(4)]).then(t.bind(null,578))})),Pa.component("CodeBlock",(function(){return Promise.resolve().then(t.bind(null,219))})),Pa.component("CodeGroup",(function(){return Promise.resolve().then(t.bind(null,220))}));t(368);var dl={name:"Eqn"},pl=Object(el.a)(dl,(function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"vuepress-eqn"},[this._t("default")],2)}),[],!1,null,null,null).exports,ul={name:"Eq"},hl=Object(el.a)(ul,(function(){var n=this.$createElement;return(this._self._c||n)("span",{staticClass:"vuepress-eq"},[this._t("default")],2)}),[],!1,null,null,null).exports,ml=t(152),fl={props:{color:{required:!1,default:"rgb(66, 185, 131)"}}},gl=(t(369),Object(el.a)(fl,(function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"spinner",style:{background:this.color}})}),[],!1,null,"1bbcb91a",null).exports),vl={name:"Mermaid",props:{id:{type:String,required:!0},graph:{type:String,required:!0}},data:function(){return{svg:void 0}},render:function(n){return void 0===this.svg?n("Loading"):n("div",{domProps:{innerHTML:this.svg,style:"width: 100%"}})},mounted:function(){var n=this;t.e(3).then(t.t.bind(null,520,7)).then((function(e){e.initialize(Object(ml.a)({startOnLoad:!0},{}));var t=document.createElement("div");document.body.appendChild(t),e.render(n.id,n.graph,(function(e){n.svg=e,document.body.removeChild(t)}),t)}))},components:{Loading:gl}},bl=[function(n){n.Vue,n.options,n.router,n.siteData},function(n){var e=n.Vue,t=(n.options,n.router,n.siteData);t.pages.map((function(n){var e=n.frontmatter,r=e.date,a=e.author;"string"==typeof r&&"Z"===r.charAt(r.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return"".concat(n.getUTCFullYear(),"-").concat(cl(n.getUTCMonth()+1),"-").concat(cl(n.getUTCDate())," ").concat(cl(n.getUTCHours()),":").concat(cl(n.getUTCMinutes()),":").concat(cl(n.getUTCSeconds()))}(r)),a?n.author=a:t.themeConfig.author&&(n.author=t.themeConfig.author)})),e.mixin(ll)},{},function(n){n.Vue.mixin({computed:{$dataBlock:function(){return this.$options.__data__block__}}})},{},{},function(){"undefined"!=typeof window&&function(n,e,t){function r(n){var t=e.createElement("div");t.className="heart",a.push({el:t,x:n.clientX-5,y:n.clientY-5,scale:1,alpha:1,color:"rgb(36,62,103)"}),e.body.appendChild(t)}var a=[];n.requestAnimationFrame=n.requestAnimationFrame||n.webkitRequestAnimationFrame||n.mozRequestAnimationFrame||n.oRequestAnimationFrame||n.msRequestAnimationFrame||function(n){setTimeout(n,1e3/60)},function(n){var t=e.createElement("style");t.type="text/css";try{t.appendChild(e.createTextNode(n))}catch(e){t.styleSheet.cssText=n}e.getElementsByTagName("head")[0].appendChild(t)}(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),function(){var e="function"==typeof n.onclick&&n.onclick;n.onclick=function(n){var t=!0;n.path&&n.path.forEach((function(n){1===n.nodeType&&"string"==typeof n.className&&n.className.indexOf("theme-vdoing-content")>-1&&(t=!1)})),t&&(e&&e(),r(n))}}(),function n(){for(var t=0;t<a.length;t++)a[t].alpha<=0?(e.body.removeChild(a[t].el),a.splice(t,1)):(a[t].y--,a[t].scale+=.004,a[t].alpha-=.013,a[t].el.style.cssText="left:"+a[t].x+"px;top:"+a[t].y+"px;opacity:"+a[t].alpha+";transform:scale("+a[t].scale+","+a[t].scale+") rotate(45deg);background:"+a[t].color+";z-index:99999");requestAnimationFrame(n)}()}(window,document)},function(n){n.router;"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},function(n){var e=n.router;"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?4654fe8c3575d99de689fbc351d2b250";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),e.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},function(n){var e,t,r,a,o,i,s=n.router;"undefined"!=typeof window&&(e=window,t=document,r="script",a="ga",e.GoogleAnalyticsObject=a,e.ga=e.ga||function(){(e.ga.q=e.ga.q||[]).push(arguments)},e.ga.l=1*new Date,o=t.createElement(r),i=t.getElementsByTagName(r)[0],o.async=1,o.src="https://www.google-analytics.com/analytics.js",i.parentNode.insertBefore(o,i),ga("create","UA-179712178-1","auto"),ga("set","anonymizeIp",!0),s.afterEach((function(n){ga("set","page",s.app.$withBase(n.fullPath)),ga("send","pageview")})))},function(n){var e=n.Vue;e.component("Eqn",pl),e.component("Eq",hl)},function(n){n.Vue.component("Mermaid",vl)}],yl=[];t(116);function xl(n,e){return(xl=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}t(216);function wl(n){return(wl=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}var El=t(11),Al=t.n(El);function Sl(n,e){return!e||"object"!==Al()(e)&&"function"!=typeof e?function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n):e}function Ml(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,r=wl(n);if(e){var a=wl(this).constructor;t=Reflect.construct(r,arguments,a)}else t=r.apply(this,arguments);return Sl(this,t)}}var Cl=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),e&&xl(n,e)}(t,n);var e=Ml(t);function t(){return os(this,t),e.apply(this,arguments)}return t}(function(){function n(){os(this,n),this.store=new Pa({data:{state:{}}})}return ss(n,[{key:"$get",value:function(n){return this.store.state[n]}},{key:"$set",value:function(n,e){Pa.set(this.store.state,n,e)}},{key:"$emit",value:function(){var n;(n=this.store).$emit.apply(n,arguments)}},{key:"$on",value:function(){var n;(n=this.store).$on.apply(n,arguments)}}]),n}());Object.assign(Cl.prototype,{getPageAsyncComponent:Ni,getLayoutAsyncComponent:Ui,getAsyncComponent:Ji,getVueComponent:$i});var kl={install:function(n){var e=new Cl;n.$vuepress=e,n.prototype.$vuepress=e}};function Tl(n){n.beforeEach((function(e,t,r){if(jl(n,e.path))r();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){var a=e.path.replace(/\/$/,"")+".html";jl(n,a)?r(a):r()}else r();else{var o=e.path+"/",i=e.path+".html";jl(n,i)?r(i):jl(n,o)?r(o):r()}}))}function jl(n,e){return n.options.routes.filter((function(n){return n.path.toLowerCase()===e.toLowerCase()})).length>0}var Il={props:{pageKey:String,slotKey:{type:String,default:"default"}},render:function(n){var e=this.pageKey||this.$parent.$page.key;return Wi("pageKey",e),Pa.component(e)||Pa.component(e,Ni(e)),Pa.component(e)?n(e):n("")}},Bl={functional:!0,props:{slotKey:String,required:!0},render:function(n,e){var t=e.props,r=e.slots;return n("div",{class:["content__".concat(t.slotKey)]},r()[t.slotKey])}},_l=(t(370),Object(el.a)({},(function(n,e){var t=e._c;return t("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[t("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),e._v(" "),t("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})])}),[],!0,null,null,null).exports);function Ll(){return(Ll=Object(r.a)(regeneratorRuntime.mark((function n(e){var t,r,a,o;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return t="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:al.routerBase||al.base,Tl(r=new Mi({base:t,mode:"history",fallback:!1,routes:rl,scrollBehavior:function(n,e,t){return t||(n.hash?!Pa.$vuepress.$get("disableScrollBehavior")&&{selector:n.hash}:{x:0,y:0})}})),a={},n.prev=4,n.next=7,Promise.all(bl.filter((function(n){return"function"==typeof n})).map((function(n){return n({Vue:Pa,options:a,router:r,siteData:al,isServer:e})})));case 7:n.next=12;break;case 9:n.prev=9,n.t0=n.catch(4),console.error(n.t0);case 12:return o=new Pa(Object.assign(a,{router:r,render:function(n){return n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},yl.map((function(e){return n(e)})))])}})),n.abrupt("return",{app:o,router:r});case 14:case"end":return n.stop()}}),n,null,[[4,9]])})))).apply(this,arguments)}Pa.config.productionTip=!1,Pa.use(Mi),Pa.use(kl),Pa.mixin(function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Pa;Ci(e),t.$vuepress.$set("siteData",e);var r=n(t.$vuepress.$get("siteData")),a=new r,o=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),i={};return Object.keys(o).reduce((function(n,e){return e.startsWith("$")&&(n[e]=o[e].get),n}),i),{computed:i}}((function(n){return function(){function e(){os(this,e)}return ss(e,[{key:"setPage",value:function(n){this.__page=n}},{key:"$site",get:function(){return n}},{key:"$themeConfig",get:function(){return this.$site.themeConfig}},{key:"$frontmatter",get:function(){return this.$page.frontmatter}},{key:"$localeConfig",get:function(){var n,e,t=this.$site.locales,r=void 0===t?{}:t;for(var a in r)"/"===a?e=r[a]:0===this.$page.path.indexOf(a)&&(n=r[a]);return n||e||{}}},{key:"$siteTitle",get:function(){return this.$localeConfig.title||this.$site.title||""}},{key:"$title",get:function(){var n=this.$page,e=this.$page.frontmatter.metaTitle;if("string"==typeof e)return e;var t=this.$siteTitle,r=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?r?r+" | "+t:t:r||"VuePress"}},{key:"$description",get:function(){var n=function(n){if(n){var e=n.filter((function(n){return"description"===n.name}))[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}},{key:"$lang",get:function(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}},{key:"$localePath",get:function(){return this.$localeConfig.path||"/"}},{key:"$themeLocaleConfig",get:function(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}},{key:"$page",get:function(){return this.__page?this.__page:function(n,e){for(var t=0;t<n.length;t++){var r=n[t];if(r.path.toLowerCase()===e.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}}]),e}()}),al)),Pa.component("Content",Il),Pa.component("ContentSlotsDistributor",Bl),Pa.component("OutboundLink",_l),Pa.component("ClientOnly",{functional:!0,render:function(n,e){var t=e.parent,r=e.children;if(t._isMounted)return r;t.$once("hook:mounted",(function(){t.$forceUpdate()}))}}),Pa.component("Layout",Ui("Layout")),Pa.component("NotFound",Ui("NotFound")),Pa.prototype.$withBase=function(n){var e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.5.2",hash:"e7f67bc"},function(n){return Ll.apply(this,arguments)}(!1).then((function(n){var e=n.app;n.router.onReady((function(){e.$mount("#app")}))}))}]);