(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{557:function(s,t,a){"use strict";a.r(t);var e=a(16),n=Object(e.a)({},(function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("p",[s._v("在之前的那篇关于MESI的"),a("a",{attrs:{href:"https://harrisonlee.net/pages/5709ee/",target:"_blank",rel:"noopener noreferrer"}},[s._v("博客"),a("OutboundLink")],1),s._v('中，我们讲到了MESI协议在MSI协议的基础上新加入了一个状态E，能够提高维护缓存一致性的效率。但是硬件工程师们发现在MESI协议中，比如某个CPU要修改一个当前缓存中不存在的变量，那么需要发出"read invalidate"消息，待收到其他CPU的确认消息后才能进行修改操作。这显然是不必要的等待，所以为了解决这个问题，又引入了Store Buffers。')]),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[s._v("提示")]),s._v(" "),a("p",[s._v("本文翻译自"),a("a",{attrs:{href:"https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.170.3279&rep=rep1&type=pdf",target:"_blank",rel:"noopener noreferrer"}},[s._v("Memory Barriers: a Hardware View for Software Hackers"),a("OutboundLink")],1),s._v("一文的部分章节，同时相对原文有删改。")])]),s._v(" "),a("h2",{attrs:{id:"store-buffers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#store-buffers"}},[s._v("#")]),s._v(" Store Buffers")]),s._v(" "),a("p",[s._v("引入Store Buffers后，CPU中的结构大体如下图所示：")]),s._v(" "),a("p",[a("img",{attrs:{src:"https://cdn.harrisonlee.net/image-20210119173238021.png",alt:"image-20210119173238021"}})]),s._v(" "),a("p",[s._v("但是引入Store Buffers后，会导致破坏全局内存顺序，下面以一个例子来说明问题。")]),s._v(" "),a("p",[s._v("对于下来代码：")]),s._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    a "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    b "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("bar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("while")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("b "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("continue")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("assert")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("a "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br")])]),a("p",[s._v("假设CPU 0执行"),a("code",[s._v("foo()")]),s._v("，CPU 1执行"),a("code",[s._v("bar()")]),s._v("，而且一开始变量a只存在CPU 1的缓存中，变量b只存在于CPU 0的缓存中。整个执行流程可能如下所述：")]),s._v(" "),a("ol",[a("li",[s._v("CPU 0 执行"),a("code",[s._v("a = 1;")]),s._v("，变量a所在的缓存行并不在CPU 0的缓存中，所以CPU 0将赋予变量a的值放入Store Buffers中，并发出“read invalidate”消息。")]),s._v(" "),a("li",[s._v("CPU 1执行"),a("code",[s._v("while(b == 0) continue;")]),s._v("，但是变量b所在的缓存行并不在CPU 1中的缓存中，所以CPU 1发出“read”消息。")]),s._v(" "),a("li",[s._v("CPU 0执行"),a("code",[s._v("b = 1;")]),s._v("，它已经拥有包含变量b的缓存行了（M或E状态），所以直接将变量b的新值写入缓存行中。")]),s._v(" "),a("li",[s._v("CPU 0接收到“read”消息后（第2步CPU 1发出的），CPU 0响应该消息，并把变量b所在缓存行的状态改为S。")]),s._v(" "),a("li",[s._v("CPU 1接收到包含b的缓存行，并放入自己的缓存中。")]),s._v(" "),a("li",[s._v("CPU 1现在可以结束执行"),a("code",[s._v("while(b == 0) continue;")]),s._v("，因为它发现变量b的值为1了，不满足循环条件。")]),s._v(" "),a("li",[s._v("CPU 1执行"),a("code",[s._v("assert(a == 1)")]),s._v("，因为CPU 1保存有变量a所在的缓存行，但是变量a的值是脏数据，所以断言失败。")]),s._v(" "),a("li",[s._v("CPU 1接收到“read invalidate”消息（第1步CPU 0发出的），并且把包含变量a的值传给CPU 0，并且CPU 1将自己缓存中的该缓存行标记为无效（I）。"),a("strong",[s._v("但是这太迟了")]),s._v("。")]),s._v(" "),a("li",[s._v("CPU 0接收到包含变量a的缓存行，并放置在自己的缓存中，并把Store Buffers中a的值写入缓存行中。")])]),s._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[s._v("提示")]),s._v(" "),a("p",[s._v("上面9步流程及其相对顺序符合原文，但是个人认为把第1步和第2步调换了顺序更好理解一些。即CPU 1先发出“read”消息，而CPU 0后发出“read invalidate”消息，即CPU 1先获得总线使用权。")])]),s._v(" "),a("p",[s._v("可以看出，整个执行流程就像是把"),a("code",[s._v("foo()")]),s._v("中两条语句调换了顺序一样。如果按照原顺序执行的话，是不可能导致断言失败的，因为"),a("code",[s._v("a = 1;")]),s._v("早于"),a("code",[s._v("b = 1;")]),s._v("执行，那么"),a("code",[s._v("while(b == 0) continue;")]),s._v("结束时，变量a的值已经是1了。"),a("font",{attrs:{color:"deeppink"}},[s._v("这算是由于引入Store Buffers而导致的指令重排序问题，而这种重排序会导致可见性问题。")])],1),s._v(" "),a("h2",{attrs:{id:"内存屏障"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#内存屏障"}},[s._v("#")]),s._v(" 内存屏障")]),s._v(" "),a("p",[s._v("对于上述问题，硬件工程师们无法提出自动维护一致性的解决方案，因为CPU无法知道哪些变量之间存在关联关系，更不必说是如何关联的。因此硬件工程师引入了"),a("strong",[s._v("内存屏障")]),s._v("，软件工程师可以用内存屏障指令告诉CPU这种关联关系。")]),s._v(" "),a("p",[s._v("仍然对于上述代码，只需要做如下修改，即可解决问题。")]),s._v(" "),a("div",{staticClass:"language-c line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-c"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("foo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    a "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("smp_mb")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    b "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("=")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("bar")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("while")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("b "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("continue")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("assert")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("a "),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("==")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[s._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br")])]),a("p",[s._v("内存屏障"),a("code",[s._v("smp_mb();")]),s._v("会导致CPU在之后的存储操作之前必须刷新它的Store Buffers。CPU要么暂停直到Store Buffers被清空，要么把后序的存储操作涉及的数据也存储到Store Buffers中，直到先存入Store Buffers的项被处理。")]),s._v(" "),a("p",[s._v("对于后一种方法，可能的执行序列如下所述：")]),s._v(" "),a("ol",[a("li",[s._v("CPU 0执行"),a("code",[s._v("a = 1;")]),s._v("，包含变量a的缓存行不在CPU 0的缓存行中，因此CPU 0将变量a的新值放入Store Buffers中，并发出“read invalidate”消息。")]),s._v(" "),a("li",[s._v("CPU 1执行"),a("code",[s._v("while(b == 0) continue;")]),s._v("，但是包含变量b的缓存行不在CPU 1的缓存中，所以发出“read”消息。")]),s._v(" "),a("li",[s._v("CPU 0执行"),a("code",[s._v("smp_mb();")]),s._v("，"),a("strong",[s._v("并标记当前Store Buffers中所有的项")]),s._v("。")]),s._v(" "),a("li",[s._v("CPU 0执行"),a("code",[s._v("b = 1;")]),s._v("，CPU 0已经拥有包含变量b的缓存行了（M或E状态），但是在Store Buffers中有标记项，因此并不会直接把变量b的新值写入到缓存行中，而是将它放入Store Buffers中（"),a("strong",[s._v("但是不标记")]),s._v("）。")]),s._v(" "),a("li",[s._v("CPU 0接收到“read”消息后（上面第2步CPU 1发出的），CPU 0将包含b的缓存行（包含旧值）传给CPU 1，并将缓存行状态设置为S。")]),s._v(" "),a("li",[s._v("CPU 1接收到关于b的缓存行并放置在自己的缓存中。")]),s._v(" "),a("li",[s._v("CPU 1现在可以加载变量b了，但是它发现变量b的值仍然是0（CPU 0传过来的旧值），所以继续循环。"),a("strong",[s._v("因为变量b的新值还放在Store Buffers中的")]),s._v("。")]),s._v(" "),a("li",[s._v("CPU 1接收到“read invalidate”消息（上面第1步）后，将包含变量a的缓存行传给CPU 0并将其设置为无效态（I）。")]),s._v(" "),a("li",[s._v("CPU 0接收到包含变量a的缓存行后，并将Store Buffers中变量a的新值写入该缓存行。")]),s._v(" "),a("li",[s._v("因为Store Buffers中的变量被标记了（上面第3步），由于当前例子中变量a是Store Buffers是唯一被标记的项，所以CPU 0也可以选择把变量b的新值写入缓存行中。")]),s._v(" "),a("li",[s._v("因为目前变量b所在缓存行的状态为S，所以CPU 0发出“invalidate”消息给CPU 1（因为上面第10步）。")]),s._v(" "),a("li",[s._v("CPU 1接收到“invalidate”消息后，将包含变量b的缓存行失效，并向CPU 0发送确认消息。")]),s._v(" "),a("li",[s._v("CPU 1执行"),a("code",[s._v("while(b == 0) continue;")]),s._v("，但是包含变量b的缓存行不在其缓存内，所以发出“read”信息。")]),s._v(" "),a("li",[s._v("CPU 0接收到确认消息后（上面第12步），将包含变量b的缓存行的状态设置为E，CPU 0将变量b的新值写入缓存行中。")]),s._v(" "),a("li",[s._v("CPU 0接收到“read”消息，将包含变量b的缓存行传给CPU 1，并将其状态设置为S。")]),s._v(" "),a("li",[s._v("CPU 1接收到包含变量b的缓存行并放置在缓存中。")]),s._v(" "),a("li",[s._v("CPU 1现在加载变量b的值，发现b的值为1，所以退出while循环。")]),s._v(" "),a("li",[s._v("CPU 1执行"),a("code",[s._v("assert(a == 1);")]),s._v("，但是包含变量a的缓存行不在缓存中（因为上面第8步），所以从CPU 0中请求数据，此时将会得到变量a的最新值，并且断言成功。")])]),s._v(" "),a("p",[s._v("正如你所看见的，整个步骤比之前多了很多。仔细回顾上面的过程，就可以发现是通过将变量b的值也写入Store Buffers中而不是直接写回到缓存行中而避免了类似指令的重排序的。")]),s._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[s._v("#")]),s._v(" 总结")]),s._v(" "),a("p",[s._v("为了提高MESI协议的效率，所以引入了Store Buffers，但是这会导致类似指令重排序的效果，为了解决这个带来的新问题，所以又引入内存屏障。关于内存屏障，后面写文再详细分析。")])])}),[],!1,null,null,null);t.default=n.exports}}]);