(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{539:function(a,s,t){"use strict";t.r(s);var n=t(16),e=Object(n.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("p",[a._v("Java方法调用不仅指方法的代码被执行，方法调用阶段唯一的任务就是确定被调用的方法版本。有些方法在编译时就能确定所调用的版本，而有些则需要等到运行时才能确定。因为在Java中，方法可能是私有的，也有可能是static或final的，另外有些方法还可以被重载和重写（听起来可能很混乱）。本文参考《深入理解Java虚拟机（第三版）》总结一下关于方法解析和分配与方法调用相关的指令。")]),a._v(" "),t("p",[a._v("Java编译器会将方法调用编译为下面5中方法调用指令：")]),a._v(" "),t("ul",[t("li",[t("p",[t("code",[a._v("invokestatic")]),a._v("：调用static方法。")]),a._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[a._v("提示")]),a._v(" "),t("p",[a._v("对于<cinit>方法没有使用"),t("code",[a._v("invokestatic")]),a._v("指令进行调用，本文所参考的书上也没有讲为什么。")])])]),a._v(" "),t("li",[t("p",[t("code",[a._v("invokespecial")]),a._v("：调用<init>()方法，私有方法和父类中的方法。")])]),a._v(" "),t("li",[t("p",[t("code",[a._v("invokevirtual")]),a._v("：调用所有的虚方法。")])]),a._v(" "),t("li",[t("p",[t("code",[a._v("invokeinterface")]),a._v("：调用接口中的方法。")])]),a._v(" "),t("li",[t("p",[t("code",[a._v("invokedynamic")]),a._v("：与支持动态类型语言有关，请见下文。")])])]),a._v(" "),t("h2",{attrs:{id:"解析（resolution）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#解析（resolution）"}},[a._v("#")]),a._v(" 解析（Resolution）")]),a._v(" "),t("p",[a._v("方法解析是一个静态的过程，在编译期间就完全确定了，在类加载的阶段就会把涉及到的符号引用全部转换为直接引用。")]),a._v(" "),t("p",[a._v("所有的静态方法，私有方法，实例构造器，父类方法以及被"),t("code",[a._v("final")]),a._v("修饰的方法，都是在编译时就确定好了方法的直接引用。前4种是通过"),t("code",[a._v("invokestatic")]),a._v("或"),t("code",[a._v("invokespecial")]),a._v("来执行的，而"),t("code",[a._v("final")]),a._v("方法是通过"),t("code",[a._v("invokevirtual")]),a._v("指令调用的（由于历史设计原因）。这些能够在编译时阶段进行解析的方法称为非虚方法（共5种），而其他方法则被称为虚方法。")]),a._v(" "),t("h2",{attrs:{id:"分派（dispatch）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#分派（dispatch）"}},[a._v("#")]),a._v(" 分派（Dispatch）")]),a._v(" "),t("p",[a._v("上面说到方法解析是一个静态的过程，而分派既可能是静态的，也有可能是动态的。另外根据的宗量，可以分为单分派和多分派。理论上可以有四种组合，不过在Java中，"),t("strong",[a._v("目前")]),a._v("Java属于静态多分派和动态单分派的语言（之所以强调目前，是因为不确定未来Java会不会做出改变，如C#在4.0前后的变化）。")]),a._v(" "),t("h3",{attrs:{id:"静态分派"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#静态分派"}},[a._v("#")]),a._v(" 静态分派")]),a._v(" "),t("p",[a._v("首先看一段代码（引用自原书）：")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("StaticDispatch")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("abstract")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Human")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Man")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("extends")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Human")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Woman")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("extends")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Human")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br")])]),t("p",[a._v("根据上面的类声明，对于下面的定义：")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Human")]),a._v(" man "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Man")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br")])]),t("p",[t("code",[a._v("Human")]),a._v("属于静态类型（或外观类型），而"),t("code",[a._v("Man")]),a._v("属于运行时类型（或实际类型）。关于原书（第三版）P305页第2段有一句话确实不好理解（原书作者写的时候也想到了，还好有例子​），所以下面记录一下原书作者举的例子：")]),a._v(" "),t("div",{staticClass:"language-java line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-java"}},[t("code",[t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 运行时类型的变化")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Human")]),a._v(" human "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Random")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("nextBoolean")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Man")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Woman")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 静态类型变化")]),a._v("\nsr"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("sayHello")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Man")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("human"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\nsr"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("sayHello")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Woman")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("human"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br")])]),t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[a._v("注意")]),a._v(" "),t("p",[a._v("关于静态类型变化这里，当然有一条语句会抛出"),t("code",[a._v("ClassCastException")]),a._v("，这里作者重点是说明静态类型可以这样变化，而不是说实际中代码可以这样写。")])]),a._v(" "),t("p",[a._v("可见，对于变量human，其运行时类型和静态类型都是可以变化的。但是运行时类型的变化只有在运行时才可知；而对于静态类型，在编译时就是可知的，如上面代码第2行静态类型为"),t("code",[a._v("Human")]),a._v("，第5行静态类型为"),t("code",[a._v("Man")]),a._v("，第6行静态类型为"),t("code",[a._v("Woman")]),a._v("。")]),a._v(" "),t("p",[t("font",{attrs:{color:"deeppink"}},[a._v("所有依赖静态类型来决定方法执行版本的分派动作，都称为静态分派")]),a._v("。"),t("strong",[a._v("静态分派最典型的应用就是方法重载（Overload）")]),a._v("，静态分派的动作发生在编译阶段，所以说静态分派是由编译器而不是虚拟机来进行的，和上面讲到的方法解析有些类似，所以有一些资料将静态分派归为解析而不是分派。")],1),a._v(" "),t("p",[a._v("另外，有些时候编译器能够确定出方法的重载版本，但在很多情况下这个重载版本不是唯一的，只能确定一个相对更合适的版本。原书第3版P306页举了一个例子，在重载匹配过程中，参数可能经过一系列的转换。对于基本类型可能按照数据范围小的类型逐渐转为数据范围大的类型，对于引用类型，可能按照类继承体系从下往上转。")]),a._v(" "),t("h3",{attrs:{id:"动态分派"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态分派"}},[a._v("#")]),a._v(" 动态分派")]),a._v(" "),t("p",[a._v("动态分派与Java里面的重写有很大的关联，之所以有动态分派是因为存在重写（Override）这个特性，而正是有因为有了动态分派，重写才得以被支持。")]),a._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"custom-block-title"},[a._v("提示")]),a._v(" "),t("p",[a._v("重写肯定是多态性的体现，而重载算不算多态，目前有一些争议。")])]),a._v(" "),t("p",[a._v("重写方法的执行与"),t("code",[a._v("invokevirtual")]),a._v("指令有关，该指令的运行时处理流程大致分为以下几步：")]),a._v(" "),t("ul",[t("li",[a._v("找到操作数栈顶的第一个元素所指向的对象的"),t("strong",[a._v("实际类型")]),a._v("，记作C。")]),a._v(" "),t("li",[a._v("如果在类型C中存在与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回"),t("code",[a._v("java.lang.IllegalError")]),a._v("异常。")]),a._v(" "),t("li",[a._v("如果不存在相符的方法，则按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。")]),a._v(" "),t("li",[a._v("如果始终没有找到合适的方法，则抛出"),t("code",[a._v("java.lang.AbstractMethodError")]),a._v("异常。")])]),a._v(" "),t("p",[a._v("所以"),t("font",{attrs:{color:"deeppink"}},[a._v("方法重写的本质是：invokevirtual指令并不是把常量池中方法的符号引用解析到直接引用上就结束了，还会根据方法接收者的实际类型来选择方法的版本")]),a._v("。"),t("strong",[a._v("这种运行期根据实际类型确定方法执行版本的分派过程称为动态分派")]),a._v("。重写方法属于一种虚方法，"),t("strong",[a._v("字段永远不可能是虚的，所以字段不会参与多态")]),a._v("。")],1),a._v(" "),t("p",[a._v("另外，如原书第三版P311举的例子，如果子类重写了父类构造方法里面所调用的方法，那么在实例化子类时，该子类重写的方法会被调用。很多时候我们对“receiver.OverloadMethod”这种模式很熟悉而忽略了构造器调用重写方法的这种情况。")]),a._v(" "),t("h3",{attrs:{id:"单分派与多分派"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#单分派与多分派"}},[a._v("#")]),a._v(" 单分派与多分派")]),a._v(" "),t("p",[a._v("有时候重载和重写会同时出现，关于这部分，原书中举了例子（第三版P312），但是个人没有很好理解。后来在知乎问答中找到一个"),t("a",{attrs:{href:"https://www.zhihu.com/question/28462483",target:"_blank",rel:"noopener noreferrer"}},[a._v("例子"),t("OutboundLink")],1),a._v("感觉比较好，可以参考“ze ran”用户的回答。")]),a._v(" "),t("div",{staticClass:"custom-block danger"},[t("p",{staticClass:"custom-block-title"},[a._v("警告")]),a._v(" "),t("p",[a._v("这部分纯属个人理解，未经证实。")]),a._v(" "),t("p",[a._v("重载属于静态分派，重写属于动态分派；静态分派在编译时根据静态类型匹配方法，而在运行时根据调用者的运行时类型进行方法匹配。所以对于那两个例子而言，首先确定重载版本，然后再根据变量的运行时类型来确定重写版本。")])]),a._v(" "),t("h3",{attrs:{id:"接口中的方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#接口中的方法"}},[a._v("#")]),a._v(" 接口中的方法")]),a._v(" "),t("p",[a._v("在Java 8以前，往接口中添加方法是一件痛苦的事情，因为往接口中添加了方法就要给所有的实现类添加方法。Java 8开始，可以往类中添加静态方法和默认方法。")]),a._v(" "),t("p",[a._v("之所以在接口中提供静态方法是为了避免定义一些相关的工具类，如"),t("code",[a._v("Collectons")]),a._v("，"),t("code",[a._v("Collectors")]),a._v("等。这样提高了内聚性。")]),a._v(" "),t("p",[a._v("子类不必实现父接口的默认方法，所以往接口中添加默认方法是安全的。但有时候多个父接口以及父类的方法可能会导致冲突，Java中的规则如下：")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("类中的方法优先级最高，父类声明的方法优先级高于任何声明为默认方法的优先级。")])]),a._v(" "),t("li",[t("p",[a._v("多个父接口中出现冲突，那么选择最具体（more-specific）的那个接口中的方法（有点就近原则的意思）。")])]),a._v(" "),t("li",[t("p",[a._v("如果上面两条规则都无法判断，那么继承了多个接口的类必须通过显式覆盖所要调用的方法，因为是从继承链的底层往最上层查找。")])])]),a._v(" "),t("p",[a._v("对于接口中的静态方法，还是通过"),t("code",[a._v("invokestatic")]),a._v("指令进行调用的，因为在编译时能唯一确定，不属于虚方法。")]),a._v(" "),t("p",[a._v("当对象的静态类型为接口时，调用方法是通过"),t("code",[a._v("invokeinterface")]),a._v("指令来进行的。")]),a._v(" "),t("h3",{attrs:{id:"动态类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#动态类型"}},[a._v("#")]),a._v(" 动态类型")]),a._v(" "),t("p",[a._v("每一处含有"),t("code",[a._v("invokedynamic")]),a._v("指令的位置都被称作“动态调用点”，这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是CONSTANT_Dynamic_info类型的，这种类型的常量中包含了一个引导方法在引导方法表中的下标，引导方法表（BootstrapMethods属性）位于类文件的属性表中。这些引导方法返回值是"),t("code",[a._v("java.lang.invoke.CallSite")]),a._v("类型的对象，该对象代表了真正要执行的目标方法。")]),a._v(" "),t("h2",{attrs:{id:"参考"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[a._v("#")]),a._v(" 参考")]),a._v(" "),t("ul",[t("li",[t("p",[t("a",{attrs:{href:"https://github.com/fenixsoft/jvm_book",target:"_blank",rel:"noopener noreferrer"}},[a._v("《深入理解Java虚拟机 （第三版）》周志明 著"),t("OutboundLink")],1)])]),a._v(" "),t("li",[t("p",[t("a",{attrs:{href:"https://www.zhihu.com/question/28462483",target:"_blank",rel:"noopener noreferrer"}},[a._v("知乎问答"),t("OutboundLink")],1)])])])])}),[],!1,null,null,null);s.default=e.exports}}]);