(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{555:function(t,_,v){"use strict";v.r(_);var a=v(16),r=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("p",[t._v("在"),v("a",{attrs:{href:"https://harrisonlee.net/pages/856225/",target:"_blank",rel:"noopener noreferrer"}},[t._v("上一篇文章"),v("OutboundLink")],1),t._v("中，讨论了缓存一致性的概念以及VI协议，本文讨论的MSI协议可以很好地解决VI协议需要高总线带宽，效率不高的缺点。而且导致VI协议有这样缺点的原因是因为其采用了写通策略，所以本文讨论的MSI协议采用写回策略。")]),t._v(" "),v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),v("p",[t._v("同样地，本文的讨论也是基于总线架构的嗅探机制，采用写分配和写失效策略。")])]),t._v(" "),v("h2",{attrs:{id:"概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),v("p",[t._v("首先，MSI协议中定义缓存块有三种状态：")]),t._v(" "),v("ul",[v("li",[t._v("已修改（Modified）："),v("strong",[t._v("该缓存块仅在一个核芯内有效")]),t._v("，且被修改过，其值可能不同于主存中的值，可以被读和写。")]),t._v(" "),v("li",[t._v("共享（Shared）：该缓存块有效，可能只被一个核芯所独享，也可能被多个核芯所共享（在此协议中不进行区分），可以被读，但是不能被写。")]),t._v(" "),v("li",[t._v("无效（Invalid）：该缓存块无效，不可以被读和写。")])]),t._v(" "),v("p",[t._v("为了便于下面讨论，现规定一些操作及其术语：")]),t._v(" "),v("p",[t._v("处理器端的请求：")]),t._v(" "),v("ul",[v("li",[t._v("PrRd：处理器端的读。")]),t._v(" "),v("li",[t._v("PrWr：处理器端的写。")])]),t._v(" "),v("p",[t._v("总线端的事务（嗅探器所要监听的事务）：")]),t._v(" "),v("ul",[v("li",[t._v("BusRd：总线读事务。")]),t._v(" "),v("li",[t._v("BusRdX：总线排他读事务。")]),t._v(" "),v("li",[t._v("Flush：总线刷新事务，将数据写入主存。")])]),t._v(" "),v("h2",{attrs:{id:"缓存块的状态转换"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存块的状态转换"}},[t._v("#")]),t._v(" 缓存块的状态转换")]),t._v(" "),v("p",[t._v("MSI协议的有限状态机如下图所示（左半部分是处理器端，右半部分是嗅探器端）：")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://cdn.harrisonlee.net/image-20201220122605848.png",alt:"image-20201220122605848"}})]),t._v(" "),v("h3",{attrs:{id:"处理器端引起的状态转换"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#处理器端引起的状态转换"}},[t._v("#")]),t._v(" 处理器端引起的状态转换")]),t._v(" "),v("p",[t._v("当缓存块的状态为无效时（可能是该缓存块不存在或该缓存块存在且其状态为无效）：")]),t._v(" "),v("ul",[v("li",[t._v("当处理器读时，同时会产生总线读，然后将其状态设置为Shared。")]),t._v(" "),v("li",[t._v("当处理器写时，先产生一个总线排他读事务，读取到最新数据，然后处理器进行写操作，最后其状态为Modified。")])]),t._v(" "),v("p",[t._v("当缓存块的的状态为共享时：")]),t._v(" "),v("ul",[v("li",[t._v("处理器读，缓存命中，所以不会产生总线读事务，状态不变。")]),t._v(" "),v("li",[t._v("处理器写时，先进行总线排他读，让其他副本失效，然后再写，最后其状态为Modified。")])]),t._v(" "),v("p",[t._v("当缓存块的状态为已修改时：")]),t._v(" "),v("ul",[v("li",[t._v("处理器的读/写请求均不会导致总线事务，也不会导致其状态改变（因为所有缓存中仅有当前一份副本，所以无论怎么修改，都不会改变状态）。")])]),t._v(" "),v("h3",{attrs:{id:"嗅探器端引起的状态转换"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#嗅探器端引起的状态转换"}},[t._v("#")]),t._v(" 嗅探器端引起的状态转换")]),t._v(" "),v("p",[t._v("当缓存块的状态为无效时：")]),t._v(" "),v("ul",[v("li",[t._v("当嗅探器监听到关于此缓存块的总线读或总线排他读时，一致性控制器不做任何操作。")])]),t._v(" "),v("p",[t._v("当缓存块的状态为共享态时：")]),t._v(" "),v("ul",[v("li",[t._v("当嗅探器监听到总线读时，说明其他核芯发生缓存未命中，由于是主存提供数据，所以一致性控制器不做任何操作。")]),t._v(" "),v("li",[t._v("当嗅探器监听到"),v("strong",[t._v("总线排他读")]),t._v("时，说明其他核芯准备写，一致性控制器将其内部对应的缓存块置为无效。")])]),t._v(" "),v("p",[t._v("当缓存块的状态为已修改时：")]),t._v(" "),v("ul",[v("li",[t._v("当嗅探器监听到总线读时，此时一致性控制器必须将已修改的数据刷新回主存，否则其他核芯会读取到脏数据，最后的状态为Shared。主存会在所有一致性控制器响应后再完成请求，所以主存先接收到刷新请求，然后再响应，所以确保了读取到的数据是最新的。")]),t._v(" "),v("li",[t._v("当嗅探器监听到排他读时，此时一致性控制器必须将已修改的数据刷新回主存，并将对应的缓存块置为无效。"),v("font",{attrs:{color:"deeppink"}},[t._v("这里刷新看似多余，因为其他核芯进行的是写操作，就算读到了最新的数据，但是立马又被覆盖了。（这的确是一个容易被忽略的点）")]),t._v("其实不然，比如核芯1修改了缓存块A的第1个字和第3个字的数据，而核芯2也要修改第1个字的数据，但是修改完后要读取第3个字的数据，如果写之前读取不到最新的数据，那么会导致读取到的第3个字为脏数据。")],1)]),t._v(" "),v("div",{staticClass:"custom-block note"},[v("p",{staticClass:"custom-block-title"},[t._v("笔记")]),t._v(" "),v("p",[t._v("当发起排他读请求的核芯监听到刷新请求时，可以将其读取到自己所属的缓存中，就不用等主存响应了，从而提升了效率。同时，主存仍然要监听刷新请求，以更新主存中的数据。")])]),t._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),v("p",[t._v("可以发现，状态的转换一定会通过总线事务，而总线事务不一定会导致状态的转换。写失效是通过总线排他读实现的，当嗅探器监听到该事务，使其内部的缓存块失效（状态为共享时）或者是刷新（状态为已更新时）。")]),t._v(" "),v("p",[t._v("MSI协议采用了写回而不是写通，所以降低了总线带宽的负荷。但是会导致发起更多的总线事务，比如修改状态为共享的缓存块，无论其他缓存中是否有该缓存块，都要发起总线排他读让其他副本失效，如果其他缓存中都没有该缓存块，那么该请求就是多余的。所以，MSI中shared状态还可以进一步分解，具体细节请看下回关于MESI的分析。")]),t._v(" "),v("h2",{attrs:{id:"参考"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://www.amazon.com/Fundamentals-Parallel-Multicore-Architecture-Solihin/dp/0367575280/ref=sr_1_1?crid=FJCGUSB0DB5A&dchild=1&keywords=fundamentals+of+parallel+multicore+architecture&qid=1607872319&sprefix=fundamental+of+para%2Caps%2C415&sr=8-1",target:"_blank",rel:"noopener noreferrer"}},[t._v("Fundamentals of Parallel Multicore Architecture"),v("OutboundLink")],1)])])])}),[],!1,null,null,null);_.default=r.exports}}]);