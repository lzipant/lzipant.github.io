(window.webpackJsonp=window.webpackJsonp||[]).push([[37],{554:function(t,a,s){"use strict";s.r(a);var e=s(16),i=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("多核CPU真正实现了程序的并行，然而现实中很多常见的CPU拥有多级缓存架构，某些处理器架构（如intel skylake）中的缓存就分为三层，其中"),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("L")]),s("mn",[t._v("1")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("L1")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"0.68333em","vertical-align":"0em"}}),s("span",{staticClass:"mord mathdefault"},[t._v("L")]),s("span",{staticClass:"mord"},[t._v("1")])])])])]),t._v("和"),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("L")]),s("mn",[t._v("2")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("L2")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"0.68333em","vertical-align":"0em"}}),s("span",{staticClass:"mord mathdefault"},[t._v("L")]),s("span",{staticClass:"mord"},[t._v("2")])])])])]),t._v("为核芯独享，"),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("L")]),s("mn",[t._v("3")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("L3")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"0.68333em","vertical-align":"0em"}}),s("span",{staticClass:"mord mathdefault"},[t._v("L")]),s("span",{staticClass:"mord"},[t._v("3")])])])])]),t._v("为所有核芯共享。虽然缓存大大提升了处理器的效率，但是当访问共享内存的多个线程在不同的核芯上执行时，可能会导致一个很严重的问题--缓存一致性。")],1),t._v(" "),s("h2",{attrs:{id:"概述"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[t._v("#")]),t._v(" 概述")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("CPU核芯之间如何组织以及如何互联对设计缓存一致性协议有非常大的影响。本文目前仅对基于总线的架构进行讨论，例如其他点对点（point-to-point）的架构暂时不讨论。")])]),t._v(" "),s("p",[t._v("导致缓存一致性的原因是多个核芯的私有缓存中有同样的缓存块，而其中某个缓存块被修改了，但是其他的核芯对此毫无察觉（就算核芯采用写通策略，也无法让其他核芯感知），继续读取到其私有缓存中的脏数据。")]),t._v(" "),s("p",[t._v("解决上述问题也就是实现缓存一致性需要保证两点：")]),t._v(" "),s("ul",[s("li",[t._v("写传播：即让核芯感知到其他核芯内的数据修改。")]),t._v(" "),s("li",[t._v("事务串行化：多个核芯同一段时间内对同一缓存块的修改的先后顺序在其他所有核芯看来是一致的。")])]),t._v(" "),s("p",[t._v("写传播有两种方式来实现，写失效和写更新：")]),t._v(" "),s("ul",[s("li",[t._v("写失效（write invalidate）：在核芯准备更新缓存时，通知其他的核芯让其内部的该缓存块失效。当需要多次修改时，这种方法比较高效（后序修改不用再让其他缓存块失效）。")]),t._v(" "),s("li",[t._v("写更新（write update）：在核芯准备更新缓存时，通知其他的核芯修改其内部对应的数据。当修改完后，其他核芯需要读数据时，该方法比较高效。")])]),t._v(" "),s("p",[t._v("如果是基于总线实现缓存一致性的话，那么天然支持事务串行化，因为多个设备要使用总线，首先要经过总线仲裁，由仲裁器来决定使用的先后顺序。注意，总线不一定是同步的，即不一定是先读完某个缓存块后再写某个缓存块，有可能是在发起读取请求后，就开始写操作了，这样的总线称作为"),s("strong",[t._v("异步总线")]),t._v("。异步总线相比同步总线的优点是吞吐量大，效率高。")]),t._v(" "),s("h2",{attrs:{id:"总线嗅探"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总线嗅探"}},[t._v("#")]),t._v(" 总线嗅探")]),t._v(" "),s("p",[t._v("基于总线的缓存一致性重点是如何实现写传播，本文来分析广播/嗅探（broadcast/snoop）机制。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("广播/嗅探机制是实现写传播的方式中的一种，除此之外，还有目录（directory）机制。前者的优点是实现简单，缺点是可扩展性差。后者的优点是可扩展性高，缺点是需要额外的存储空间。")])]),t._v(" "),s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[t._v("注意")]),t._v(" "),s("p",[t._v("在具体讨论该机制前，首先说明一下：上面也说到了，三级缓存中"),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("L")]),s("mn",[t._v("1")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("L1")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"0.68333em","vertical-align":"0em"}}),s("span",{staticClass:"mord mathdefault"},[t._v("L")]),s("span",{staticClass:"mord"},[t._v("1")])])])])]),t._v("和"),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("L")]),s("mn",[t._v("2")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("L2")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"0.68333em","vertical-align":"0em"}}),s("span",{staticClass:"mord mathdefault"},[t._v("L")]),s("span",{staticClass:"mord"},[t._v("2")])])])])]),t._v("都是核芯私有的，而"),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("L")]),s("mn",[t._v("3")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("L3")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"0.68333em","vertical-align":"0em"}}),s("span",{staticClass:"mord mathdefault"},[t._v("L")]),s("span",{staticClass:"mord"},[t._v("3")])])])])]),t._v("是多个核芯共享的。下述讨论中，把"),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("L")]),s("mn",[t._v("1")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("L1")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"0.68333em","vertical-align":"0em"}}),s("span",{staticClass:"mord mathdefault"},[t._v("L")]),s("span",{staticClass:"mord"},[t._v("1")])])])])]),t._v("和"),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("L")]),s("mn",[t._v("2")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("L2")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"0.68333em","vertical-align":"0em"}}),s("span",{staticClass:"mord mathdefault"},[t._v("L")]),s("span",{staticClass:"mord"},[t._v("2")])])])])]),t._v("看成一级缓存，同时把"),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("L")]),s("mn",[t._v("3")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("L3")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"0.68333em","vertical-align":"0em"}}),s("span",{staticClass:"mord mathdefault"},[t._v("L")]),s("span",{staticClass:"mord"},[t._v("3")])])])])]),t._v("看作是主存。至于L3如何把数据同步到真实的主存中暂时不讨论。")],1),t._v(" "),s("p",[t._v("由于CPU的架构“千奇百怪”，不可能把所有的情况都讨论完，本文只讨论一些常见的，然后在写程序时心里有底就行了。")])]),t._v(" "),s("p",[t._v("连接缓存总线的各方都有一个一致性控制器，其示意图如下：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.harrisonlee.net/image-20201219142943093.png",alt:"image-20201219142943093"}})]),t._v(" "),s("ul",[s("li",[t._v("事务表（Outstanding Transaction Table）：保存由当前核芯发起的未完成的总线事务表。")]),t._v(" "),s("li",[t._v("总线嗅探器（snooper）：监听总线上的事务。当其接收到信号时，控制器检测缓存内的tag是否需要响应该总线事务。")]),t._v(" "),s("li",[t._v("有限状态机（FSM）：判断缓存块的状态如何改变。后面分析缓存一致性协议的时候会讲到。")]),t._v(" "),s("li",[t._v("写回缓存区（write back buffer）：所有需要写回的缓存块先保存到该缓存区中。")])]),t._v(" "),s("p",[t._v("对于不同的写传播方式，其一致性控制器的行为是不一样的，而且真实情况下，其控制器的构造也可能和上述图示如出一辙，但是其作用是类似的。（我们不是CPU设计者，不用太纠结）")]),t._v(" "),s("h2",{attrs:{id:"采用写通的缓存一致性协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#采用写通的缓存一致性协议"}},[t._v("#")]),t._v(" 采用写通的缓存一致性协议")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("现实中，该方案很少被使用，但是分析该案例有利于理解后面的各种协议。这里假设采用的是写不分配和写失效策略。")])]),t._v(" "),s("p",[t._v("该协议定义了缓存块具有两个状态：")]),t._v(" "),s("ul",[s("li",[t._v("Valid：该缓存块有效（该缓存块在整个存储系统中的所有副本的值都一致）。")]),t._v(" "),s("li",[t._v("Invalid：该缓存块无效，读取该缓存块时会导致缓存未命中。")])]),t._v(" "),s("p",[t._v("因此，该协议又简称为"),s("strong",[t._v("VI")]),t._v("。在分析问题之前，先约定一些简称如下：")]),t._v(" "),s("p",[t._v("处理器端：")]),t._v(" "),s("ul",[s("li",[t._v("PrRd：处理器端请求读一个缓存块。")]),t._v(" "),s("li",[t._v("PrWr：处理器端请求写一个缓存块。")])]),t._v(" "),s("p",[t._v("嗅探器端：")]),t._v(" "),s("ul",[s("li",[t._v("BusRd：监听其他核芯发起的读请求事件。")]),t._v(" "),s("li",[t._v("BusWr：监听其他核芯发起的写请求事件。")])]),t._v(" "),s("p",[t._v("注意，由于是写通，那么核芯私有缓存内的数据会被写到主存中。")]),t._v(" "),s("p",[t._v("缓存块的状态转换过程如下图所示（处理器端的请求对应图中左半部分，嗅探器端对应右半部分）：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.harrisonlee.net/image-20201219170124778.png",alt:"image-20201219170124778"}})]),t._v(" "),s("p",[t._v("处理器端：")]),t._v(" "),s("ul",[s("li",[t._v("处理器读（同时产生总线读）会导致缓存块由无效状态转变为有效状态。"),s("font",{attrs:{color:"deeppink"}},[t._v("这里的I状态表示了两种情况，一是缓存块不在缓存中，二是缓存块确实是无效状态。")])],1),t._v(" "),s("li",[t._v("当缓存有效时，处理器写后仍然有效（同时也会更新缓存块），由于是写通，所以会导致总线写。")]),t._v(" "),s("li",[t._v("当缓存无效时，如果缓存块不存在，由于是写不分配，所以写后还是无效状态。因为是写通和写不分配，所以不会在缓存中保存缓存块，所以最终还是保持无效记录。")])]),t._v(" "),s("p",[t._v("嗅探器端：")]),t._v(" "),s("ul",[s("li",[t._v("如果缓存块有效，当监听到总线读（说明其他核芯在读）时，由于应该从主存中读取，所以一致性控制器不做任何操作，其状态仍然是有效。")]),t._v(" "),s("li",[t._v("如果缓存块无效，不管监听到总线读还是总线写，一致性控制器都不做任何操作，所以器状态仍然是无效。")]),t._v(" "),s("li",[t._v("如果缓存块有效，且监听到了总线写（说明其他核芯在写），那么一致性控制器将其状态更改为无效。当处理器再读时，发生缓存未命中，从而从主存中读取，又因为总线仲裁器不会允许同一缓存块的读写操作并行（不同块的读写操作可以并行），所以读取到的只能是最新的值（因为是先写后读），从而保证了缓存一致性。")])]),t._v(" "),s("p",[s("strong",[t._v("VI")]),t._v("协议可以保证缓存一致性，虽然简单，但是占用总线带宽以及效率不高，在上述分析中处理器端的第三点讲到：缓存块无效时，都会产生总线写（占用大量总线带宽）；同时当下次读时，又会从主存中读（效率不高）。**究其原因，是因为采用了写通策略。**如果采用写回，就可以避免该问题，但是会引入更多的状态，使得整个协议变得复杂，所以如果采用了写回策略，那么VI协议就不再是VI协议了。如果采用写分配策略，那么在无效状态时，需要先读取，然后再多级写，导致时延大大增加，所以这种方法也不太好。")]),t._v(" "),s("p",[t._v("关于采用写回策略的其他协议，在后序文章中进行分析。")]),t._v(" "),s("h2",{attrs:{id:"参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),s("ul",[s("li",[s("p",[s("a",{attrs:{href:"https://www.amazon.com/Fundamentals-Parallel-Multicore-Architecture-Solihin/dp/0367575280/ref=sr_1_1?crid=FJCGUSB0DB5A&dchild=1&keywords=fundamentals+of+parallel+multicore+architecture&qid=1607872319&sprefix=fundamental+of+para%2Caps%2C415&sr=8-1",target:"_blank",rel:"noopener noreferrer"}},[t._v("Fundamentals of Parallel Multicore Architecture"),s("OutboundLink")],1)])]),t._v(" "),s("li",[s("p",[s("a",{attrs:{href:"https://course.ece.cmu.edu/~ece600/fall17/lectures/lecture17.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("卡内基梅隆大学的课件"),s("OutboundLink")],1)])]),t._v(" "),s("li",[s("p",[s("a",{attrs:{href:"http://web.cs.wpi.edu/~cs4515/d15/Protected/LecturesNotes_D15/Week3_TeamA_i7-Presentation.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("伍斯特理工学院的课件"),s("OutboundLink")],1)])]),t._v(" "),s("li",[s("p",[s("a",{attrs:{href:"https://www.cs.utah.edu/~rajeev/cs7820/pres/7820-07.pdf",target:"_blank",rel:"noopener noreferrer"}},[t._v("犹他州立大学的课件"),s("OutboundLink")],1)])])])])}),[],!1,null,null,null);a.default=i.exports}}]);