(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{533:function(t,a,s){"use strict";s.r(a);var e=s(16),i=Object(e.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("p",[t._v("集合可以说是无处不在，我们日常的业务代码以及各种框架底层实现都大量使用集合。集合是存储和管理数据的工具，不同集合采用不同的数据结构，这些数据结构本身并无优劣之分，但是在特定场景下其效率将会产生天壤之别。所以，熟练掌握各种集合以及底层的实现原理对系统开发至关重要。")]),t._v(" "),s("h2",{attrs:{id:"集合体系概览"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#集合体系概览"}},[t._v("#")]),t._v(" 集合体系概览")]),t._v(" "),s("p",[t._v("Java集合类库将接口与实现分离，接口定义了基本操作，实现决定采用哪种数据结构来存储数据以及如何实现这些操作。Java集合体系中的接口如下图所示：")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.harrisonlee.net/image-20210118125902726.png",alt:"Java集合框架中的接口"}})]),t._v(" "),s("p",[t._v("整个体系可以分为四部分：")]),t._v(" "),s("ul",[s("li",[s("p",[s("code",[t._v("RandomAccess")]),t._v("：这个接口不包含任何方法，属于一个标记接口。可以用它来测试一个特定的集合是否支持高效的"),s("strong",[t._v("随机访问")]),t._v("。")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("Iterator")]),t._v("：迭代器，可以用来对iterable对象进行迭代和删除操作。")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("Collection")]),t._v("：单列集合，存储某一类型的数据。一共有三个子接口分别是"),s("code",[t._v("List")]),t._v("，"),s("code",[t._v("Set")]),t._v("，"),s("code",[t._v("Queue")]),t._v("，分别表示列表，集合（不同于本文所属的广义上的集合，而是数学概念中的集合），队列。另外，以前Java提供了关于栈的实现，但是由于其效率不太高，已不推荐使用，可以使用双端队列来模拟。")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("Map")]),t._v("：双列集合，存储键和值的映射关系。关于为什么"),s("code",[t._v("Map")]),t._v("不继承于"),s("code",[t._v("Collection")]),t._v("，Java官方给出的回答时"),s("code",[t._v("Collection")]),t._v("的这种单列关系无法表示"),s("code",[t._v("Map")]),t._v("中的双列关系，就算把map中的键值对封装为entry存入collection中，那么无法直接根据键获取到值，也无法直接根据键删除一对键值。")])])]),t._v(" "),s("h2",{attrs:{id:"基础数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基础数据结构"}},[t._v("#")]),t._v(" 基础数据结构")]),t._v(" "),s("p",[t._v("其实根据存储特点，本质上就两种数据结构--数组和链表，其他比如队列，栈，树，图等都是基于数组和链表来实现的，"),s("strong",[t._v("数组和链表属于物理数据结构，而队列和栈等更像是逻辑数据结构")]),t._v("。不管是"),s("code",[t._v("Collection")]),t._v("的各个子接口还是"),s("code",[t._v("Map")]),t._v("，都提供了基于不同数据结构的实现，这些不同的实现具有不同的使用场景。所以，在项目中要根据业务逻辑合理选择使用哪种容器，不要一股脑地使用"),s("code",[t._v("ArrayList")]),t._v("存储元素，"),s("code",[t._v("HashMap")]),t._v("存储映射关系。")]),t._v(" "),s("h3",{attrs:{id:"数组"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数组"}},[t._v("#")]),t._v(" 数组")]),t._v(" "),s("p",[t._v("数组是两大基础数据结构之一。数组表示一组"),s("strong",[t._v("连续")]),t._v("存储的数据，正是因为连续的特性，所以数组随机访问的效率很高，只需"),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("O")]),s("mo",{attrs:{stretchy:"false"}},[t._v("(")]),s("mn",[t._v("1")]),s("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(1)")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),s("span",{staticClass:"mopen"},[t._v("(")]),s("span",{staticClass:"mord"},[t._v("1")]),s("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v("的时间复杂度；不过也正是因为连续，所以导致插入和删除操作效率不如链表，因为插入和删除会导致数组元素的移动，时间复杂度为"),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("O")]),s("mo",{attrs:{stretchy:"false"}},[t._v("(")]),s("mi",[t._v("n")]),s("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n)")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),s("span",{staticClass:"mopen"},[t._v("(")]),s("span",{staticClass:"mord mathdefault"},[t._v("n")]),s("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v("。")],1),t._v(" "),s("h3",{attrs:{id:"链表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[t._v("#")]),t._v(" 链表")]),t._v(" "),s("p",[t._v("链表是两大基础数据结构之一。链表和数组是互补的，因为数组的优点刚好是链表的缺点，数组的缺点刚好是链表的优点。所以，链表不能随机访问，如果要访问某个元素，需要遍历整个链表，时间复杂度为"),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("O")]),s("mo",{attrs:{stretchy:"false"}},[t._v("(")]),s("mi",[t._v("n")]),s("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n)")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),s("span",{staticClass:"mopen"},[t._v("(")]),s("span",{staticClass:"mord mathdefault"},[t._v("n")]),s("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v("；但是链表适合插入和删除，时间复杂度仅为"),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("O")]),s("mo",{attrs:{stretchy:"false"}},[t._v("(")]),s("mn",[t._v("1")]),s("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(1)")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),s("span",{staticClass:"mopen"},[t._v("(")]),s("span",{staticClass:"mord"},[t._v("1")]),s("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v("。")],1),t._v(" "),s("h2",{attrs:{id:"java中的集合实现"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java中的集合实现"}},[t._v("#")]),t._v(" Java中的集合实现")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://cdn.harrisonlee.net/image-20210118154544460.png",alt:"Java中的集合实现"}})]),t._v(" "),s("h3",{attrs:{id:"列表"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#列表"}},[t._v("#")]),t._v(" 列表")]),t._v(" "),s("p",[s("strong",[t._v("列表存储了一组逻辑上并无关联的同一类型的数据")]),t._v("，采用数组和链表实现均可。如"),s("code",[t._v("ArrayList")]),t._v("采用数组，"),s("code",[t._v("LinkedList")]),t._v("采用链表。")]),t._v(" "),s("h3",{attrs:{id:"队列和栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#队列和栈"}},[t._v("#")]),t._v(" 队列和栈")]),t._v(" "),s("p",[t._v("队列和栈主要用来实现某种特定策略，比如队列可以用来实现先进先出（FIFO），栈可以用来实现先进后出（LIFO）。队列和栈既可以使用数组也可以使用链表来实现。使用数组实现的队列有"),s("code",[t._v("ArrayDeque")]),t._v("，这是一个双端队列，可以用来实现栈；使用链表存储的队列有"),s("code",[t._v("LinkedBlockingDeque")]),t._v("，这是一个双端阻塞队列的实现。")]),t._v(" "),s("h3",{attrs:{id:"映射"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#映射"}},[t._v("#")]),t._v(" 映射")]),t._v(" "),s("p",[t._v("尽管数组可以实现随机访问，但是当访问元素之前必须要知道相应的下标，否则还是要像链表一样进行遍历操作，时间复杂度为"),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("O")]),s("mo",{attrs:{stretchy:"false"}},[t._v("(")]),s("mi",[t._v("n")]),s("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(n)")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),s("span",{staticClass:"mopen"},[t._v("(")]),s("span",{staticClass:"mord mathdefault"},[t._v("n")]),s("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v("。"),s("code",[t._v("Map")]),t._v("接口定义的根据键来获取值的操作可以让查找的时间复杂度降低至"),s("eq",[s("span",{staticClass:"katex"},[s("span",{staticClass:"katex-mathml"},[s("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[s("semantics",[s("mrow",[s("mi",[t._v("O")]),s("mo",{attrs:{stretchy:"false"}},[t._v("(")]),s("mn",[t._v("1")]),s("mo",{attrs:{stretchy:"false"}},[t._v(")")])],1),s("annotation",{attrs:{encoding:"application/x-tex"}},[t._v("O(1)")])],1)],1)],1),s("span",{staticClass:"katex-html",attrs:{"aria-hidden":"true"}},[s("span",{staticClass:"base"},[s("span",{staticClass:"strut",staticStyle:{height:"1em","vertical-align":"-0.25em"}}),s("span",{staticClass:"mord mathdefault",staticStyle:{"margin-right":"0.02778em"}},[t._v("O")]),s("span",{staticClass:"mopen"},[t._v("(")]),s("span",{staticClass:"mord"},[t._v("1")]),s("span",{staticClass:"mclose"},[t._v(")")])])])])]),t._v("。映射可以使用hash和树来实现，注意映射并不等于hash，hash只是一种实现方式。一般像是"),s("code",[t._v("HashMap")]),t._v("， "),s("code",[t._v("LinkedHashMap")]),t._v("，"),s("code",[t._v("TreeMap")]),t._v("等，都综合运用了多种数据接口，如"),s("code",[t._v("HashMap")]),t._v("中就用了数组，链表，红黑树。")],1),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("关于树为什么能够实现映射以及为什么使用红黑树，这里说一下鄙人的拙见。映射的本质是提高查找的效率，而有些树也很有利于查找，比如二叉查找树，但是由于二叉查找树可能存在让查找线性化的问题（左斜树或右斜树），所以一般采用平衡二叉树来避免这个问题，平衡二叉树的定义是指左右子树的高度差不超过1，AVL树严格地实现了这样的要求。但是可能是实践实现，发现AVL树在使用中花费了大量时间用于维护自身的平衡结构，效率不太高（尽管可以优化）。红黑树算是一种非严格的平衡二叉树，对平衡的要求没有那么苛刻（当然也带来了复杂度），从而提高了查找的效率。")]),t._v(" "),s("p",[t._v("B树或者B+树更多用于需要与磁盘打交道的场景，如数据库，目的是让整棵树变矮（减少与磁盘的交互次数）。关于B树或B+树与红黑树的查找效率对比可见下图，至于为什么Java设计团队要使用红黑树而不使用B树或B+树，这应该属于设计问题吧（其实也没什么不可以的）。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://pic4.zhimg.com/80/v2-3b0dd24fe1bc5e5940cc405233ce1e0e_720w.jpg?source=1940ef5c",alt:"多种查找树效率对比"}})])]),t._v(" "),s("h3",{attrs:{id:"线程安全"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#线程安全"}},[t._v("#")]),t._v(" 线程安全")]),t._v(" "),s("p",[t._v("上面的讨论中是假设在单线程中，如果在多线程场景中，对集合的操作可能会导致集合内部数据结构的紊乱，所以需要采取相应手段来确保集合操作的线程安全性。在很早以前，Java提供的集合框架都是线程安全的（如Vector，Stack，HashTable等），但也带来了很大的问题，因为这些集合中的方法都是由"),s("code",[t._v("synchronized")]),t._v("关键字修饰的，在早期该关键字的效率很低，而且经过实践发现大多数时候对于集合的操作还是在单线程中的，这样导致集合操作的效率很低了，这也是不推荐使用stack来实现栈，而使用"),s("code",[t._v("Deque")]),t._v("的实现类来代替的原因。")]),t._v(" "),s("p",[t._v("但多线程的问题还是存在的，除了上述的遗留安全类集合，Java还提供了其他关于线程安全的集合类。整个Java中的线程安全集合可以分为三大类：")]),t._v(" "),s("ul",[s("li",[t._v("遗留的安全集合：如HashTable，Vector等。")]),t._v(" "),s("li",[t._v("修饰的安全集合：Collections类提供了很多以“Synchronized”开头的修饰类，如"),s("code",[t._v("SynchronizedMap")]),t._v("，"),s("code",[t._v("SynchronizedList")]),t._v("等。这些修饰类的内部利用"),s("strong",[t._v("装饰器模式")]),t._v("通过"),s("code",[t._v("synchronized")]),t._v("关键字来保证对原线程不安全的集合操作的线程安全。虽然近年来"),s("code",[t._v("synchronized")]),t._v("关键字的性能得到了优化，但是还有更好的实现。")]),t._v(" "),s("li",[t._v("JUC并发包提供的安全集合：\n"),s("ul",[s("li",[t._v("Blocking类：大部分实现基于锁（显式锁），并提供用来阻塞线程的方法。")]),t._v(" "),s("li",[t._v("CopyOnWrite类：修改时拷贝，适用于读多写少的场景，因为拷贝的代价较高。")]),t._v(" "),s("li",[t._v("Concurrent类：内部很多操作采用CAS优化，利用分段锁来提供较高的吞吐量。但是这类容器具有"),s("strong",[t._v("弱一致性")]),t._v("，即在遍历容器时，虽然遍历操作可以进行，但是遍历读取到的内容可能是旧数据；还有就是求大小的弱一致性，size方法返回的未必就是真正的size。")])])])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("对于线程不安全的集合，如果发送了并发修改，会抛出"),s("code",[t._v("ConcurrentModificationException")]),t._v("（可以参考"),s("a",{attrs:{href:"https://harrisonlee.net/pages/574b5f/",target:"_blank",rel:"noopener noreferrer"}},[t._v("另一篇文章"),s("OutboundLink")],1),t._v("），这种称为fail-fast机制，只是让遍历结束，而不能保证线程安全性。对于线程安全的集合并发访问不会导致失败，这种机制称为fail-safe。")])])])}),[],!1,null,null,null);a.default=i.exports}}]);